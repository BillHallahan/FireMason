
==================== FINAL INTERFACE ====================
2016-07-25 02:59:01.800085 UTC

interface main@main:ConvertToHorn 7103
  interface hash: 0610bbb8e87da07a9c0f6a8e3d00abc2
  ABI hash: 6cb55903d556cefafac546a1c5981ddc
  export-list hash: b5f037d6452ad3c0b4404302332b70f7
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: a0aab809f050b6a8c91e361e2a7bef92
  sig of: Nothing
  used TH splices: False
  where
exports:
  ConvertToHorn.condenseAnd
  ConvertToHorn.condenseOr
  ConvertToHorn.eliminateOr
  ConvertToHorn.inputChainToChain
  ConvertToHorn.inputCriteriaToCriteria
  ConvertToHorn.simplifyNots
  ConvertToHorn.stringInputChainsToStringChains
module dependencies: Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  Types d93d85b9feb9e7bdde739bd993ea6c3d
  exports: fd7624f994dcfddcd82d0e50111df34c
  And 4de7897e246a7edb96c8c21ecc274d04
  Chain 2f2d7ed8f6319c449172a96c30c14176
  Criteria acb8f9fefaf08e84cf768fcbabc1ff7f
  InC 89df2708ca41954f266c45677191f36a
  InCNot 03518b0f0fbd13e0d1b434830fd64692
  InputChain f771e3b40964f50130390d908f4a6084
  InputCriteria 7ffc5977565cf554c6bbed570d4e0be9
  InputRule 7ffc5977565cf554c6bbed570d4e0be9
  Not b2e9458a7b472c9990f1385f350bbac6
  Or 03d2255cec70f50054798bfa83da3a89
  PropVariableCriteria d86055bfb315a3f95643eebccd4771bd
  PropVariableTarget d7cace759dc39a5f0c0dafff9f565d03
  Rule c4715c6ecf27c8f6cfa2722e3604c3a0
  Rule acb8f9fefaf08e84cf768fcbabc1ff7f
  criteria 5953dec82ab8a201003cb58763e11434
  label c65f7a8ae4595fcc377a6ac50005b49f
  targets cd7d556154124ef351aeffc69e7ba5a4
7dbd3a7ce422d367c93fa0f36dbe6885
  $weliminateOr ::
    Types.InputCriteria
    -> GHC.Types.Int -> (# Types.Criteria, [Types.InputRule] #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ w :: Types.InputCriteria w1 :: GHC.Types.Int ->
                 case w of wild {
                   DEFAULT
                   -> case ConvertToHorn.eliminateOr2 wild
                      ret_ty (# Types.Criteria, [Types.InputRule] #)
                      of {}
                   Types.Or c
                   -> (# Types.PropVariableCriteria w1,
                         GHC.Types.:
                           @ Types.InputRule
                           (Types.Rule
                              @ Types.InputCriteria
                              (GHC.Base.map
                                 @ Types.InputCriteria
                                 @ Types.InputCriteria
                                 Types.InCNot
                                 c)
                              (GHC.Types.:
                                 @ Types.Target
                                 (Types.PropVariableTarget w1 GHC.Types.False)
                                 (GHC.Types.[] @ Types.Target))
                              ConvertToHorn.eliminateOr1)
                           (GHC.Base.map
                              @ Types.InputCriteria
                              @ (Types.GenRule Types.InputCriteria)
                              (\ c' :: Types.InputCriteria ->
                               Types.Rule
                                 @ Types.InputCriteria
                                 (GHC.Types.:
                                    @ Types.InputCriteria
                                    c'
                                    (GHC.Types.[] @ Types.InputCriteria))
                                 (GHC.Types.:
                                    @ Types.Target
                                    (Types.PropVariableTarget w1 GHC.Types.True)
                                    (GHC.Types.[] @ Types.Target))
                                 ConvertToHorn.eliminateOr1)
                              c) #) }) -}
a72aa08c1a0a1b5b69df6f6f6e4bb3a1
  $winputCriteriaToCriteria ::
    [Types.InputCriteria]
    -> GHC.Types.Int
    -> (# [Types.Criteria], [Types.InputRule], GHC.Types.Int #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>,
     Inline: [0] -}
e2c6c9a5eb527c545d63b7b7670e02d4
  condenseAnd :: [Types.InputCriteria] -> [Types.InputCriteria]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
9b54a6181d32c77079487fee69dddfe9
  condenseOr :: [Types.InputCriteria] -> [Types.InputCriteria]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
61d9fe49467467bfd5e4abfc4b8e8834
  eliminateOr ::
    Types.InputCriteria
    -> GHC.Types.Int -> (Types.Criteria, [Types.InputRule])
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.InputCriteria w1 :: GHC.Types.Int ->
                 case ConvertToHorn.$weliminateOr w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
b2bc19829deb639a8cb7ffbcbef48c0a
  eliminateOr1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# (-1)) -}
6a7b0033421d8e2ffb7267471c99bfbd
  eliminateOr2 ::
    Types.InputCriteria -> (Types.Criteria, [Types.InputRule])
  {- Arity: 1, Strictness: <L,U>b -}
200ff50174c099fea2e524848b11cf4a
  inputChainToChain ::
    [Types.InputRule] -> GHC.Types.Int -> [Types.Rule]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)> -}
0eb4d3e5812db8a86e2c4584dd72fc10
  inputCriteriaToCriteria ::
    [Types.InputCriteria]
    -> GHC.Types.Int
    -> ([Types.Criteria], [Types.InputRule], GHC.Types.Int)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.InputCriteria] w1 :: GHC.Types.Int ->
                 case ConvertToHorn.$winputCriteriaToCriteria
                        w
                        w1 of ww { (#,,#) ww1 ww2 ww3 ->
                 (ww1, ww2, ww3) }) -}
bc6c362294bd1424fe8f8fa8ae2bb20c
  simplifyNots :: [Types.InputCriteria] -> [Types.InputCriteria]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
b688331ee6f9618a61b0dd2701c608af
  stringInputChainsToStringChains ::
    [(GHC.Base.String, Types.InputChain)]
    -> GHC.Types.Int -> [(GHC.Base.String, Types.Chain)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U(U)> -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

