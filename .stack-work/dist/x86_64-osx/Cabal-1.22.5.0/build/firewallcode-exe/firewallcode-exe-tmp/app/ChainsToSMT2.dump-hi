
==================== FINAL INTERFACE ====================
2016-09-08 15:10:34.36238 UTC

interface main@main:ChainsToSMT2 7103
  interface hash: 4e70e0d7a3ca957f2bff9cc4ed85ad16
  ABI hash: 151cbb12ba94002d1fd05a122ea1ce24
  export-list hash: 6109aad0b3db01e7a67ec7f2a5544d8e
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: e468f87777beb3fe7114763efe9ccb2f
  sig of: Nothing
  used TH splices: False
  where
exports:
  ChainsToSMT2.chainToSMT
  ChainsToSMT2.convertChainsCheckSMT
  ChainsToSMT2.flagToString
  ChainsToSMT2.notMatchesGo
  ChainsToSMT2.notOverChainEnd
  ChainsToSMT2.notTopLevelPolicy
  ChainsToSMT2.onlyOneTopLevel
  ChainsToSMT2.reachesEnd
  ChainsToSMT2.reachesMatchesGo
  ChainsToSMT2.reachesMatchesGoReturn
  ChainsToSMT2.reachesMatchesReturn
  ChainsToSMT2.reachesMatchesTerminating
  ChainsToSMT2.reachesNoneTarget
  ChainsToSMT2.replaceAllCombinations
  ChainsToSMT2.returnsFrom
  ChainsToSMT2.setupChain
  ChainsToSMT2.stringNumList
  ChainsToSMT2.topLevelPolicy
  ChainsToSMT2.ToSMT{ChainsToSMT2.toSMT ChainsToSMT2.toSMTPath ChainsToSMT2.toSMTPrereq}
module dependencies: NameIdChain ParserHelp SMT Types
package dependencies: MissingH-1.3.0.2@Missi_JQoKIaJuITOBZjt8xhTikH
                      appar-0.1.4@appar_0ov5bpGH3STIB4U7WU8MFi
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0
                      binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      byteorder-1.0.4@byteo_6yQGE3rJo3bBqr3CFoBQ27
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      case-insensitive-1.2.0.7@casei_2hQWsf0VfQP5NW180eleos
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_EalUWgp8NarBYWPbvYAD8I integer-gmp-1.0.0.0
                      iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY
                      mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      network-2.6.3.1@netwo_4FL8hbDqfKm3Q9HV1QK1xw
                      process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      regex-base-0.93.2@regex_47KXx9dLqeO8MNJeizLKhP
                      regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89
                      regex-compat-0.95.1@regex_EyUO1k1s8YNJ81jSdgVW1z
                      semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      tagged-0.8.4@tagge_LPeicl3HxVfGUMMwMEsAE6
                      text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne
                      tostring-0.2.1.1@tostr_3WKXD89KZfc5BSX8Q5dXep
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
                      unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw
                      utf8-string-1.0.1.1@utf8s_L8eKHa7Iv9q7FVKUYW6u4b
                      z3-4.1.0@z3_IihW0G4lPF9JXAMQOHqRN1
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_EalUWgp8NarBYWPbvYAD8I:Data.Hashable.Generic
         main@main:Types
         network-2.6.3.1@netwo_4FL8hbDqfKm3Q9HV1QK1xw:Network.Socket
         regex-base-0.93.2@regex_47KXx9dLqeO8MNJeizLKhP:Text.Regex.Base.Context
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.ByteString
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.Sequence
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.String
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Show
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Addr
                         iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Range
                         semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1:Data.List.NonEmpty
                         semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1:Data.Semigroup
                         tagged-0.8.4@tagge_LPeicl3HxVfGUMMwMEsAE6:Data.Tagged
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw:Data.HashMap.Base
                         unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw:Data.HashSet
import  -/  MissingH-1.3.0.2@Missi_JQoKIaJuITOBZjt8xhTikH:Data.List.Utils ce981cfe310794ef1a8cce64686b662a
import  -/  MissingH-1.3.0.2@Missi_JQoKIaJuITOBZjt8xhTikH:Data.String.Utils 648cc5d90663b3d1816ffda72f371606
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Traversable 7576318f4ef8587ad947f87012b65abf
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  NameIdChain d1ae7110724ba70c0795ca6655d3b92e
  exports: 74b41ccd5fac3af95e652991c2f2c706
  IdNameChain 32bf0a15e7b5b3b6866eaff422615364
  maxId d398903f98cb04af07e6f8ec85f2b02f
  namesChains c99393370b137bb9bb56d2fdf9efcc87
  notTopLevelChains 6b165327151c50f7b572d9d06889af8d
  toList' 1a771825043dbdceb9e05bf9f0c16c99
  topLevelChains ef0c291c2836e267cf2f229d1b35c469
  validIds be8ed11d93c89717d4febb86e2305186
import  -/  ParserHelp c7affdab4be2cddd08133e07d05d3b63
  exports: 4408f0f73d248a4701f2f315f854c188
import  -/  SMT bb0ce52fb4a545f7866ab96873dc4eff
  exports: 5bc876e004c370db3db3ba63df48f8b7
  Assert 682db37814e1f1cbdeba450ddde29970
  DeclareFun b45c20186d79b1398d949f94d9214444
  Implies 546f1fa1db9e5085b48eda42a4913386
  MatchesCriteria e00bf93fd232d5e4e0270a1ff4f5ff51
  MatchesRule eff62e195abbc43a7b655073453108df
  Reaches fc63fa7799c55c071342a1c1b5c3acfd
  ReachesEnd 0c215fc1bc807296273793925fac3be8
  ReachesReturn 63db1d313a778d4f57b31e1abfd1f580
  ReturnsFrom d5cc44675e0631c9d73dc3da0981fc13
  RuleTarget d70ceb84d7318235d028e6d977081ebd
  SMTAnd da3e6007d99cd60ac6236ebbf660a1d3
  SMTEq 802f10dbc396d15021fff739f70210d7
  SMTF1 500c387a25304b862b9ad65cea2a7da1
  SMTF2 48ce250652c0bc709d49fad5ab92e2dc
  SMTInt 06d416672b5c741ce4f51b5e359a1b38
  SMTNot fbeef319aa50de2971f4d2a3ec6cea5c
  SMTOr 95b1274b45916df12a42a6fd6434f399
  SMTString f8c8a89a4eed8f1eec40565dd8f67ece
  TerminatesWith 3f54b665b36d182853f7d1b4fa23e923
  TopLevelChain d94f1d7dac4a5c3fedc5273d987f8225
  printSMTFunc1 4088369a4874ee1f2ed2c3379b8a0ec6
  printSMTFunc2 bfaf08863a9c0888403d3b9d7e511aca
  printSMTFunc3 a213144ea9487708793dc68b27b0bd7d
import  -/  Types 834748e642c4e651373ed10baf19a0ff
  exports: 6f12662abbc00dd4b84bee85c0e4261f
  ACCEPT 08ea8d5ba9c8e5ae84bd818c2cc3ee1f
  ACK 69c02da22bdd3d2b93a2ecc7619dcfe7
  BoolFlag 8e31b955518611cb68524179997dad2b
  Chain 22bad0de0907d94f3e5221ebf3c3d3f0
  Criteria e19364fbcccdcd240635a00eaccbd95c
  DROP e0e88d7e035c9851606c6a03aeae2391
  FIN acd0c3060669504ee79bdaf73850ca14
  Flag 8e33f4fd031cf75e26ef6380dedbc5c6
  Go 4c5408c41de596e0dc952fb3fcb57393
  GoReturn 108205ab09197687b0a03c823482edba
  Not 1adbafabbd7f98320f67479286fd3b91
  Port 175675c7c9254add9716442f319e60d5
  PropVariableCriteria f8c7f0748e176b35a77d1b42c9ba66fe
  PropVariableTarget e516f11b198d68f0c48067d67afcef52
  Protocol 28d217f7cfd42059fccbb1335d04e6b8
  RETURN 3f2ed69b4fdf43af50b4a72bb41f96de
  RST 0a1b39e3163ab3ce4a061f2482b7a7bf
  Rule e845056bfb5def189a003fec7dc08b76
  Rule 57a03d8810fd087706ee2247df704e77
  ST 36c8ca126b5a21d28e5e60d278f46a6b
  SYN 0cbc6e0a2ddace940e82bf819da11d6b
  Source b53eb4518fedc84d30c0b4327bd32c7d
  Target 97fc31d3ca68602965fcc27b6e7cac76
  URG bf7cb5a70aec1989d3e04436be444b11
import  -/  tostring-0.2.1.1@tostr_3WKXD89KZfc5BSX8Q5dXep:Data.String.ToString d0991a72f1064ecb9aa2833fb0b76080
90ad622dde91a58a2504638315f0a61c
  $dmtoSMTPath ::
    ChainsToSMT2.ToSMT a =>
    a -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs, Strictness: <L,A><L,A><L,A><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a5
                   $dToSMT :: ChainsToSMT2.ToSMT a5
                   ds :: a5
                   ds1 :: GHC.Types.Int
                   ds2 :: GHC.Types.Int ->
                 GHC.Types.[] @ GHC.Types.Char) -}
cdff70d7b184ae1b7c82059c5dc6711d
  $dmtoSMTPrereq :: ChainsToSMT2.ToSMT a => a -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a5 $dToSMT :: ChainsToSMT2.ToSMT a5 ds :: a5 ->
                 GHC.Types.[] @ GHC.Base.String) -}
a8fc48a8fb31009844b915360a01d480
  $fToSMTCriteria :: ChainsToSMT2.ToSMT Types.Criteria
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria
                  ChainsToSMT2.$fToSMTCriteria_$ctoSMTPrereq
                  ChainsToSMT2.$fToSMTCriteria_$ctoSMT
                  ChainsToSMT2.$fToSMTCriteria_$ctoSMTPath -}
62dad8cc6185df1e0579de1ec955bc2a
  $fToSMTCriteria_$ctoSMT ::
    Types.Criteria -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,A><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: Types.Criteria w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 ChainsToSMT2.$w$ctoSMT w) -}
d3897bd5c53ad616161ec260da1b093d
  $fToSMTCriteria_$ctoSMTPath ::
    Types.Criteria -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ ds :: Types.Criteria
                   ds1 :: GHC.Types.Int
                   ds2 :: GHC.Types.Int ->
                 GHC.Types.[] @ GHC.Types.Char) -}
db95136fa3f58b5feaa93e36b18b7bd8
  $fToSMTCriteria_$ctoSMTPrereq ::
    Types.Criteria -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
a8fc48a8fb31009844b915360a01d480
  $fToSMTGenRule :: ChainsToSMT2.ToSMT Types.Rule
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule
                  ChainsToSMT2.$fToSMTGenRule_$ctoSMTPrereq
                  ChainsToSMT2.$fToSMTGenRule_$ctoSMT
                  ChainsToSMT2.$fToSMTGenRule_$ctoSMTPath -}
76152805e86572b19df7f72fe1d8b902
  $fToSMTGenRule1 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   ChainsToSMT2.$fToSMTGenRule4
                   ChainsToSMT2.$fToSMTGenRule2) -}
d25933cd537498350f4899f192888c88
  $fToSMTGenRule2 :: [GHC.Types.Int]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Int
                   ChainsToSMT2.$fToSMTGenRule3
                   (GHC.Types.[] @ GHC.Types.Int)) -}
7cea1c19ae6070a2254ecf8667dcf24b
  $fToSMTGenRule3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
28c5401928e5c929060f3307dc47f9b0
  $fToSMTGenRule4 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
4b5c4b67a3b08b412c808510dc9ee7c4
  $fToSMTGenRule_$ctoSMT ::
    Types.Rule -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S(SLL),1*U(1*U,A,A)><L,U><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 ChainsToSMT2.$w$ctoSMT1 ww1 w1 w2 }) -}
2d1d13b95a3816de302a6d7fe916399e
  $fToSMTGenRule_$ctoSMTPath ::
    Types.Rule -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S(SSL),1*U(1*U,1*U,A)><L,U(U)><L,U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 ChainsToSMT2.$w$ctoSMTPath ww1 ww2 w1 w2 }) -}
7a74e702171471f09b8ce493330ee182
  $fToSMTGenRule_$ctoSMTPrereq :: Types.Rule -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.GenRule Types.Criteria ->
                 case ds of wild { Types.Rule c t ds1 ->
                 ChainsToSMT2.$fToSMTGenRule_$ctoSMTPrereq1 c }) -}
4f2870876227b7e7485d34462c77a0b2
  $fToSMTGenRule_$ctoSMTPrereq1 ::
    [Types.Criteria] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
a8fc48a8fb31009844b915360a01d480
  $fToSMTTarget :: ChainsToSMT2.ToSMT Types.Target
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target
                  ChainsToSMT2.$fToSMTTarget_$ctoSMTPrereq
                  ChainsToSMT2.$fToSMTTarget_$ctoSMT
                  ChainsToSMT2.$fToSMTTarget_$ctoSMTPath -}
7fd832e483eae92fb5703f587a4016c2
  $fToSMTTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
fd9f1d94db2f5829ccc1748a08c22903
  $fToSMTTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
a5c7cdd24f536ba4f42457a672da9782
  $fToSMTTarget3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " (Int) Bool)"#) -}
72a4cda7c48b45acab17bcdada554572
  $fToSMTTarget_$ctoSMT ::
    Types.Target -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,A><L,A>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: Types.Target ds1 :: GHC.Types.Int ds2 :: GHC.Types.Int ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   Types.ACCEPT -> ChainsToSMT2.$fToSMTTarget2
                   Types.DROP -> ChainsToSMT2.$fToSMTTarget1 }) -}
e58f1fd52ab2d756cd081070cd8ea782
  $fToSMTTarget_$ctoSMTPath ::
    Types.Target -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U)> -}
4ffc3dd43b6d8f49223ef22dae583ae1
  $fToSMTTarget_$ctoSMTPrereq :: Types.Target -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Types.Target ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Base.String
                   Types.PropVariableTarget i ds1
                   -> GHC.Types.:
                        @ GHC.Base.String
                        (GHC.CString.unpackAppendCString#
                           "(declare-fun v"#
                           (case i of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   0
                                   ww3
                                   (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                              ChainsToSMT2.$fToSMTTarget3 } }))
                        (GHC.Types.[] @ GHC.Base.String) }) -}
a8fc48a8fb31009844b915360a01d480
  $fToSMT[] :: ChainsToSMT2.ToSMT [Types.Target]
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [Types.Target]
                  ChainsToSMT2.$fToSMT[]_$ctoSMTPrereq
                  ChainsToSMT2.$fToSMT[]_$ctoSMT
                  ChainsToSMT2.$fToSMT[]_$ctoSMTPath -}
a8fc48a8fb31009844b915360a01d480
  $fToSMT[]0 :: ChainsToSMT2.ToSMT [Types.Criteria]
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [Types.Criteria]
                  ChainsToSMT2.$fToSMTGenRule_$ctoSMTPrereq1
                  ChainsToSMT2.$fToSMT[]0_$ctoSMT
                  ChainsToSMT2.$fToSMT[]0_$ctoSMTPath -}
d2b9aa1dd30bb701fda6c0aa3c7639fd
  $fToSMT[]0_$ctoSMT ::
    [Types.Criteria]
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,A><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: [Types.Criteria] w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 ChainsToSMT2.$w$ctoSMT2 w) -}
cdf604a3171c60f9cfdefe409dd1905b
  $fToSMT[]0_$ctoSMTPath ::
    [Types.Criteria]
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ ds :: [Types.Criteria]
                   ds1 :: GHC.Types.Int
                   ds2 :: GHC.Types.Int ->
                 GHC.Types.[] @ GHC.Types.Char) -}
a8fc48a8fb31009844b915360a01d480
  $fToSMT[]1 :: ChainsToSMT2.ToSMT Types.Chain
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Chain
                  ChainsToSMT2.$fToSMT[]1_$ctoSMTPrereq
                  ChainsToSMT2.$fToSMT[]1_$ctoSMT
                  ChainsToSMT2.$fToSMT[]1_$ctoSMTPath -}
25ea9daa2024ef3faa5c179f7eedf72e
  $fToSMT[]1_$ctoSMT ::
    Types.Chain -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ rs :: Types.Chain ch :: GHC.Types.Int ru :: GHC.Types.Int ->
                 ChainsToSMT2.chainToSMT
                   rs
                   ChainsToSMT2.$fToSMTGenRule_$ctoSMT
                   ch
                   ru) -}
ef89ff3c653ba911a251683aaac5413b
  $fToSMT[]1_$ctoSMTPath ::
    Types.Chain -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ rs :: Types.Chain ch :: GHC.Types.Int ru :: GHC.Types.Int ->
                 ChainsToSMT2.chainToSMT
                   rs
                   ChainsToSMT2.$fToSMTGenRule_$ctoSMTPath
                   ch
                   ru) -}
743eb5a1d2ef8dda72eed2588c39b911
  $fToSMT[]1_$ctoSMTPrereq :: Types.Chain -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
f3b45560df11b2689b2bbccab22eca1d
  $fToSMT[]_$ctoSMT ::
    [Types.Target] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,A><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: [Types.Target] w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 ChainsToSMT2.$w$ctoSMT3 w) -}
c9b0cff01cf965c64a3c541ff09ea6ca
  $fToSMT[]_$ctoSMTPath ::
    [Types.Target] -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U(U)> -}
536f2ad61c9beb4b78f9ab1ae6926a6a
  $fToSMT[]_$ctoSMTPrereq :: [Types.Target] -> [GHC.Base.String]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ ds :: [Types.Target] -> GHC.Types.[] @ GHC.Base.String) -}
bd4ead35a34e8dbb802a516c215a1cd8
  $w$ctoSMT :: Types.Criteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
94882973cf79be1c111f948353961a80
  $w$ctoSMT1 ::
    [Types.Criteria]
    -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: [Types.Criteria]
                   w :: GHC.Types.Int
                   w1 :: GHC.Types.Int ->
                 case ww of wild {
                   []
                   -> letrec {
                        go11 :: [GHC.Types.Int] -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [GHC.Types.Int] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : y ys
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (SMT.$fToStringSMT_$ctoString
                                    (SMT.Assert (SMT.MatchesCriteria y w w1)))
                                 (go11 ys) }
                      } in
                      go11 ChainsToSMT2.$fToSMTGenRule1
                   : ipv ipv1
                   -> let {
                        a5 :: GHC.Base.String = ChainsToSMT2.$w$ctoSMT2 wild
                      } in
                      let {
                        lvl57 :: SMT.SMT = SMT.SMTString a5
                      } in
                      letrec {
                        go11 :: [GHC.Types.Int] -> [GHC.Types.Char]
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ ds :: [GHC.Types.Int] ->
                          case ds of wild1 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : y ys
                            -> GHC.Base.++
                                 @ GHC.Types.Char
                                 (SMT.$fToStringSMT_$ctoString
                                    (SMT.Assert (SMT.SMTEq lvl57 (SMT.MatchesCriteria y w w1))))
                                 (go11 ys) }
                      } in
                      go11 ChainsToSMT2.$fToSMTGenRule1 }) -}
b26e444af17b6f0c3ea450206e6ca7ab
  $w$ctoSMT2 :: [Types.Criteria] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
0fea2497bc03f109d9c5c1cdaeeb06a4
  $w$ctoSMT3 :: [Types.Target] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f708a60164ef2cee9af2d3780dc44a7a
  $w$ctoSMTPath ::
    [Types.Criteria]
    -> [Types.Target]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,1*U><S,1*U><L,U(U)><L,U(U)>,
     Inline: [0] -}
8e53b9e0aeea648e35f9201136d14c97
  $wlvl ::
    GHC.Base.String
    -> [GHC.Base.String] -> [([GHC.Types.Char], [GHC.Types.Char])]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String ww1 :: [GHC.Base.String] ->
                 letrec {
                   xs :: [[GHC.Types.Char]] -> [([GHC.Types.Char], [GHC.Types.Char])]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [[GHC.Types.Char]] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ ([GHC.Types.Char], [GHC.Types.Char])
                       : y ys
                       -> GHC.Types.:
                            @ ([GHC.Types.Char], [GHC.Types.Char])
                            (ww, y)
                            (xs ys) }
                 } in
                 xs ww1) -}
7be395b9eecfaaaebbfade5e35cf830b
  $wnotTopLevelPolicy :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U(U)>, Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.SMTEq
                         (SMT.SMTString
                            (GHC.CString.unpackAppendCString#
                               "(policy "#
                               (case w of ww2 { GHC.Types.I# ww3 ->
                                case GHC.Show.$wshowSignedInt
                                       0
                                       ww3
                                       (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                                  ChainsToSMT2.notTopLevelPolicy3 } })))
                         ChainsToSMT2.notTopLevelPolicy1))) -}
d0338f225e137edb27a0f4cb625346b4
  $wstringNumList ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> [[GHC.Types.Char]]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# ww1 :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww ww1) of wild {
                   GHC.Types.False
                   -> letrec {
                        go11 :: GHC.Prim.Int# -> [[GHC.Types.Char]]
                          {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Prim.Int# ->
                          GHC.Types.:
                            @ [GHC.Types.Char]
                            (case GHC.Show.$wshowSignedInt
                                    0
                                    x
                                    (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                            (case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.==# x ww1) of wild1 {
                               GHC.Types.False -> go11 (GHC.Prim.+# x 1)
                               GHC.Types.True -> GHC.Types.[] @ [GHC.Types.Char] })
                      } in
                      go11 ww
                   GHC.Types.True -> GHC.Types.[] @ [GHC.Types.Char] }) -}
a8fc48a8fb31009844b915360a01d480
  class ToSMT a where
    toSMTPrereq {- Has default method -} :: a -> [GHC.Base.String]
    toSMT :: a -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
    toSMTPath {- Has default method -} ::
      a -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
47fc21e0451360e7e8fbd280fb8715f0
  chainToSMT ::
    [Types.Rule]
    -> (Types.Rule
        -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String)
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,C(C1(C1(U)))><L,U><L,U(U)> -}
3101e81a110576bc1d4439d128c71f9f
  convertChainsCheckSMT ::
    NameIdChain.IdNameChain
    -> GHC.Base.String
    -> GHC.Base.String
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,1*U(A,A,A,A,A,A,A,A,1*U,U,A,A,A,U,U,A,1*U(U),A,A,A,U)><S,1*U><L,U><L,U(U)><L,1*U> -}
2090257453b6b47f51eff5a3427faa42
  flagToString :: Types.Flag -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Flag ->
                 case ds of wild {
                   Types.SYN -> ChainsToSMT2.flagToString5
                   Types.ACK -> ChainsToSMT2.flagToString4
                   Types.FIN -> ChainsToSMT2.flagToString3
                   Types.RST -> ChainsToSMT2.flagToString2
                   Types.URG -> ChainsToSMT2.flagToString1 }) -}
317a490d17c9b5417836e9b324cfc7b1
  flagToString1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "URG"#) -}
d6d9b3a90ee574bf7ee0d42b7b354cfe
  flagToString2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RST"#) -}
27adea2919a2ac7a842150470dcfce7a
  flagToString3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FIN"#) -}
2a273f3264ac0bf1175df05e39edff0b
  flagToString4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACK"#) -}
79d45ba70d249b84d21885ef33073ed6
  flagToString5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SYN"#) -}
025fd952ef8809f3cbc904f08736988e
  notMatchesGo ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U><L,U><L,U>,
     Unfolding: InlineRule (5, True, False)
                (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   r :: GHC.Types.Int
                   goC :: GHC.Types.Int
                   goR :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.SMTNot (SMT.MatchesRule p c r))
                         (SMT.SMTNot (SMT.Reaches p goC goR))))) -}
e4b71c32e98639b82dcae6166db354db
  notOverChainEnd ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ p :: GHC.Types.Int c :: GHC.Types.Int cLen :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.SMTNot
                         (SMT.Reaches
                            p
                            c
                            (case cLen of wild { GHC.Types.I# x ->
                             GHC.Types.I# (GHC.Prim.+# x 1) }))))) -}
ff471dac4fe7d6391aab76ade996fd36
  notTopLevelPolicy ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, Strictness: <L,A><L,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int ->
                 ChainsToSMT2.$wnotTopLevelPolicy w1) -}
46751635e86295233e2dfc07f506574c
  notTopLevelPolicy1 :: SMT.SMT
  {- Strictness: m12,
     Unfolding: (SMT.SMTString ChainsToSMT2.notTopLevelPolicy2) -}
470076ae01474f95cfcead1b7ba58528
  notTopLevelPolicy2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONE"#) -}
05d02e69465b7328520135d8e05861db
  notTopLevelPolicy3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ")"#) -}
62071424b5754e403ccda99da19718d4
  onlyOneTopLevel ::
    GHC.Types.Int -> [GHC.Types.Int] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
45cbb8b830f87f417defb672ea8f5e4c
  reachesEnd ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ p :: GHC.Types.Int c :: GHC.Types.Int cLen :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.SMTEq (SMT.Reaches p c cLen) (SMT.ReachesEnd p c)))) -}
8c4188d435606cba2885ff09b6a9e555
  reachesMatchesGo ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U(U)><L,U><L,U>,
     Unfolding: (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   r :: GHC.Types.Int
                   goC :: GHC.Types.Int
                   goR :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.MatchesRule p c r)
                         (SMT.SMTAnd
                            (GHC.Types.:
                               @ SMT.SMT
                               (SMT.Reaches p goC goR)
                               (GHC.Types.:
                                  @ SMT.SMT
                                  (SMT.SMTEq
                                     (SMT.ReturnsFrom p goC)
                                     (SMT.Reaches
                                        p
                                        c
                                        (case r of wild { GHC.Types.I# x ->
                                         GHC.Types.I# (GHC.Prim.+# x 1) })))
                                  (GHC.Types.[] @ SMT.SMT))))))) -}
0ecf997cecf68201048e515f8b25a52f
  reachesMatchesGoReturn ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,U><L,U(U)><L,U><L,U>,
     Unfolding: (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   r :: GHC.Types.Int
                   goC :: GHC.Types.Int
                   goR :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.MatchesRule p c r)
                         (SMT.SMTAnd
                            (GHC.Types.:
                               @ SMT.SMT
                               (SMT.Reaches p goC goR)
                               (GHC.Types.:
                                  @ SMT.SMT
                                  (SMT.SMTNot
                                     (SMT.Reaches
                                        p
                                        c
                                        (case r of wild { GHC.Types.I# x ->
                                         GHC.Types.I# (GHC.Prim.+# x 1) })))
                                  (GHC.Types.:
                                     @ SMT.SMT
                                     (SMT.SMTEq (SMT.ReturnsFrom p goC) (SMT.ReturnsFrom p c))
                                     (GHC.Types.[] @ SMT.SMT)))))))) -}
cbef58b45590f2227118322f81bb1de2
  reachesMatchesReturn ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U)>,
     Unfolding: (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   r :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.MatchesRule p c r)
                         (SMT.SMTAnd
                            (GHC.Types.:
                               @ SMT.SMT
                               (SMT.ReturnsFrom p c)
                               (GHC.Types.:
                                  @ SMT.SMT
                                  (SMT.SMTNot
                                     (SMT.Reaches
                                        p
                                        c
                                        (case r of wild { GHC.Types.I# x ->
                                         GHC.Types.I# (GHC.Prim.+# x 1) })))
                                  (GHC.Types.[] @ SMT.SMT))))))) -}
3573c12154f6de6e05645654e8151c13
  reachesMatchesTerminating ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,U><L,U(U)><L,U>,
     Unfolding: (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   r :: GHC.Types.Int
                   s :: GHC.Base.String ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.MatchesRule p c r)
                         (SMT.SMTAnd
                            (GHC.Types.:
                               @ SMT.SMT
                               (SMT.SMTNot
                                  (SMT.Reaches
                                     p
                                     c
                                     (case r of wild { GHC.Types.I# x ->
                                      GHC.Types.I# (GHC.Prim.+# x 1) })))
                               (GHC.Types.:
                                  @ SMT.SMT
                                  (SMT.SMTEq (SMT.TerminatesWith p) (SMT.SMTString s))
                                  (GHC.Types.[] @ SMT.SMT))))))) -}
b67307a1577d78b3f24895237f11ef40
  reachesNoneTarget ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U)>,
     Unfolding: InlineRule (3, True, False)
                (\ p :: GHC.Types.Int c :: GHC.Types.Int r :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.Reaches p c r)
                         (SMT.Reaches
                            p
                            c
                            (case r of wild { GHC.Types.I# x ->
                             GHC.Types.I# (GHC.Prim.+# x 1) }))))) -}
1320aa9728902d41589bbde73acceaef
  replaceAllCombinations ::
    GHC.Base.String
    -> [(GHC.Base.String, [GHC.Base.String])] -> GHC.Base.String
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ s :: GHC.Base.String
                   xs :: [(GHC.Base.String, [GHC.Base.String])] ->
                 letrec {
                   go11 :: [([GHC.Types.Char], [GHC.Types.Char])] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [([GHC.Types.Char], [GHC.Types.Char])] ->
                     case ds of wild {
                       [] -> s
                       : y ys
                       -> case y of wild1 { (,) o n ->
                          case Data.List.Utils.split
                                 @ GHC.Types.Char
                                 GHC.Classes.$fEqChar
                                 o
                                 (go11 ys) of wild2 {
                            [] -> GHC.Types.[] @ GHC.Types.Char
                            : x xs1
                            -> Data.List.Utils.replace1
                                 @ GHC.Types.Char
                                 (GHC.Types.:
                                    @ [GHC.Types.Char]
                                    x
                                    (Data.OldList.prependToAll @ [GHC.Types.Char] n xs1)) } } }
                 } in
                 letrec {
                   go12 :: [[([GHC.Types.Char], [GHC.Types.Char])]]
                           -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [[([GHC.Types.Char], [GHC.Types.Char])]] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys -> GHC.Base.++ @ GHC.Types.Char (go11 y) (go12 ys) }
                 } in
                 go12
                   (ChainsToSMT2.replaceAllCombinations_go
                      (GHC.Base.map
                         @ (GHC.Base.String, [GHC.Base.String])
                         @ [(GHC.Base.String, GHC.Base.String)]
                         ChainsToSMT2.replaceAllCombinations1
                         xs))) -}
450e366d14c56e6ef40c80a4f0358a5e
  replaceAllCombinations1 ::
    (GHC.Base.String, [GHC.Base.String])
    -> [([GHC.Types.Char], [GHC.Types.Char])]
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: (GHC.Base.String, [GHC.Base.String]) ->
                 case w of ww { (,) ww1 ww2 -> ChainsToSMT2.$wlvl ww1 ww2 }) -}
31ba5d3a427bfe5a8cfe9b3306efb82f
  replaceAllCombinations_go ::
    [[(GHC.Base.String, GHC.Base.String)]]
    -> [[(GHC.Base.String, GHC.Base.String)]]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
472ec74b7de49e94e7ae808cd8b78f07
  returnsFrom :: GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ p :: GHC.Types.Int c :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.SMTEq
                         (SMT.ReturnsFrom p c)
                         (SMT.SMTOr
                            (GHC.Types.:
                               @ SMT.SMT
                               (SMT.ReachesReturn p c)
                               (GHC.Types.:
                                  @ SMT.SMT
                                  (SMT.ReachesEnd p c)
                                  (GHC.Types.[] @ SMT.SMT))))))) -}
8429c9ec9ae718dfe49377ac6002af36
  setupChain ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U)>,
     Unfolding: (\ p :: GHC.Types.Int
                   c :: GHC.Types.Int
                   cLen :: GHC.Types.Int ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (SMT.$fToStringSMT_$ctoString
                      (SMT.Assert
                         (SMT.SMTNot
                            (SMT.Reaches
                               p
                               c
                               (case cLen of wild { GHC.Types.I# x ->
                                GHC.Types.I# (GHC.Prim.+# x 1) })))))
                   (GHC.CString.unpackAppendCString#
                      "\n"#
                      (GHC.Base.++
                         @ GHC.Types.Char
                         (SMT.$fToStringSMT_$ctoString
                            (SMT.Assert
                               (SMT.SMTEq (SMT.Reaches p c cLen) (SMT.ReachesEnd p c))))
                         (GHC.CString.unpackAppendCString#
                            "\n"#
                            (ChainsToSMT2.returnsFrom p c))))) -}
d1f6386be2a5d9fac7494dc334cc655d
  stringNumList ::
    GHC.Types.Int -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U)><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 ChainsToSMT2.$wstringNumList ww1 ww3 } }) -}
8396baff42fe9ccc988e3278f78546bd
  topLevelPolicy :: GHC.Types.Int -> GHC.Types.Int -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,U(U)>,
     Unfolding: (\ p :: GHC.Types.Int c :: GHC.Types.Int ->
                 SMT.$fToStringSMT_$ctoString
                   (SMT.Assert
                      (SMT.Implies
                         (SMT.ReachesEnd p c)
                         (SMT.SMTEq
                            (SMT.TerminatesWith p)
                            (SMT.SMTString
                               (GHC.CString.unpackAppendCString#
                                  "(policy "#
                                  (case c of ww2 { GHC.Types.I# ww3 ->
                                   case GHC.Show.$wshowSignedInt
                                          0
                                          ww3
                                          (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Base.++
                                     @ GHC.Types.Char
                                     (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                                     ChainsToSMT2.notTopLevelPolicy3 } }))))))) -}
instance ChainsToSMT2.ToSMT [Types.Criteria]
  = ChainsToSMT2.$fToSMTCriteria
instance ChainsToSMT2.ToSMT [Types.GenRule]
  = ChainsToSMT2.$fToSMTGenRule
instance ChainsToSMT2.ToSMT [Types.Target]
  = ChainsToSMT2.$fToSMTTarget
instance ChainsToSMT2.ToSMT [[]] = ChainsToSMT2.$fToSMT[]
instance ChainsToSMT2.ToSMT [[]] = ChainsToSMT2.$fToSMT[]0
instance ChainsToSMT2.ToSMT [[]] = ChainsToSMT2.$fToSMT[]1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

