
==================== FINAL INTERFACE ====================
2016-07-20 23:33:31.461249 UTC

interface main@main:Types 7103
  interface hash: 9d0f0847be76210c6f6855221854b450
  ABI hash: be1e767e9389ce9c8fd11ba155041f23
  export-list hash: 98cf0ae77f95faeb276b282dfb3cdefd
  orphan hash: 6e65ce1f65dc0e4284ce9a99f6379a8d
  flag hash: e468f87777beb3fe7114763efe9ccb2f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Types.eitherToRule
  Types.Chain
  Types.Criteria{Types.And Types.IPAddress Types.Not Types.Or Types.Port Types.PropVariableCriteria Types.Protocol Types.SC}
  Types.Label
  Types.ModuleFunc
  Types.Rule{Types.Rule Types.criteria Types.label Types.targets}
  Types.Target{Types.ACCEPT Types.DROP Types.Go Types.Jump Types.PropVariableTarget Types.ST}
  Types.ToString{Types.toString}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set 7116dff3002cb8f8fc1c63ac63f4ea50
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
301d972945a67a79ef58d0f57083ac37
  $fEqCriteria :: GHC.Classes.Eq Types.Criteria
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria Types.$fEqCriteria_$c== Types.$fEqCriteria_$c/= -}
301d972945a67a79ef58d0f57083ac37
  $fEqCriteria_$c/= ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Criteria b :: Types.Criteria ->
                 case Types.$fEqCriteria_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
301d972945a67a79ef58d0f57083ac37
  $fEqCriteria_$c== ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
ac330ce08d4cccb73260095eb52eb1d7
  $fEqRule :: GHC.Classes.Eq Types.Rule
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule Types.$fEqRule_$c== Types.$fEqRule_$c/= -}
ac330ce08d4cccb73260095eb52eb1d7
  $fEqRule_$c/= :: Types.Rule -> Types.Rule -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U(U))><S(SLL),1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Rule b :: Types.Rule ->
                 case Types.$fEqRule_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fEqRule_$c== :: Types.Rule -> Types.Rule -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U,1*U(U))><S(SLL),1*U(1*U,1*U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 Types.$w$c== ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fEqTarget :: GHC.Classes.Eq Types.Target
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target Types.$fEqTarget_$c== Types.$fEqTarget_$c/= -}
7ae42b578730cec1847a60a81b4bf4b8
  $fEqTarget_$c/= :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Target b :: Types.Target ->
                 case Types.$fEqTarget_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fEqTarget_$c== :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Types.Target ds1 :: Types.Target ->
                 case ds of wild {
                   Types.Jump a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Jump b1 -> GHC.Base.eqString a1 b1 }
                   Types.Go a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Go b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.eqInt a2 b2 } } } }
                   Types.ACCEPT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.ACCEPT -> GHC.Types.True }
                   Types.DROP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.DROP -> GHC.Types.True }
                   Types.PropVariableTarget a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.PropVariableTarget b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.$fEqBool_$c== a2 b2 } } } }
                   Types.ST a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.ST b1 -> GHC.Base.eqString a1 b1 } }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fMonoidRule :: GHC.Base.Monoid Types.Rule
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule
                  Types.$fMonoidRule_$cmempty
                  Types.$fMonoidRule_$cmappend
                  Types.$fMonoidRule_$cmconcat -}
ac330ce08d4cccb73260095eb52eb1d7
  $fMonoidRule_$cmappend :: Types.Rule -> Types.Rule -> Types.Rule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U,1*U(U))><S,1*U(1*U,1*U,1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 Types.Rule
                   (GHC.Base.++ @ Types.Criteria ww1 ww5)
                   (GHC.Base.++ @ Types.Target ww2 ww6)
                   (GHC.Classes.$fOrdInt_$cmax ww3 ww7) } }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fMonoidRule_$cmconcat :: [Types.Rule] -> Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Types.Rule] ->
                 case Types.$wgo w of ww { (#,,#) ww1 ww2 ww3 ->
                 Types.Rule ww1 ww2 ww3 }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fMonoidRule_$cmempty :: Types.Rule
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Types.Rule
                   (GHC.Types.[] @ Types.Criteria)
                   (GHC.Types.[] @ Types.Target)
                   GHC.Base.minInt) -}
301d972945a67a79ef58d0f57083ac37
  $fShowCriteria :: GHC.Show.Show Types.Criteria
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria
                  Types.$fShowCriteria_$cshowsPrec
                  Types.$fShowCriteria_$cshow
                  Types.$fShowCriteria_$cshowList -}
301d972945a67a79ef58d0f57083ac37
  $fShowCriteria1 :: Types.Criteria -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Types.Criteria -> Types.$w$cshowsPrec 0 w) -}
301d972945a67a79ef58d0f57083ac37
  $fShowCriteria_$cshow :: Types.Criteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Criteria ->
                 Types.$fShowCriteria_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
301d972945a67a79ef58d0f57083ac37
  $fShowCriteria_$cshowList :: [Types.Criteria] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Criteria
                   Types.$fShowCriteria1) -}
301d972945a67a79ef58d0f57083ac37
  $fShowCriteria_$cshowsPrec ::
    GHC.Types.Int -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.Criteria ->
                 case w of ww { GHC.Types.I# ww1 -> Types.$w$cshowsPrec ww1 w1 }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fShowRule :: GHC.Show.Show Types.Rule
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule
                  Types.$fShowRule_$cshowsPrec
                  Types.$fShowRule_$cshow
                  Types.$fShowRule_$cshowList -}
ac330ce08d4cccb73260095eb52eb1d7
  $fShowRule1 :: Types.Rule -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Rule w1 :: GHC.Base.String ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 Types.$w$cshowsPrec1 0 ww1 ww2 ww3 w1 }) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fShowRule_$cshow :: Types.Rule -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Rule ->
                 Types.$fShowRule_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fShowRule_$cshowList :: [Types.Rule] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Types.Rule Types.$fShowRule1) -}
ac330ce08d4cccb73260095eb52eb1d7
  $fShowRule_$cshowsPrec ::
    GHC.Types.Int -> Types.Rule -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.Rule w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Types.Rule ww3 ww4 ww5 ->
                 Types.$w$cshowsPrec1 ww1 ww3 ww4 ww5 w2 } }) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fShowTarget :: GHC.Show.Show Types.Target
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target
                  Types.$fShowTarget_$cshowsPrec
                  Types.$fShowTarget_$cshow
                  Types.$fShowTarget_$cshowList -}
7ae42b578730cec1847a60a81b4bf4b8
  $fShowTarget1 :: Types.Target -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Types.$fShowTarget_$cshowsPrec Types.$fShowTarget2) -}
0b0bd96a8eb40b411a4cbdd853dd4359
  $fShowTarget2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fShowTarget_$cshow :: Types.Target -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Target ->
                 Types.$fShowTarget_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fShowTarget_$cshowList :: [Types.Target] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Target
                   Types.$fShowTarget1) -}
7ae42b578730cec1847a60a81b4bf4b8
  $fShowTarget_$cshowsPrec ::
    GHC.Types.Int -> Types.Target -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
7be3006f4b3e789e3fa086ea15403adc
  $fToStringChar :: Types.ToString GHC.Types.Char
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringChar_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Types.Char>_N)) -}
6b8d8cc0e786c6703f42e2426b5ba3ce
  $fToStringChar_$ctoString :: GHC.Types.Char -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Char ->
                 GHC.Types.: @ GHC.Types.Char x (GHC.Types.[] @ GHC.Types.Char)) -}
7be3006f4b3e789e3fa086ea15403adc
  $fToStringInt :: Types.ToString GHC.Types.Int
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringInt_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Types.Int>_N)) -}
07880c5c41c52e5267732da9fe80737b
  $fToStringInt_$ctoString :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Unfolding: InlineRule (0, True, True) GHC.Show.$fShowInt_$cshow -}
7be3006f4b3e789e3fa086ea15403adc
  $fToString[] :: Types.ToString GHC.Base.String
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToString[]_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Base.String>_N)) -}
86f26df0a364da9692e45f9fdb8d928f
  $fToString[]_$ctoString :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ x :: GHC.Base.String -> x) -}
35b3fa811bccd7f4f16f0fd4017aec33
  $s$fShow(,) :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowInt)
                  Types.$s$fShow(,)_$s$fShow(,)_$cshow
                  Types.$s$fShow(,)_$s$fShow(,)_$cshowList -}
f2924be10a90a0186b399809837cf167
  $s$fShow(,)_$s$fShow(,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U))>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: (GHC.Types.Int, GHC.Types.Int) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowInt
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87ce232c44ef923f656e8e6cad5985e5
  $s$fShow(,)_$s$fShow(,)_$cshowList ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: [(GHC.Types.Int, GHC.Types.Int)]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      GHC.Show.shows18)
                   eta
                   eta1) -}
d8ae8da96fa68037333fce8958ded922
  $w$c== ::
    [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U(U)><S,1*U><L,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ ww :: [Types.Criteria]
                   ww1 :: [Types.Target]
                   ww2 :: Types.Label
                   ww3 :: [Types.Criteria]
                   ww4 :: [Types.Target]
                   ww5 :: Types.Label ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Types.Criteria
                        Types.$fEqCriteria
                        ww
                        ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ Types.Target
                             Types.$fEqTarget
                             ww1
                             ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.eqInt ww2 ww5 } }) -}
301d972945a67a79ef58d0f57083ac37
  $w$cshowsPrec :: GHC.Prim.Int# -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
2efc58a22819a302fdae565c12889ef0
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [0] -}
ac330ce08d4cccb73260095eb52eb1d7
  $wgo ::
    [Types.Rule] -> (# [Types.Criteria], [Types.Target], Types.Label #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
0a970728856b5d9154b0315f841145e0
  type Chain = [Types.Rule]
301d972945a67a79ef58d0f57083ac37
  data Criteria
    = And [Types.Criteria]
    | Or [Types.Criteria]
    | Not Types.Criteria
    | Port GHC.Base.String
           (Data.Either.Either GHC.Types.Int (GHC.Types.Int, GHC.Types.Int))
    | IPAddress GHC.Base.String
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
    | PropVariableCriteria GHC.Types.Int
    | Protocol GHC.Types.Int
    | SC GHC.Base.String
8ea1cbc35ff6354c4e178e365701b867
  type Label = GHC.Types.Int
ab5330f02a891d005ffbea99fe1c0e14
  type ModuleFunc =
    [GHC.Base.String]
    -> (GHC.Base.Maybe
          [Data.Either.Either Types.Criteria Types.Target],
        [GHC.Base.String])
ac330ce08d4cccb73260095eb52eb1d7
  data Rule
    = Rule {criteria :: [Types.Criteria],
            targets :: [Types.Target],
            label :: Types.Label}
7ae42b578730cec1847a60a81b4bf4b8
  data Target
    = Jump GHC.Base.String
    | Go GHC.Types.Int GHC.Types.Int
    | ACCEPT
    | DROP
    | PropVariableTarget GHC.Types.Int GHC.Types.Bool
    | ST GHC.Base.String
7be3006f4b3e789e3fa086ea15403adc
  class ToString a where
    toString :: a -> GHC.Base.String
5b8533cdc53545fcea0706ca7ae2ba91
  criteria :: Types.Rule -> [Types.Criteria]
  RecSel Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Rule ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds1 }) -}
97c592b40986cf8442f7842b925ed501
  eitherToRule ::
    Data.Either.Either Types.Criteria Types.Target
    -> GHC.Types.Int -> Types.Rule
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Data.Either.Either Types.Criteria Types.Target
                   i :: GHC.Types.Int ->
                 case ds of wild {
                   Data.Either.Left c
                   -> Types.Rule
                        (GHC.Types.: @ Types.Criteria c (GHC.Types.[] @ Types.Criteria))
                        (GHC.Types.[] @ Types.Target)
                        i
                   Data.Either.Right t
                   -> Types.Rule
                        (GHC.Types.[] @ Types.Criteria)
                        (GHC.Types.: @ Types.Target t (GHC.Types.[] @ Types.Target))
                        i }) -}
29e70a94ef11ac439309b20c2d514613
  label :: Types.Rule -> Types.Label
  RecSel Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Rule ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds3 }) -}
dabc9615e422ce8e03e5c82c6f655a6d
  targets :: Types.Rule -> [Types.Target]
  RecSel Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Rule ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds2 }) -}
instance GHC.Classes.Eq [Types.Criteria] = Types.$fEqCriteria
instance GHC.Classes.Eq [Types.Rule] = Types.$fEqRule
instance GHC.Classes.Eq [Types.Target] = Types.$fEqTarget
instance GHC.Base.Monoid [Types.Rule] = Types.$fMonoidRule
instance GHC.Show.Show [Types.Criteria] = Types.$fShowCriteria
instance GHC.Show.Show [Types.Rule] = Types.$fShowRule
instance GHC.Show.Show [Types.Target] = Types.$fShowTarget
instance Types.ToString [GHC.Types.Char] = Types.$fToStringChar
instance Types.ToString [GHC.Types.Int] = Types.$fToStringInt
instance Types.ToString [[]] = Types.$fToString[]
"SPEC/Types $fShow(,) @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                               GHC.Types.Int
                                                   $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,) @ GHC.Types.Int @ GHC.Types.Int $dShow $dShow1
  = Types.$s$fShow(,)
"SPEC/Types $fShow(,)_$cshow @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                      GHC.Types.Int
                                                          $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshow @ GHC.Types.Int
                            @ GHC.Types.Int
                            $dShow
                            $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshow
"SPEC/Types $fShow(,)_$cshowList @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                          GHC.Types.Int
                                                              $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshowList @ GHC.Types.Int
                                @ GHC.Types.Int
                                $dShow
                                $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshowList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

