
==================== FINAL INTERFACE ====================
2016-08-01 16:59:18.298171 UTC

interface main@main:Types 7103
  interface hash: 730b1a37cb7d143be98172997e5fed75
  ABI hash: 7934cc096ad4ac018aac4adeb7e3cd39
  export-list hash: 39af0f5b1cafb87923b315bfa9b266b9
  orphan hash: 6e65ce1f65dc0e4284ce9a99f6379a8d
  flag hash: e468f87777beb3fe7114763efe9ccb2f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Types.eitherToRule
  Types.nameToIdListMap
  Types.targetsToChainIds
  Types.Chain
  Types.Criteria{Types.IPAddress Types.Not Types.Port Types.PropVariableCriteria Types.Protocol Types.SC}
  Types.GenRule{Types.Rule Types.criteria Types.targets}
  Types.InputChain
  Types.InputCriteria{Types.And Types.InC Types.InCNot Types.Or}
  Types.InputInstruction
  Types.InputRule
  Types.Instruction
  Types.ModuleFunc
  Types.NameIdChain{Types.NameIdChain Types.chain Types.ids Types.name}
  Types.Rule
  Types.SynthInstruction{Types.NoInstruction Types.ToChainNamed Types.chainName Types.insRule}
  Types.Target{Types.ACCEPT Types.DROP Types.Go Types.Jump Types.PropVariableTarget Types.ST}
  Types.ToString{Types.toString}
module dependencies:
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set 7116dff3002cb8f8fc1c63ac63f4ea50
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
61b02b594ef3ae008da99e5e81a331ad
  $fEqCriteria :: GHC.Classes.Eq Types.Criteria
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria Types.$fEqCriteria_$c== Types.$fEqCriteria_$c/= -}
61b02b594ef3ae008da99e5e81a331ad
  $fEqCriteria_$c/= ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Criteria b :: Types.Criteria ->
                 case Types.$fEqCriteria_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
61b02b594ef3ae008da99e5e81a331ad
  $fEqCriteria_$c== ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule ::
    GHC.Classes.Eq crit => GHC.Classes.Eq (Types.GenRule crit)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ crit $dEq :: GHC.Classes.Eq crit.
                  @ (Types.GenRule crit)
                  (Types.$fEqGenRule_$c== @ crit $dEq)
                  (Types.$fEqGenRule_$c/= @ crit $dEq) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule_$c/= ::
    GHC.Classes.Eq crit =>
    Types.GenRule crit -> Types.GenRule crit -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   $dEq :: GHC.Classes.Eq crit
                   a :: Types.GenRule crit
                   b :: Types.GenRule crit ->
                 case Types.$fEqGenRule_$c== @ crit $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule_$c== ::
    GHC.Classes.Eq crit =>
    Types.GenRule crit -> Types.GenRule crit -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   w :: GHC.Classes.Eq crit
                   w1 :: Types.GenRule crit
                   w2 :: Types.GenRule crit ->
                 case w1 of ww { Types.Rule ww1 ww2 ->
                 case w2 of ww3 { Types.Rule ww4 ww5 ->
                 Types.$w$c== @ crit w ww1 ww2 ww4 ww5 } }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule_$s$c/= ::
    Types.GenRule Types.Criteria
    -> Types.GenRule Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.GenRule Types.Criteria
                   b :: Types.GenRule Types.Criteria ->
                 case Types.$fEqGenRule_$s$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule_$s$c== ::
    Types.GenRule Types.Criteria
    -> Types.GenRule Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U)><S(SL),1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.GenRule Types.Criteria
                   w1 :: Types.GenRule Types.Criteria ->
                 case w of ww { Types.Rule ww1 ww2 ->
                 case w1 of ww3 { Types.Rule ww4 ww5 ->
                 Types.$w$s$c== ww1 ww2 ww4 ww5 } }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fEqGenRule_$s$fEqGenRule ::
    GHC.Classes.Eq (Types.GenRule Types.Criteria)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Types.GenRule Types.Criteria)
                  Types.$fEqGenRule_$s$c==
                  Types.$fEqGenRule_$s$c/= -}
87de19e4c0783477235da4b1982384b1
  $fEqInputCriteria :: GHC.Classes.Eq Types.InputCriteria
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.InputCriteria
                  Types.$fEqInputCriteria_$c==
                  Types.$fEqInputCriteria_$c/= -}
87de19e4c0783477235da4b1982384b1
  $fEqInputCriteria_$c/= ::
    Types.InputCriteria -> Types.InputCriteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.InputCriteria b :: Types.InputCriteria ->
                 case Types.$fEqInputCriteria_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
87de19e4c0783477235da4b1982384b1
  $fEqInputCriteria_$c== ::
    Types.InputCriteria -> Types.InputCriteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
8291be8a39ca8cfd31ec21359b660c7b
  $fEqNameIdChain :: GHC.Classes.Eq Types.NameIdChain
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.NameIdChain
                  Types.$fEqNameIdChain_$c==
                  Types.$fEqNameIdChain_$c/= -}
8291be8a39ca8cfd31ec21359b660c7b
  $fEqNameIdChain_$c/= ::
    Types.NameIdChain -> Types.NameIdChain -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U)><S(SLL),1*U(1*U,1*U(U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.NameIdChain b :: Types.NameIdChain ->
                 case Types.$fEqNameIdChain_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
8291be8a39ca8cfd31ec21359b660c7b
  $fEqNameIdChain_$c== ::
    Types.NameIdChain -> Types.NameIdChain -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLL),1*U(1*U,1*U(U),1*U)><S(SLL),1*U(1*U,1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.NameIdChain w1 :: Types.NameIdChain ->
                 case w of ww { Types.NameIdChain ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.NameIdChain ww5 ww6 ww7 ->
                 Types.$w$c==1 ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
c528360e1dad54e821a9320bd4983290
  $fEqSynthInstruction ::
    GHC.Classes.Eq r => GHC.Classes.Eq (Types.SynthInstruction r)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r $dEq :: GHC.Classes.Eq r.
                  @ (Types.SynthInstruction r)
                  (Types.$fEqSynthInstruction_$c== @ r $dEq)
                  (Types.$fEqSynthInstruction_$c/= @ r $dEq) -}
c528360e1dad54e821a9320bd4983290
  $fEqSynthInstruction_$c/= ::
    GHC.Classes.Eq r =>
    Types.SynthInstruction r
    -> Types.SynthInstruction r -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   $dEq :: GHC.Classes.Eq r
                   a :: Types.SynthInstruction r
                   b :: Types.SynthInstruction r ->
                 case Types.$fEqSynthInstruction_$c== @ r $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c528360e1dad54e821a9320bd4983290
  $fEqSynthInstruction_$c== ::
    GHC.Classes.Eq r =>
    Types.SynthInstruction r
    -> Types.SynthInstruction r -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ r
                   $dEq :: GHC.Classes.Eq r
                   ds :: Types.SynthInstruction r
                   ds1 :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed a1 a2
                   -> case ds1 of wild1 {
                        Types.ToChainNamed b1 b2
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ r $dEq a2 b2 }
                        Types.NoInstruction ipv -> GHC.Types.False }
                   Types.NoInstruction a1
                   -> case ds1 of wild1 {
                        Types.ToChainNamed ipv ipv1 -> GHC.Types.False
                        Types.NoInstruction b1 -> GHC.Classes.== @ r $dEq a1 b1 } }) -}
96fab3e40e346c4a445f4966317f4361
  $fEqTarget :: GHC.Classes.Eq Types.Target
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target Types.$fEqTarget_$c== Types.$fEqTarget_$c/= -}
96fab3e40e346c4a445f4966317f4361
  $fEqTarget_$c/= :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Target b :: Types.Target ->
                 case Types.$fEqTarget_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
96fab3e40e346c4a445f4966317f4361
  $fEqTarget_$c== :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Types.Target ds1 :: Types.Target ->
                 case ds of wild {
                   Types.Jump a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Jump b1 -> GHC.Base.eqString a1 b1 }
                   Types.Go a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Go b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.eqInt a2 b2 } } } }
                   Types.ACCEPT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.ACCEPT -> GHC.Types.True }
                   Types.DROP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.DROP -> GHC.Types.True }
                   Types.PropVariableTarget a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.PropVariableTarget b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.$fEqBool_$c== a2 b2 } } } }
                   Types.ST a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.ST b1 -> GHC.Base.eqString a1 b1 } }) -}
87de19e4c0783477235da4b1982384b1
  $fMonoidGenRule :: GHC.Base.Monoid Types.InputRule
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.InputRule
                  Types.$fMonoidGenRule_$cmempty
                  Types.$fMonoidGenRule_$cmappend
                  Types.$fMonoidGenRule_$cmconcat -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fMonoidGenRule0 :: GHC.Base.Monoid Types.Rule
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule
                  Types.$fMonoidGenRule0_$cmempty
                  Types.$fMonoidGenRule0_$cmappend
                  Types.$fMonoidGenRule0_$cmconcat -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fMonoidGenRule0_$cmappend ::
    Types.Rule -> Types.Rule -> Types.Rule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U)><S,1*U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Types.GenRule Types.Criteria
                   ds1 :: Types.GenRule Types.Criteria ->
                 case ds of wild { Types.Rule c1 t1 ->
                 case ds1 of wild1 { Types.Rule c2 t2 ->
                 Types.Rule
                   @ Types.Criteria
                   (GHC.Base.augment
                      @ Types.Criteria
                      (\ @ b c :: Types.Criteria -> b -> b[OneShot] n :: b[OneShot] ->
                       GHC.Base.foldr @ Types.Criteria @ b c n c1)
                      c2)
                   (GHC.Base.augment
                      @ Types.Target
                      (\ @ b c :: Types.Target -> b -> b[OneShot] n :: b[OneShot] ->
                       GHC.Base.foldr @ Types.Target @ b c n t1)
                      t2) } }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fMonoidGenRule0_$cmconcat :: [Types.Rule] -> Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Types.Rule] ->
                 case Types.$wgo1 w of ww { (#,#) ww1 ww2 ->
                 Types.Rule @ Types.Criteria ww1 ww2 }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fMonoidGenRule0_$cmempty :: Types.Rule
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Types.Rule
                   @ Types.Criteria
                   (GHC.Types.[] @ Types.Criteria)
                   (GHC.Types.[] @ Types.Target)) -}
87de19e4c0783477235da4b1982384b1
  $fMonoidGenRule_$cmappend ::
    Types.InputRule -> Types.InputRule -> Types.InputRule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U)><S,1*U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Types.GenRule Types.InputCriteria
                   ds1 :: Types.GenRule Types.InputCriteria ->
                 case ds of wild { Types.Rule c1 t1 ->
                 case ds1 of wild1 { Types.Rule c2 t2 ->
                 Types.Rule
                   @ Types.InputCriteria
                   (GHC.Base.augment
                      @ Types.InputCriteria
                      (\ @ b
                         c :: Types.InputCriteria -> b -> b[OneShot]
                         n :: b[OneShot] ->
                       GHC.Base.foldr @ Types.InputCriteria @ b c n c1)
                      c2)
                   (GHC.Base.augment
                      @ Types.Target
                      (\ @ b c :: Types.Target -> b -> b[OneShot] n :: b[OneShot] ->
                       GHC.Base.foldr @ Types.Target @ b c n t1)
                      t2) } }) -}
87de19e4c0783477235da4b1982384b1
  $fMonoidGenRule_$cmconcat :: [Types.InputRule] -> Types.InputRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Types.InputRule] ->
                 case Types.$wgo w of ww { (#,#) ww1 ww2 ->
                 Types.Rule @ Types.InputCriteria ww1 ww2 }) -}
87de19e4c0783477235da4b1982384b1
  $fMonoidGenRule_$cmempty :: Types.InputRule
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Types.Rule
                   @ Types.InputCriteria
                   (GHC.Types.[] @ Types.InputCriteria)
                   (GHC.Types.[] @ Types.Target)) -}
61b02b594ef3ae008da99e5e81a331ad
  $fShowCriteria :: GHC.Show.Show Types.Criteria
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria
                  Types.$fShowCriteria_$cshowsPrec
                  Types.$fShowCriteria_$cshow
                  Types.$fShowCriteria_$cshowList -}
61b02b594ef3ae008da99e5e81a331ad
  $fShowCriteria1 :: Types.Criteria -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Types.Criteria -> Types.$w$cshowsPrec 0 w) -}
61b02b594ef3ae008da99e5e81a331ad
  $fShowCriteria_$cshow :: Types.Criteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Criteria ->
                 Types.$fShowCriteria_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
61b02b594ef3ae008da99e5e81a331ad
  $fShowCriteria_$cshowList :: [Types.Criteria] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Criteria
                   Types.$fShowCriteria1) -}
61b02b594ef3ae008da99e5e81a331ad
  $fShowCriteria_$cshowsPrec ::
    GHC.Types.Int -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.Criteria ->
                 case w of ww { GHC.Types.I# ww1 -> Types.$w$cshowsPrec ww1 w1 }) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fShowGenRule ::
    GHC.Show.Show crit => GHC.Show.Show (Types.GenRule crit)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ crit $dShow :: GHC.Show.Show crit.
                  @ (Types.GenRule crit)
                  (Types.$fShowGenRule_$cshowsPrec @ crit $dShow)
                  (Types.$fShowGenRule_$cshow @ crit $dShow)
                  (Types.$fShowGenRule_$cshowList @ crit $dShow) -}
7ae29fd63fdfdb0515a8949c83cfdb72
  $fShowGenRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
b3b85f3bd505be1a491f332d2d0cc654
  $fShowGenRule2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Rule {"#) -}
865546b4dc6340fdea3bb4ceca9d1898
  $fShowGenRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
c9abac52e1b3be636009bd801969f345
  $fShowGenRule4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "targets = "#) -}
c064acd9a271b36b4c8350302fbb84b9
  $fShowGenRule5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
35e2afb79f5c581fcba955b0b5a640c1
  $fShowGenRule6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "criteria = "#) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fShowGenRule_$cshow ::
    GHC.Show.Show crit => Types.GenRule crit -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,A,1*C1(U))><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ crit $dShow :: GHC.Show.Show crit x :: Types.GenRule crit ->
                 Types.$fShowGenRule_$cshowsPrec
                   @ crit
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fShowGenRule_$cshowList ::
    GHC.Show.Show crit => [Types.GenRule crit] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,A,C(U))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   $dShow :: GHC.Show.Show crit
                   eta :: [Types.GenRule crit]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Types.GenRule crit)
                   (Types.$fShowGenRule_$cshowsPrec
                      @ crit
                      $dShow
                      Types.$fShowGenRule1)
                   eta
                   eta1) -}
b6d94cfe05ce24ee2081c8f355e279c9
  $fShowGenRule_$cshowsPrec ::
    GHC.Show.Show crit =>
    GHC.Types.Int -> Types.GenRule crit -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(A,A,1*C1(U))><S,1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   w :: GHC.Show.Show crit
                   w1 :: GHC.Types.Int
                   w2 :: Types.GenRule crit ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Types.Rule ww3 ww4 ->
                 Types.$w$cshowsPrec1 @ crit w ww1 ww3 ww4 } }) -}
96fab3e40e346c4a445f4966317f4361
  $fShowGenRule_$cshowsPrec1 ::
    GHC.Types.Int -> Types.Target -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
87de19e4c0783477235da4b1982384b1
  $fShowInputCriteria :: GHC.Show.Show Types.InputCriteria
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.InputCriteria
                  Types.$fShowInputCriteria_$cshowsPrec
                  Types.$fShowInputCriteria_$cshow
                  Types.$fShowInputCriteria_$cshowList -}
87de19e4c0783477235da4b1982384b1
  $fShowInputCriteria1 :: Types.InputCriteria -> GHC.Show.ShowS
  {- Arity: 1 -}
87de19e4c0783477235da4b1982384b1
  $fShowInputCriteria_$cshow ::
    Types.InputCriteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.InputCriteria ->
                 Types.$fShowInputCriteria_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87de19e4c0783477235da4b1982384b1
  $fShowInputCriteria_$cshowList ::
    [Types.InputCriteria] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.InputCriteria
                   Types.$fShowInputCriteria1) -}
87de19e4c0783477235da4b1982384b1
  $fShowInputCriteria_$cshowsPrec ::
    GHC.Types.Int -> Types.InputCriteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.InputCriteria ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.$w$cshowsPrec2 ww1 w1 }) -}
8291be8a39ca8cfd31ec21359b660c7b
  $fShowNameIdChain :: GHC.Show.Show Types.NameIdChain
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.NameIdChain
                  Types.$fShowNameIdChain_$cshowsPrec
                  Types.$fShowNameIdChain_$cshow
                  Types.$fShowNameIdChain_$cshowList -}
8291be8a39ca8cfd31ec21359b660c7b
  $fShowNameIdChain1 :: Types.NameIdChain -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.NameIdChain w1 :: GHC.Base.String ->
                 case w of ww { Types.NameIdChain ww1 ww2 ww3 ->
                 Types.$w$cshowsPrec3 0 ww1 ww2 ww3 w1 }) -}
081964981f77bf4b50812ce79ae4fd47
  $fShowNameIdChain2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chain = "#) -}
e3543f2e9624fa4d2cba23d9cb770d94
  $fShowNameIdChain3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ids = "#) -}
572808a6c191abb864dfbc50905ac7bc
  $fShowNameIdChain4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "name = "#) -}
c27718119d66118a71aadb2a94537463
  $fShowNameIdChain5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NameIdChain {"#) -}
8291be8a39ca8cfd31ec21359b660c7b
  $fShowNameIdChain_$cshow :: Types.NameIdChain -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(U),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.NameIdChain ->
                 Types.$fShowNameIdChain_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8291be8a39ca8cfd31ec21359b660c7b
  $fShowNameIdChain_$cshowList ::
    [Types.NameIdChain] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.NameIdChain
                   Types.$fShowNameIdChain1) -}
8291be8a39ca8cfd31ec21359b660c7b
  $fShowNameIdChain_$cshowsPrec ::
    GHC.Types.Int -> Types.NameIdChain -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U,1*U(U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.NameIdChain
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Types.NameIdChain ww3 ww4 ww5 ->
                 Types.$w$cshowsPrec3 ww1 ww3 ww4 ww5 w2 } }) -}
c528360e1dad54e821a9320bd4983290
  $fShowSynthInstruction ::
    GHC.Show.Show r => GHC.Show.Show (Types.SynthInstruction r)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r $dShow :: GHC.Show.Show r.
                  @ (Types.SynthInstruction r)
                  (Types.$fShowSynthInstruction_$cshowsPrec @ r $dShow)
                  (Types.$fShowSynthInstruction_$cshow @ r $dShow)
                  (Types.$fShowSynthInstruction_$cshowList @ r $dShow) -}
d5fd1cdfde79c82c0c0699c4b9f9e58e
  $fShowSynthInstruction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoInstruction {"#) -}
8cbafb84264fcbfa78254e343ab3f501
  $fShowSynthInstruction2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "insRule = "#) -}
275d1b7bc46599703a07bc5e35815f60
  $fShowSynthInstruction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chainName = "#) -}
4fcb1ec2290f2c9d0f9cceea84a88a71
  $fShowSynthInstruction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ToChainNamed {"#) -}
c528360e1dad54e821a9320bd4983290
  $fShowSynthInstruction_$cshow ::
    GHC.Show.Show r => Types.SynthInstruction r -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ r $dShow :: GHC.Show.Show r x :: Types.SynthInstruction r ->
                 Types.$fShowSynthInstruction_$cshowsPrec
                   @ r
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c528360e1dad54e821a9320bd4983290
  $fShowSynthInstruction_$cshowList ::
    GHC.Show.Show r => [Types.SynthInstruction r] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   $dShow :: GHC.Show.Show r
                   eta :: [Types.SynthInstruction r]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Types.SynthInstruction r)
                   (Types.$fShowSynthInstruction_$cshowsPrec
                      @ r
                      $dShow
                      Types.$fShowGenRule1)
                   eta
                   eta1) -}
c528360e1dad54e821a9320bd4983290
  $fShowSynthInstruction_$cshowsPrec ::
    GHC.Show.Show r =>
    GHC.Types.Int -> Types.SynthInstruction r -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   w :: GHC.Show.Show r
                   w1 :: GHC.Types.Int
                   w2 :: Types.SynthInstruction r ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Types.$w$cshowsPrec4 @ r w ww1 w2 }) -}
96fab3e40e346c4a445f4966317f4361
  $fShowTarget :: GHC.Show.Show Types.Target
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target
                  Types.$fShowGenRule_$cshowsPrec1
                  Types.$fShowTarget_$cshow
                  Types.$fShowTarget_$cshowList -}
96fab3e40e346c4a445f4966317f4361
  $fShowTarget1 :: Types.Target -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Types.$fShowGenRule_$cshowsPrec1
                   Types.$fShowGenRule1) -}
96fab3e40e346c4a445f4966317f4361
  $fShowTarget_$cshow :: Types.Target -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Target ->
                 Types.$fShowGenRule_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
96fab3e40e346c4a445f4966317f4361
  $fShowTarget_$cshowList :: [Types.Target] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Target
                   Types.$fShowTarget1) -}
7be3006f4b3e789e3fa086ea15403adc
  $fToStringChar :: Types.ToString GHC.Types.Char
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringChar_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Types.Char>_N)) -}
6b8d8cc0e786c6703f42e2426b5ba3ce
  $fToStringChar_$ctoString :: GHC.Types.Char -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Char ->
                 GHC.Types.: @ GHC.Types.Char x (GHC.Types.[] @ GHC.Types.Char)) -}
7be3006f4b3e789e3fa086ea15403adc
  $fToStringInt :: Types.ToString GHC.Types.Int
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringInt_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Types.Int>_N)) -}
07880c5c41c52e5267732da9fe80737b
  $fToStringInt_$ctoString :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Unfolding: InlineRule (0, True, True) GHC.Show.$fShowInt_$cshow -}
7be3006f4b3e789e3fa086ea15403adc
  $fToString[] :: Types.ToString GHC.Base.String
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToString[]_$ctoString
                  `cast`
                (Sym (Types.NTCo:ToString[0] <GHC.Base.String>_N)) -}
86f26df0a364da9692e45f9fdb8d928f
  $fToString[]_$ctoString :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ x :: GHC.Base.String -> x) -}
35b3fa811bccd7f4f16f0fd4017aec33
  $s$fShow(,) :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowInt)
                  Types.$s$fShow(,)_$s$fShow(,)_$cshow
                  Types.$s$fShow(,)_$s$fShow(,)_$cshowList -}
f2924be10a90a0186b399809837cf167
  $s$fShow(,)_$s$fShow(,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U))>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: (GHC.Types.Int, GHC.Types.Int) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowInt
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87ce232c44ef923f656e8e6cad5985e5
  $s$fShow(,)_$s$fShow(,)_$cshowList ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: [(GHC.Types.Int, GHC.Types.Int)]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      GHC.Show.shows18)
                   eta
                   eta1) -}
0e66f6cc880f96fdf3f4c469dfaf08d3
  $w$c== ::
    GHC.Classes.Eq crit =>
    [crit]
    -> [Types.Target] -> [crit] -> [Types.Target] -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U><S,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ @ crit
                   w :: GHC.Classes.Eq crit
                   ww :: [crit]
                   ww1 :: [Types.Target]
                   ww2 :: [crit]
                   ww3 :: [Types.Target] ->
                 case GHC.Classes.$fEq[]_$c== @ crit w ww ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ Types.Target
                        Types.$fEqTarget
                        ww1
                        ww3 }) -}
0f858635bd0294b28298134b7b79e1ec
  $w$c==1 ::
    GHC.Base.String
    -> GHC.Types.Int
    -> Types.Chain
    -> GHC.Base.String
    -> GHC.Types.Int
    -> Types.Chain
    -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><S,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Base.String
                   ww1 :: GHC.Types.Int
                   ww2 :: Types.Chain
                   ww3 :: GHC.Base.String
                   ww4 :: GHC.Types.Int
                   ww5 :: Types.Chain ->
                 case GHC.Base.eqString ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww4 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> GHC.Classes.$fEq[]_$c==
                             @ (Types.GenRule Types.Criteria)
                             Types.$fEqGenRule_$s$fEqGenRule
                             ww2
                             ww5 } } } }) -}
61b02b594ef3ae008da99e5e81a331ad
  $w$cshowsPrec :: GHC.Prim.Int# -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
2f065cc59cdc95b56a2e415fe48f39e7
  $w$cshowsPrec1 ::
    GHC.Show.Show crit =>
    GHC.Prim.Int# -> [crit] -> [Types.Target] -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(A,A,1*C1(U))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ crit
                   w :: GHC.Show.Show crit
                   ww :: GHC.Prim.Int#
                   ww1 :: [crit]
                   ww2 :: [Types.Target] ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showList @ crit w ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Types.$fShowGenRule6
                       (f (GHC.Base.++
                             @ GHC.Types.Char
                             Types.$fShowGenRule5
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.$fShowGenRule4
                                (let {
                                   s :: GHC.Base.String
                                   = GHC.Base.++ @ GHC.Types.Char Types.$fShowGenRule3 x
                                 } in
                                 case ww2 of wild {
                                   [] -> GHC.CString.unpackAppendCString# "[]"# s
                                   : x1 xs
                                   -> GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showList__3
                                        (Types.$fShowGenRule_$cshowsPrec1
                                           Types.$fShowGenRule1
                                           x1
                                           (let {
                                              lvl26 :: [GHC.Types.Char]
                                              = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                            } in
                                            letrec {
                                              showl :: [Types.Target] -> [GHC.Types.Char]
                                                {- Arity: 1, Strictness: <S,1*U> -}
                                              = \ ds2 :: [Types.Target] ->
                                                case ds2 of wild1 {
                                                  [] -> lvl26
                                                  : y ys
                                                  -> GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.showList__1
                                                       (Types.$fShowGenRule_$cshowsPrec1
                                                          Types.$fShowGenRule1
                                                          y
                                                          (showl ys)) }
                                            } in
                                            showl xs)) }))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++ @ GHC.Types.Char Types.$fShowGenRule2 (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Types.$fShowGenRule2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
87de19e4c0783477235da4b1982384b1
  $w$cshowsPrec2 ::
    GHC.Prim.Int# -> Types.InputCriteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
2347bd4d95be857a0a68f3e920d5b008
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> GHC.Base.String
    -> GHC.Types.Int
    -> Types.Chain
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U(U)><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Base.String
                   ww2 :: GHC.Types.Int
                   ww3 :: Types.Chain
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Types.$fShowNameIdChain5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Types.$fShowNameIdChain4
                          (GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows6
                             (GHC.Show.showLitString
                                ww1
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Base.++
                                      @ GHC.Types.Char
                                      Types.$fShowGenRule5
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Types.$fShowNameIdChain3
                                         (case ww2 of ww4 { GHC.Types.I# ww5 ->
                                          case GHC.Show.$wshowSignedInt
                                                 0
                                                 ww5
                                                 (GHC.Base.++
                                                    @ GHC.Types.Char
                                                    Types.$fShowGenRule5
                                                    (GHC.Base.++
                                                       @ GHC.Types.Char
                                                       Types.$fShowNameIdChain2
                                                       (let {
                                                          s :: GHC.Base.String
                                                          = GHC.Base.++
                                                              @ GHC.Types.Char
                                                              Types.$fShowGenRule3
                                                              x
                                                        } in
                                                        case ww3 of wild {
                                                          []
                                                          -> GHC.CString.unpackAppendCString#
                                                               "[]"#
                                                               s
                                                          : x1 xs
                                                          -> GHC.Types.:
                                                               @ GHC.Types.Char
                                                               GHC.Show.showList__3
                                                               (case x1 of ww6 { Types.Rule ww7 ww8 ->
                                                                Types.$w$cshowsPrec1
                                                                  @ Types.Criteria
                                                                  Types.$fShowCriteria
                                                                  0
                                                                  ww7
                                                                  ww8
                                                                  (let {
                                                                     lvl26 :: [GHC.Types.Char]
                                                                     = GHC.Types.:
                                                                         @ GHC.Types.Char
                                                                         GHC.Show.showList__2
                                                                         s
                                                                   } in
                                                                   letrec {
                                                                     showl :: [Types.GenRule
                                                                                 Types.Criteria]
                                                                              -> [GHC.Types.Char]
                                                                       {- Arity: 1,
                                                                          Strictness: <S,1*U> -}
                                                                     = \ ds2 :: [Types.GenRule
                                                                                   Types.Criteria] ->
                                                                       case ds2 of wild1 {
                                                                         [] -> lvl26
                                                                         : y ys
                                                                         -> GHC.Types.:
                                                                              @ GHC.Types.Char
                                                                              GHC.Show.showList__1
                                                                              (case y of ww9 { Types.Rule ww10 ww11 ->
                                                                               Types.$w$cshowsPrec1
                                                                                 @ Types.Criteria
                                                                                 Types.$fShowCriteria
                                                                                 0
                                                                                 ww10
                                                                                 ww11
                                                                                 (showl ys) }) }
                                                                   } in
                                                                   showl
                                                                     xs) }) }))) of ww6 { (#,#) ww7 ww8 ->
                                          GHC.Types.: @ GHC.Types.Char ww7 ww8 } })))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
c528360e1dad54e821a9320bd4983290
  $w$cshowsPrec4 ::
    GHC.Show.Show r =>
    GHC.Prim.Int# -> Types.SynthInstruction r -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ r
                   w :: GHC.Show.Show r
                   ww :: GHC.Prim.Int#
                   w1 :: Types.SynthInstruction r ->
                 case w1 of wild {
                   Types.ToChainNamed b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ r w Types.$fShowGenRule1 b2
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.$fShowSynthInstruction4
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Types.$fShowSynthInstruction3
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows6
                                  (GHC.Show.showLitString
                                     b1
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows6
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           Types.$fShowGenRule5
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Types.$fShowSynthInstruction2
                                              (f (GHC.Base.++
                                                    @ GHC.Types.Char
                                                    Types.$fShowGenRule3
                                                    x))))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   Types.NoInstruction b1
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ r w Types.$fShowGenRule1 b1
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.$fShowSynthInstruction1
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Types.$fShowSynthInstruction2
                               (f (GHC.Base.++ @ GHC.Types.Char Types.$fShowGenRule3 x)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) } }) -}
91fe7194e26d1884b6af92a3e3b9960e
  $w$s$c== ::
    [Types.Criteria]
    -> [Types.Target]
    -> [Types.Criteria]
    -> [Types.Target]
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: [Types.Criteria]
                   ww1 :: [Types.Target]
                   ww2 :: [Types.Criteria]
                   ww3 :: [Types.Target] ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Types.Criteria
                        Types.$fEqCriteria
                        ww
                        ww2 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c==
                        @ Types.Target
                        Types.$fEqTarget
                        ww1
                        ww3 }) -}
87de19e4c0783477235da4b1982384b1
  $wgo ::
    [Types.InputRule] -> (# [Types.InputCriteria], [Types.Target] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
b6d94cfe05ce24ee2081c8f355e279c9
  $wgo1 :: [Types.Rule] -> (# [Types.Criteria], [Types.Target] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
63cc581b204b4367506f8067294b4375
  type Chain = [Types.Rule]
61b02b594ef3ae008da99e5e81a331ad
  data Criteria
    = Not Types.Criteria
    | Port GHC.Base.String
           (Data.Either.Either GHC.Types.Int (GHC.Types.Int, GHC.Types.Int))
    | IPAddress GHC.Base.String
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
                GHC.Types.Int
    | PropVariableCriteria GHC.Types.Int
    | Protocol GHC.Types.Int
    | SC GHC.Base.String
b6d94cfe05ce24ee2081c8f355e279c9
  data GenRule crit
    = Rule {criteria :: [crit], targets :: [Types.Target]}
21741417fa13a64d47626b28a64ff34f
  type InputChain = [Types.InputRule]
87de19e4c0783477235da4b1982384b1
  data InputCriteria
    = InC Types.Criteria
    | InCNot Types.InputCriteria
    | And [Types.InputCriteria]
    | Or [Types.InputCriteria]
465e6057143fc4e229ba70042940d8e2
  type InputInstruction = Types.SynthInstruction Types.InputRule
87de19e4c0783477235da4b1982384b1
  type InputRule = Types.GenRule Types.InputCriteria
961d9c37c629f8d37f154cc6c8c8d7ef
  type Instruction = Types.SynthInstruction Types.Rule
1e2498d2f3c0f24f91d52f3d898da77e
  type ModuleFunc =
    [GHC.Base.String]
    -> (GHC.Base.Maybe
          [Data.Either.Either Types.InputCriteria Types.Target],
        [GHC.Base.String])
8291be8a39ca8cfd31ec21359b660c7b
  data NameIdChain
    = NameIdChain {name :: GHC.Base.String,
                   ids :: GHC.Types.Int,
                   chain :: Types.Chain}
b6d94cfe05ce24ee2081c8f355e279c9
  type Rule = Types.GenRule Types.Criteria
c528360e1dad54e821a9320bd4983290
  data SynthInstruction r
    = ToChainNamed {chainName :: GHC.Base.String, insRule :: r}
    | NoInstruction {insRule :: r}
96fab3e40e346c4a445f4966317f4361
  data Target
    = Jump GHC.Base.String
    | Go GHC.Types.Int GHC.Types.Int
    | ACCEPT
    | DROP
    | PropVariableTarget GHC.Types.Int GHC.Types.Bool
    | ST GHC.Base.String
7be3006f4b3e789e3fa086ea15403adc
  class ToString a where
    toString :: a -> GHC.Base.String
8bbf7e1f27cb638d758b4325f96d5592
  chain :: Types.NameIdChain -> Types.Chain
  RecSel Types.NameIdChain
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.NameIdChain ->
                 case ds of wild { Types.NameIdChain ds1 ds2 ds3 -> ds3 }) -}
ab0cf82ed436ae66ad6a67c8d1630804
  chainName :: Types.SynthInstruction r -> GHC.Base.String
  RecSel Types.SynthInstruction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ r ds :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed ds1 ds2 -> ds1
                   Types.NoInstruction ipv -> Types.chainName1 }) -}
86cc83d13a5267976d269d3f766b53e3
  chainName1 :: GHC.Base.String
  {- Strictness: b -}
b22504e024f4f0f8636519bee4a7a9bb
  criteria :: Types.GenRule crit -> [crit]
  RecSel Types.GenRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ crit ds :: Types.GenRule crit ->
                 case ds of wild { Types.Rule ds1 ds2 -> ds1 }) -}
de8215f0f34097fdcb1c1d46f57acbba
  eitherToRule ::
    Data.Either.Either Types.InputCriteria Types.Target
    -> Types.InputRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Data.Either.Either Types.InputCriteria Types.Target ->
                 case ds of wild {
                   Data.Either.Left c
                   -> Types.Rule
                        @ Types.InputCriteria
                        (GHC.Types.:
                           @ Types.InputCriteria
                           c
                           (GHC.Types.[] @ Types.InputCriteria))
                        (GHC.Types.[] @ Types.Target)
                   Data.Either.Right t
                   -> Types.Rule
                        @ Types.InputCriteria
                        (GHC.Types.[] @ Types.InputCriteria)
                        (GHC.Types.: @ Types.Target t (GHC.Types.[] @ Types.Target)) }) -}
0dea467f3f42cf574dc9487e2404f4af
  ids :: Types.NameIdChain -> GHC.Types.Int
  RecSel Types.NameIdChain
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U(U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.NameIdChain ->
                 case ds of wild { Types.NameIdChain ds1 ds2 ds3 -> ds2 }) -}
a9610eb0bc656025132274d219858804
  insRule :: Types.SynthInstruction r -> r
  RecSel Types.SynthInstruction
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ r ds :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed ds1 ds2 -> ds2
                   Types.NoInstruction ds1 -> ds1 }) -}
a8e6111a530434eb1f97885d78c94099
  name :: Types.NameIdChain -> GHC.Base.String
  RecSel Types.NameIdChain
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.NameIdChain ->
                 case ds of wild { Types.NameIdChain ds1 ds2 ds3 -> ds1 }) -}
9f8dd0c950004eb068e1edc54864f1ec
  nameToIdListMap ::
    GHC.Base.String -> [Types.NameIdChain] -> [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ s :: GHC.Base.String l :: [Types.NameIdChain] ->
                 letrec {
                   go :: [Types.NameIdChain] -> [GHC.Types.Int]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [Types.NameIdChain] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Int
                       : y ys
                       -> case y of wild1 { Types.NameIdChain n ds1 ds2 ->
                          case GHC.Base.eqString n s of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True -> GHC.Types.: @ GHC.Types.Int ds1 (go ys) } } }
                 } in
                 go l) -}
15c983b265178bc5e42c0a0e5b7522a4
  targets :: Types.GenRule crit -> [Types.Target]
  RecSel Types.GenRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ crit ds :: Types.GenRule crit ->
                 case ds of wild { Types.Rule ds1 ds2 -> ds2 }) -}
7fbc1449d86dc559dd9f8d12eb962ada
  targetsToChainIds :: [Types.Target] -> [GHC.Types.Int]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
instance GHC.Classes.Eq [Types.Criteria] = Types.$fEqCriteria
instance GHC.Classes.Eq [Types.GenRule] = Types.$fEqGenRule
instance GHC.Classes.Eq [Types.InputCriteria]
  = Types.$fEqInputCriteria
instance GHC.Classes.Eq [Types.NameIdChain] = Types.$fEqNameIdChain
instance GHC.Classes.Eq [Types.SynthInstruction]
  = Types.$fEqSynthInstruction
instance GHC.Classes.Eq [Types.Target] = Types.$fEqTarget
instance GHC.Base.Monoid [Types.GenRule] = Types.$fMonoidGenRule
instance GHC.Base.Monoid [Types.GenRule] = Types.$fMonoidGenRule0
instance GHC.Show.Show [Types.Criteria] = Types.$fShowCriteria
instance GHC.Show.Show [Types.GenRule] = Types.$fShowGenRule
instance GHC.Show.Show [Types.InputCriteria]
  = Types.$fShowInputCriteria
instance GHC.Show.Show [Types.NameIdChain]
  = Types.$fShowNameIdChain
instance GHC.Show.Show [Types.SynthInstruction]
  = Types.$fShowSynthInstruction
instance GHC.Show.Show [Types.Target] = Types.$fShowTarget
instance Types.ToString [GHC.Types.Char] = Types.$fToStringChar
instance Types.ToString [GHC.Types.Int] = Types.$fToStringInt
instance Types.ToString [[]] = Types.$fToString[]
"SPEC $c/= @ Criteria" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                 Types.Criteria
  Types.$fEqGenRule_$c/= @ Types.Criteria $dEq
  = Types.$fEqGenRule_$s$c/=
"SPEC $c== @ Criteria" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                 Types.Criteria
  Types.$fEqGenRule_$c== @ Types.Criteria $dEq
  = Types.$fEqGenRule_$s$c==
"SPEC $fEqGenRule @ Criteria" [ALWAYS] forall $dEq :: GHC.Classes.Eq
                                                        Types.Criteria
  Types.$fEqGenRule @ Types.Criteria $dEq
  = Types.$fEqGenRule_$s$fEqGenRule
"SPEC/Types $fShow(,) @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                               GHC.Types.Int
                                                   $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,) @ GHC.Types.Int @ GHC.Types.Int $dShow $dShow1
  = Types.$s$fShow(,)
"SPEC/Types $fShow(,)_$cshow @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                      GHC.Types.Int
                                                          $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshow @ GHC.Types.Int
                            @ GHC.Types.Int
                            $dShow
                            $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshow
"SPEC/Types $fShow(,)_$cshowList @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                          GHC.Types.Int
                                                              $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshowList @ GHC.Types.Int
                                @ GHC.Types.Int
                                $dShow
                                $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshowList
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

