
==================== FINAL INTERFACE ====================
2017-03-03 16:06:40.810536 UTC

interface main@main:Types [orphan module] 7103
  interface hash: 74314b4852489a5a485e24b85b6869b4
  ABI hash: 5cc88623eea062e7f6011dfd679287af
  export-list hash: 150e5976e36f4ba67c4c37181359bbdd
  orphan hash: f5cd95dcb0a36d2e5e9074ee0cbfbfa4
  flag hash: e468f87777beb3fe7114763efe9ccb2f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Types.boolFlagToFlag
  Types.eitherToRule
  Types.flagsToStrings
  Types.flagsToStrings'
  Types.ifNotRemoveNot
  Types.ipAddr
  Types.ipMask
  Types.ipToWord
  Types.isNot
  Types.isStateful
  Types.isStateless
  Types.stringsToFlags
  Types.targetsToChainIds
  Types.toIPRange
  Types.Chain
  Types.ChainId
  Types.Criteria{Types.BoolFlag Types.IPAddress Types.Limit Types.Not Types.Port Types.PropVariableCriteria Types.Protocol Types.SC Types.UnrecognizedCriteria}
  Types.Endpoint{Types.Destination Types.Source}
  Types.Example{Types.Example Types.exRule Types.state}
  Types.ExampleChain
  Types.ExampleCriteria
  Types.ExampleInstruction
  Types.ExampleRule
  Types.ExampleRuleInstruction
  Types.FileChain
  Types.FileCriteria
  Types.FileInput{Types.InCLimit Types.InCUnrecognizedCriteria}
  Types.FileInstruction
  Types.FileRule
  Types.Flag{Types.ACK Types.FIN Types.RST Types.SYN Types.URG}
  Types.GenRule{Types.Rule Types.criteria Types.label Types.targets}
  Types.InputChain
  Types.InputCriteria{Types.And Types.Ext Types.InC Types.InCNot Types.Or}
  Types.InputInstruction
  Types.InputRule
  Types.Instruction
  Types.Label
  Types.ModuleFunc
  Types.Rule
  Types.RuleInd
  Types.Seconds
  Types.State{Types.Time}
  Types.SynthInstruction{Types.NoInstruction Types.ToChainNamed Types.chainName Types.insRule}
  Types.Target{Types.ACCEPT Types.DROP Types.Go Types.GoReturn Types.GoTo Types.Jump Types.PropVariableTarget Types.RETURN Types.ST Types.UnrecognizedTarget}
module dependencies:
package dependencies: appar-0.1.4@appar_0ov5bpGH3STIB4U7WU8MFi
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0
                      binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi
                      byteorder-1.0.4@byteo_6yQGE3rJo3bBqr3CFoBQ27
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      case-insensitive-1.2.0.7@casei_2hQWsf0VfQP5NW180eleos
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_EalUWgp8NarBYWPbvYAD8I integer-gmp-1.0.0.0
                      iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY
                      largeword-1.2.5@large_7BOdRtoTTTgFdsG28EDk6P
                      network-2.6.3.1@netwo_4FL8hbDqfKm3Q9HV1QK1xw
                      semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1
                      tagged-0.8.4@tagge_LPeicl3HxVfGUMMwMEsAE6
                      text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne
                      tostring-0.2.1.1@tostr_3WKXD89KZfc5BSX8Q5dXep
                      unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw
                      utf8-string-1.0.1.1@utf8s_L8eKHa7Iv9q7FVKUYW6u4b
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         binary-0.7.5.0@binar_3uXFWMoAGBg0xKP9MHKRwi:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_EalUWgp8NarBYWPbvYAD8I:Data.Hashable.Generic
         network-2.6.3.1@netwo_4FL8hbDqfKm3Q9HV1QK1xw:Network.Socket
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Show
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntMap.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.IntSet.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
                         iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Addr
                         iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Range
                         semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1:Data.List.NonEmpty
                         semigroups-0.18.1@semig_LaeT7FLzCl4KIQUoVrPYl1:Data.Semigroup
                         tagged-0.8.4@tagge_LPeicl3HxVfGUMMwMEsAE6:Data.Tagged
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text
                         text-1.2.2.1@text_HmqVQnZSpjaC156ABqPhne:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw:Data.HashMap.Base
                         unordered-containers-0.2.7.1@unord_5iWC5HdL16JGHXLbsgBJnw:Data.HashSet
import  -/  base-4.8.2.0:Data.Bits 87551525e7ef366d0fc4cad44e8b1bfc
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.Int 1419fa899a36eeb2bd16fdb7f0a89738
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.Word ec8deb535202352cc8b509b14004bcbd
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Enum debc6de3086023a15993ab0cecffb90b
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:GHC.Word 10dc88543d98000abab9695a1019767d
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base 8b0bee2cbf19008d0429e93c882cbe4e
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set 7116dff3002cb8f8fc1c63ac63f4ea50
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP 01265d616023459ed1a88e34df15c136
import  -/  iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Addr 405f7c868331a5344db48f25c3e84461
import  -/  iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Internal dbf43e6b2d6321a399b282a76f903998
import  -/  iproute-1.7.0@iprou_EmwGKuwHXxo93hguRyGitY:Data.IP.Range 91da3076a3f7291d5ba7aeb7b3b6bf68
import  -/  largeword-1.2.5@large_7BOdRtoTTTgFdsG28EDk6P:Data.LargeWord 354f86b73f096c48c610faad64e0d6d9
import  -/  tostring-0.2.1.1@tostr_3WKXD89KZfc5BSX8Q5dXep:Data.String.ToString d0991a72f1064ecb9aa2833fb0b76080
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fEqCriteria :: GHC.Classes.Eq Types.Criteria
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria Types.$fEqCriteria_$c== Types.$fEqCriteria_$c/= -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fEqCriteria_$c/= ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Criteria b :: Types.Criteria ->
                 case Types.$fEqCriteria_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fEqCriteria_$c== ::
    Types.Criteria -> Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
55973a7fc1eaa199e3fcffaea36f620c
  $fEqEndpoint :: GHC.Classes.Eq Types.Endpoint
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Endpoint Types.$fEqEndpoint_$c== Types.$fEqEndpoint_$c/= -}
55973a7fc1eaa199e3fcffaea36f620c
  $fEqEndpoint_$c/= ::
    Types.Endpoint -> Types.Endpoint -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Endpoint b :: Types.Endpoint ->
                 case a of wild {
                   Types.Source
                   -> case b of wild1 {
                        Types.Source -> GHC.Types.False
                        Types.Destination -> GHC.Types.True }
                   Types.Destination
                   -> case b of wild1 {
                        Types.Source -> GHC.Types.True
                        Types.Destination -> GHC.Types.False } }) -}
55973a7fc1eaa199e3fcffaea36f620c
  $fEqEndpoint_$c== ::
    Types.Endpoint -> Types.Endpoint -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Types.Endpoint ds1 :: Types.Endpoint ->
                 case ds of wild {
                   Types.Source
                   -> case ds1 of wild1 {
                        Types.Source -> GHC.Types.True
                        Types.Destination -> GHC.Types.False }
                   Types.Destination
                   -> case ds1 of wild1 {
                        Types.Source -> GHC.Types.False
                        Types.Destination -> GHC.Types.True } }) -}
5d53fcbd3679645285b943aca51fb623
  $fEqExample :: GHC.Classes.Eq Types.Example
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Example Types.$fEqExample_$c== Types.$fEqExample_$c/= -}
5d53fcbd3679645285b943aca51fb623
  $fEqExample_$c/= ::
    Types.Example -> Types.Example -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)L),1*U(1*U(1*U,1*U,1*U(U)),1*U)><S(S(SLL)L),1*U(1*U(1*U,1*U,1*U(U)),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Example b :: Types.Example ->
                 case Types.$fEqExample_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
5d53fcbd3679645285b943aca51fb623
  $fEqExample_$c== ::
    Types.Example -> Types.Example -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SLL)L),1*U(1*U(1*U,1*U,1*U(U)),1*U)><S(S(SLL)L),1*U(1*U(1*U,1*U,1*U(U)),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Example w1 :: Types.Example ->
                 case w of ww { Types.Example ww1 ww2 ->
                 case ww1 of ww3 { Types.Rule ww4 ww5 ww6 ->
                 case w1 of ww7 { Types.Example ww8 ww9 ->
                 case ww8 of ww10 { Types.Rule ww11 ww12 ww13 ->
                 Types.$w$c== ww4 ww5 ww6 ww2 ww11 ww12 ww13 ww9 } } } }) -}
89a04067a57a11855a548d82893fcb82
  $fEqFileInput :: GHC.Classes.Eq Types.FileInput
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.FileInput
                  Types.$fEqFileInput_$c==
                  Types.$fEqFileInput_$c/= -}
89a04067a57a11855a548d82893fcb82
  $fEqFileInput_$c/= ::
    Types.FileInput -> Types.FileInput -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.FileInput b :: Types.FileInput ->
                 case Types.$fEqFileInput_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
89a04067a57a11855a548d82893fcb82
  $fEqFileInput_$c== ::
    Types.FileInput -> Types.FileInput -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Types.FileInput ds1 :: Types.FileInput ->
                 case ds of wild {
                   Types.InCLimit a1 a2 a3
                   -> case ds1 of wild1 {
                        Types.InCLimit b1 b2 b3
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case a2 of wild5 { GHC.Types.I# x1 ->
                                case b2 of wild6 { GHC.Types.I# y1 ->
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# x1 y1) of wild7 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> GHC.Classes.eqInt a3 b3 } } } } } }
                        Types.InCUnrecognizedCriteria ipv -> GHC.Types.False }
                   Types.InCUnrecognizedCriteria a1
                   -> case ds1 of wild1 {
                        Types.InCLimit ipv ipv1 ipv2 -> GHC.Types.False
                        Types.InCUnrecognizedCriteria b1 -> GHC.Base.eqString a1 b1 } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fEqFlag :: GHC.Classes.Eq Types.Flag
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Flag Types.$fEqFlag_$c== Types.$fEqFlag_$c/= -}
8787caaca59e38ad2a9bb8caed366b89
  $fEqFlag_$c/= :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.SYN -> GHC.Types.False }
                   Types.ACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.ACK -> GHC.Types.False }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.FIN -> GHC.Types.False }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.RST -> GHC.Types.False }
                   Types.URG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.URG -> GHC.Types.False } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fEqFlag_$c== :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Types.Flag ds1 :: Types.Flag ->
                 case ds of wild {
                   Types.SYN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.SYN -> GHC.Types.True }
                   Types.ACK
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.ACK -> GHC.Types.True }
                   Types.FIN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.FIN -> GHC.Types.True }
                   Types.RST
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.RST -> GHC.Types.True }
                   Types.URG
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.URG -> GHC.Types.True } }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fEqGenRule ::
    GHC.Classes.Eq crit => GHC.Classes.Eq (Types.GenRule crit)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ crit $dEq :: GHC.Classes.Eq crit.
                  @ (Types.GenRule crit)
                  (Types.$fEqGenRule_$c== @ crit $dEq)
                  (Types.$fEqGenRule_$c/= @ crit $dEq) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fEqGenRule_$c/= ::
    GHC.Classes.Eq crit =>
    Types.GenRule crit -> Types.GenRule crit -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SLL),1*U(1*U,1*U,1*U(U))><S(SLL),1*U(1*U,1*U,1*U(U))>,
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   $dEq :: GHC.Classes.Eq crit
                   a :: Types.GenRule crit
                   b :: Types.GenRule crit ->
                 case Types.$fEqGenRule_$c== @ crit $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fEqGenRule_$c== ::
    GHC.Classes.Eq crit =>
    Types.GenRule crit -> Types.GenRule crit -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(SLL),1*U(1*U,1*U,1*U(U))><S(SLL),1*U(1*U,1*U,1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   w :: GHC.Classes.Eq crit
                   w1 :: Types.GenRule crit
                   w2 :: Types.GenRule crit ->
                 case w1 of ww { Types.Rule ww1 ww2 ww3 ->
                 case w2 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 Types.$w$c==1 @ crit w ww1 ww2 ww3 ww5 ww6 ww7 } }) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fEqInputCriteria ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Types.InputCriteria a)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dEq :: GHC.Classes.Eq a.
                  @ (Types.InputCriteria a)
                  (Types.$fEqInputCriteria_$c== @ a $dEq)
                  (Types.$fEqInputCriteria_$c/= @ a $dEq) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fEqInputCriteria_$c/= ::
    GHC.Classes.Eq a =>
    Types.InputCriteria a -> Types.InputCriteria a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dEq :: GHC.Classes.Eq a
                   a1 :: Types.InputCriteria a
                   b :: Types.InputCriteria a ->
                 case Types.$fEqInputCriteria_$c== @ a $dEq a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fEqInputCriteria_$c== ::
    GHC.Classes.Eq a =>
    Types.InputCriteria a -> Types.InputCriteria a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fEqState :: GHC.Classes.Eq Types.State
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.State Types.$fEqState_$c== Types.$fEqState_$c/= -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fEqState_$c/= :: Types.State -> Types.State -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.State b :: Types.State ->
                 case a of wild { Types.Time a1 ->
                 case b of wild1 { Types.Time b1 ->
                 case a1 of wild2 { GHC.Types.I# x ->
                 case b1 of wild3 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x y) of wild4 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } } } }) -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fEqState_$c== :: Types.State -> Types.State -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Types.State ds1 :: Types.State ->
                 case ds of wild { Types.Time a1 ->
                 case ds1 of wild1 { Types.Time b1 ->
                 GHC.Classes.eqInt a1 b1 } }) -}
2d45766896fc1eac836fade4900804ad
  $fEqSynthInstruction ::
    GHC.Classes.Eq r => GHC.Classes.Eq (Types.SynthInstruction r)
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r $dEq :: GHC.Classes.Eq r.
                  @ (Types.SynthInstruction r)
                  (Types.$fEqSynthInstruction_$c== @ r $dEq)
                  (Types.$fEqSynthInstruction_$c/= @ r $dEq) -}
2d45766896fc1eac836fade4900804ad
  $fEqSynthInstruction_$c/= ::
    GHC.Classes.Eq r =>
    Types.SynthInstruction r
    -> Types.SynthInstruction r -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   $dEq :: GHC.Classes.Eq r
                   a :: Types.SynthInstruction r
                   b :: Types.SynthInstruction r ->
                 case Types.$fEqSynthInstruction_$c== @ r $dEq a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
2d45766896fc1eac836fade4900804ad
  $fEqSynthInstruction_$c== ::
    GHC.Classes.Eq r =>
    Types.SynthInstruction r
    -> Types.SynthInstruction r -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(1*C1(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: (\ @ r
                   $dEq :: GHC.Classes.Eq r
                   ds :: Types.SynthInstruction r
                   ds1 :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed a1 a2
                   -> case ds1 of wild1 {
                        Types.ToChainNamed b1 b2
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.== @ r $dEq a2 b2 }
                        Types.NoInstruction ipv -> GHC.Types.False }
                   Types.NoInstruction a1
                   -> case ds1 of wild1 {
                        Types.ToChainNamed ipv ipv1 -> GHC.Types.False
                        Types.NoInstruction b1 -> GHC.Classes.== @ r $dEq a1 b1 } }) -}
c86273e8d5a2db581a040f85173b28c7
  $fEqTarget :: GHC.Classes.Eq Types.Target
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target Types.$fEqTarget_$c== Types.$fEqTarget_$c/= -}
c86273e8d5a2db581a040f85173b28c7
  $fEqTarget_$c/= :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Types.Target b :: Types.Target ->
                 case Types.$fEqTarget_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
c86273e8d5a2db581a040f85173b28c7
  $fEqTarget_$c== :: Types.Target -> Types.Target -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Types.Target ds1 :: Types.Target ->
                 case ds of wild {
                   Types.Jump a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Jump b1 -> GHC.Base.eqString a1 b1 }
                   Types.GoTo a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.GoTo b1 -> GHC.Base.eqString a1 b1 }
                   Types.Go a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.Go b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.eqInt a2 b2 } } } }
                   Types.GoReturn a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.GoReturn b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.eqInt a2 b2 } } } }
                   Types.ACCEPT
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.ACCEPT -> GHC.Types.True }
                   Types.DROP
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.DROP -> GHC.Types.True }
                   Types.RETURN
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Types.RETURN -> GHC.Types.True }
                   Types.PropVariableTarget a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.PropVariableTarget b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Classes.$fEqBool_$c== a2 b2 } } } }
                   Types.UnrecognizedTarget a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.UnrecognizedTarget b1 b2
                        -> case a1 of wild2 { GHC.Types.I# x ->
                           case b1 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> GHC.Base.eqString a2 b2 } } } }
                   Types.ST a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.ST b1 -> GHC.Base.eqString a1 b1 } }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule :: GHC.Base.Monoid (Types.InputRule a)
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a.
                  @ (Types.InputRule a)
                  (Types.$fMonoidGenRule_$cmempty @ a)
                  (Types.$fMonoidGenRule_$cmappend @ a)
                  (Types.$fMonoidGenRule_$cmconcat @ a) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule0 :: GHC.Base.Monoid Types.Rule
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Rule
                  Types.$fMonoidGenRule0_$cmempty
                  Types.$fMonoidGenRule0_$cmappend
                  Types.$fMonoidGenRule0_$cmconcat -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule0_$cmappend ::
    Types.Rule -> Types.Rule -> Types.Rule
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U,1*U(U))><S,1*U(1*U,1*U,1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 Types.Rule
                   @ Types.Criteria
                   (GHC.Base.++ @ Types.Criteria ww1 ww5)
                   (GHC.Base.++ @ Types.Target ww2 ww6)
                   (GHC.Classes.$fOrdInt_$cmax ww3 ww7) } }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule0_$cmconcat :: [Types.Rule] -> Types.Rule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Types.Rule] ->
                 case Types.$wgo w of ww { (#,,#) ww1 ww2 ww3 ->
                 Types.Rule @ Types.Criteria ww1 ww2 ww3 }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule0_$cmempty :: Types.Rule
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Types.Rule
                   @ Types.Criteria
                   (GHC.Types.[] @ Types.Criteria)
                   (GHC.Types.[] @ Types.Target)
                   GHC.Base.minInt) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule1 ::
    [Types.InputRule a]
    -> (# [Types.InputCriteria a], [Types.Target], Types.Label #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule_$cmappend ::
    Types.InputRule a -> Types.InputRule a -> Types.InputRule a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(1*U,1*U,1*U(U))><S,1*U(1*U,1*U,1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a w :: Types.InputRule a w1 :: Types.InputRule a ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 Types.Rule
                   @ (Types.InputCriteria a)
                   (GHC.Base.++ @ (Types.InputCriteria a) ww1 ww5)
                   (GHC.Base.++ @ Types.Target ww2 ww6)
                   (GHC.Classes.$fOrdInt_$cmax ww3 ww7) } }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule_$cmconcat ::
    [Types.InputRule a] -> Types.InputRule a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a w :: [Types.InputRule a] ->
                 case Types.$fMonoidGenRule1 @ a w of ww { (#,,#) ww1 ww2 ww3 ->
                 Types.Rule @ (Types.InputCriteria a) ww1 ww2 ww3 }) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fMonoidGenRule_$cmempty :: Types.InputRule a
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (\ @ a ->
                 Types.Rule
                   @ (Types.InputCriteria a)
                   (GHC.Types.[] @ (Types.InputCriteria a))
                   (GHC.Types.[] @ Types.Target)
                   GHC.Base.minInt) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag :: GHC.Classes.Ord Types.Flag
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Flag
                  Types.$fEqFlag
                  Types.$fOrdFlag_$ccompare
                  Types.$fOrdFlag_$c<
                  Types.$fOrdFlag_$c<=
                  Types.$fOrdFlag_$c>
                  Types.$fOrdFlag_$c>=
                  Types.$fOrdFlag_$cmax
                  Types.$fOrdFlag_$cmin -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$c< :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.False
                        Types.ACK -> GHC.Types.True
                        Types.FIN -> GHC.Types.True
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.ACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.FIN -> GHC.Types.True
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False Types.URG -> GHC.Types.True }
                   Types.URG -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$c<= :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN -> case b of wild1 { DEFAULT -> GHC.Types.True }
                   Types.ACK
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.False
                        Types.ACK -> GHC.Types.True
                        Types.FIN -> GHC.Types.True
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.FIN -> GHC.Types.True
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False
                        Types.RST -> GHC.Types.True
                        Types.URG -> GHC.Types.True }
                   Types.URG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.False Types.URG -> GHC.Types.True } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$c> :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN -> case b of wild1 { DEFAULT -> GHC.Types.False }
                   Types.ACK
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.True
                        Types.ACK -> GHC.Types.False
                        Types.FIN -> GHC.Types.False
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Types.FIN -> GHC.Types.False
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.URG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.URG -> GHC.Types.False } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$c>= :: Types.Flag -> Types.Flag -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.True
                        Types.ACK -> GHC.Types.False
                        Types.FIN -> GHC.Types.False
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.ACK
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Types.FIN -> GHC.Types.False
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True
                        Types.RST -> GHC.Types.False
                        Types.URG -> GHC.Types.False }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Types.URG -> GHC.Types.False }
                   Types.URG -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$ccompare ::
    Types.Flag -> Types.Flag -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ a :: Types.Flag b :: Types.Flag ->
                 case a of wild {
                   Types.SYN
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.EQ
                        Types.ACK -> GHC.Types.LT
                        Types.FIN -> GHC.Types.LT
                        Types.RST -> GHC.Types.LT
                        Types.URG -> GHC.Types.LT }
                   Types.ACK
                   -> case b of wild1 {
                        Types.SYN -> GHC.Types.GT
                        Types.ACK -> GHC.Types.EQ
                        Types.FIN -> GHC.Types.LT
                        Types.RST -> GHC.Types.LT
                        Types.URG -> GHC.Types.LT }
                   Types.FIN
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Types.FIN -> GHC.Types.EQ
                        Types.RST -> GHC.Types.LT
                        Types.URG -> GHC.Types.LT }
                   Types.RST
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT
                        Types.RST -> GHC.Types.EQ
                        Types.URG -> GHC.Types.LT }
                   Types.URG
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.GT Types.URG -> GHC.Types.EQ } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$cmax :: Types.Flag -> Types.Flag -> Types.Flag
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: Types.Flag y :: Types.Flag ->
                 case x of wild {
                   Types.SYN -> y
                   Types.ACK
                   -> case y of wild1 {
                        DEFAULT -> Types.ACK
                        Types.FIN -> Types.FIN
                        Types.RST -> Types.RST
                        Types.URG -> Types.URG }
                   Types.FIN
                   -> case y of wild1 {
                        DEFAULT -> Types.FIN
                        Types.RST -> Types.RST
                        Types.URG -> Types.URG }
                   Types.RST
                   -> case y of wild1 { DEFAULT -> Types.RST Types.URG -> Types.URG }
                   Types.URG -> case y of wild1 { DEFAULT -> Types.URG } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fOrdFlag_$cmin :: Types.Flag -> Types.Flag -> Types.Flag
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ x :: Types.Flag y :: Types.Flag ->
                 case x of wild {
                   Types.SYN -> case y of wild1 { DEFAULT -> Types.SYN }
                   Types.ACK
                   -> case y of wild1 {
                        Types.SYN -> Types.SYN
                        Types.ACK -> Types.ACK
                        Types.FIN -> Types.ACK
                        Types.RST -> Types.ACK
                        Types.URG -> Types.ACK }
                   Types.FIN
                   -> case y of wild1 {
                        DEFAULT -> wild1
                        Types.FIN -> Types.FIN
                        Types.RST -> Types.FIN
                        Types.URG -> Types.FIN }
                   Types.RST
                   -> case y of wild1 {
                        DEFAULT -> wild1 Types.RST -> Types.RST Types.URG -> Types.RST }
                   Types.URG -> y }) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fShowCriteria :: GHC.Show.Show Types.Criteria
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Criteria
                  Types.$fShowCriteria_$cshowsPrec
                  Types.$fShowCriteria_$cshow
                  Types.$fShowCriteria_$cshowList -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fShowCriteria1 :: Types.Criteria -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Types.Criteria -> Types.$w$cshowsPrec 0 w) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fShowCriteria_$cshow :: Types.Criteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Criteria ->
                 Types.$fShowCriteria_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fShowCriteria_$cshowList :: [Types.Criteria] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Criteria
                   Types.$fShowCriteria1) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $fShowCriteria_$cshowsPrec ::
    GHC.Types.Int -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.Criteria ->
                 case w of ww { GHC.Types.I# ww1 -> Types.$w$cshowsPrec ww1 w1 }) -}
55973a7fc1eaa199e3fcffaea36f620c
  $fShowEndpoint :: GHC.Show.Show Types.Endpoint
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Endpoint
                  Types.$fShowEndpoint_$cshowsPrec
                  Types.$fShowEndpoint_$cshow
                  Types.$fShowEndpoint_$cshowList -}
55973a7fc1eaa199e3fcffaea36f620c
  $fShowEndpoint1 :: Types.Endpoint -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Types.Endpoint eta :: GHC.Base.String ->
                 case ds of wild {
                   Types.Source
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Types.$fShowEndpoint3)
                        eta
                   Types.Destination
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Types.$fShowEndpoint2)
                        eta }) -}
81212b2fc6aabdde5d84c21a5fda5557
  $fShowEndpoint2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Destination"#) -}
603b329c77fe7f8c2142a5c31eeaa500
  $fShowEndpoint3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Source"#) -}
55973a7fc1eaa199e3fcffaea36f620c
  $fShowEndpoint_$cshow :: Types.Endpoint -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Endpoint ->
                 case x of wild {
                   Types.Source -> Types.$fShowEndpoint3
                   Types.Destination -> Types.$fShowEndpoint2 }) -}
55973a7fc1eaa199e3fcffaea36f620c
  $fShowEndpoint_$cshowList :: [Types.Endpoint] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Endpoint
                   Types.$fShowEndpoint1) -}
55973a7fc1eaa199e3fcffaea36f620c
  $fShowEndpoint_$cshowsPrec ::
    GHC.Types.Int -> Types.Endpoint -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int
                   ds1 :: Types.Endpoint
                   eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Types.Source
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Types.$fShowEndpoint3)
                        eta
                   Types.Destination
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Types.$fShowEndpoint2)
                        eta }) -}
5d53fcbd3679645285b943aca51fb623
  $fShowExample :: GHC.Show.Show Types.Example
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Example
                  Types.$fShowExample_$cshowsPrec
                  Types.$fShowExample_$cshow
                  Types.$fShowExample_$cshowList -}
5d53fcbd3679645285b943aca51fb623
  $fShowExample1 :: Types.Example -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.Example w1 :: GHC.Base.String ->
                 case w of ww { Types.Example ww1 ww2 ->
                 Types.$w$cshowsPrec1 0 ww1 ww2 w1 }) -}
ccdc855d8032453b4e1614a4bb96ccc3
  $fShowExample2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Example {"#) -}
822f415556b2f979a77b321d850aacfe
  $fShowExample3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Time "#) -}
bf744a8629a4aecaba33139f71b8c9ec
  $fShowExample4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
2a56c276988c7d8082d4e99ac0e61e4d
  $fShowExample5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "state = "#) -}
22efa82f1b2ee77d24e817caacab6b9b
  $fShowExample6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
c969c021e1b80e56d50a69c8ad1727a3
  $fShowExample7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "exRule = "#) -}
5d53fcbd3679645285b943aca51fb623
  $fShowExample_$cshow :: Types.Example -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U,1*U,1*U(U)),1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Example ->
                 Types.$fShowExample_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
5d53fcbd3679645285b943aca51fb623
  $fShowExample_$cshowList :: [Types.Example] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Example
                   Types.$fShowExample1) -}
5d53fcbd3679645285b943aca51fb623
  $fShowExample_$cshowsPrec ::
    GHC.Types.Int -> Types.Example -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S,1*U(U)><S,1*U(1*U(1*U,1*U,1*U(U)),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.Example w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Types.Example ww3 ww4 ->
                 Types.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
89a04067a57a11855a548d82893fcb82
  $fShowFileInput :: GHC.Show.Show Types.FileInput
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.FileInput
                  Types.$fShowFileInput_$cshowsPrec
                  Types.$fShowFileInput_$cshow
                  Types.$fShowFileInput_$cshowList -}
89a04067a57a11855a548d82893fcb82
  $fShowFileInput1 :: Types.FileInput -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.FileInput w1 :: GHC.Base.String ->
                 Types.$w$cshowsPrec3 0 w w1) -}
05abff6e26e495bcb7d5428b50769751
  $fShowFileInput2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "InCUnrecognizedCriteria "#) -}
d6ce85922b285212faa86860b7072044
  $fShowFileInput3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "InCLimit "#) -}
89a04067a57a11855a548d82893fcb82
  $fShowFileInput_$cshow :: Types.FileInput -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.FileInput ->
                 Types.$fShowFileInput_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
89a04067a57a11855a548d82893fcb82
  $fShowFileInput_$cshowList :: [Types.FileInput] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.FileInput
                   Types.$fShowFileInput1) -}
89a04067a57a11855a548d82893fcb82
  $fShowFileInput_$cshowsPrec ::
    GHC.Types.Int -> Types.FileInput -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Types.FileInput
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Types.$w$cshowsPrec3 ww1 w1 w2 }) -}
8787caaca59e38ad2a9bb8caed366b89
  $fShowFlag :: GHC.Show.Show Types.Flag
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Flag
                  Types.$fShowFlag_$cshowsPrec
                  Types.$fShowFlag_$cshow
                  Types.$fShowFlag_$cshowList -}
a07e2da102a2b48ee57d811bad79716f
  $fShowFlag1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "URG"#) -}
5666d442d8107d5480a7e725cc013c50
  $fShowFlag2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RST"#) -}
9115f351c9cf00e07b446d32244caf9c
  $fShowFlag3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FIN"#) -}
13bd771eeab75548483bcd27f0e0c99b
  $fShowFlag4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACK"#) -}
dfd6d9d25b5020133dcc550795c302c4
  $fShowFlag5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SYN"#) -}
8787caaca59e38ad2a9bb8caed366b89
  $fShowFlag_$cshow :: Types.Flag -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Flag ->
                 Types.$fShowFlag_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8787caaca59e38ad2a9bb8caed366b89
  $fShowFlag_$cshowList :: [Types.Flag] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Flag
                   Types.$w$cshowsPrec4) -}
8787caaca59e38ad2a9bb8caed366b89
  $fShowFlag_$cshowsPrec ::
    GHC.Types.Int -> Types.Flag -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int w1 :: Types.Flag w2 :: GHC.Base.String ->
                 Types.$w$cshowsPrec4 w1 w2) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fShowGenRule ::
    GHC.Show.Show crit => GHC.Show.Show (Types.GenRule crit)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(A,A,C(U))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ crit $dShow :: GHC.Show.Show crit.
                  @ (Types.GenRule crit)
                  (Types.$fShowGenRule_$cshowsPrec @ crit $dShow)
                  (Types.$fShowGenRule_$cshow @ crit $dShow)
                  (Types.$fShowGenRule_$cshowList @ crit $dShow) -}
7ae29fd63fdfdb0515a8949c83cfdb72
  $fShowGenRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
d22dab7a66ab903f7e2da818176f6910
  $fShowGenRule2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "label = "#) -}
6bc0c6bafccfbdfdf5ed3eb3797578f5
  $fShowGenRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "targets = "#) -}
f7dfc85147b7d34eefc2ba6821235eab
  $fShowGenRule4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "criteria = "#) -}
b6781abb6b7944f4f8a4b3458da1314a
  $fShowGenRule5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Rule {"#) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fShowGenRule_$cshow ::
    GHC.Show.Show crit => Types.GenRule crit -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(A,A,1*C1(U))><S,1*U(U,U,U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ @ crit $dShow :: GHC.Show.Show crit x :: Types.GenRule crit ->
                 Types.$fShowGenRule_$cshowsPrec
                   @ crit
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fShowGenRule_$cshowList ::
    GHC.Show.Show crit => [Types.GenRule crit] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,A,C(U))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   $dShow :: GHC.Show.Show crit
                   eta :: [Types.GenRule crit]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Types.GenRule crit)
                   (Types.$fShowGenRule_$cshowsPrec
                      @ crit
                      $dShow
                      Types.$fShowGenRule1)
                   eta
                   eta1) -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $fShowGenRule_$cshowsPrec ::
    GHC.Show.Show crit =>
    GHC.Types.Int -> Types.GenRule crit -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(A,A,1*C1(U))><S,1*U(U)><S,1*U(U,U,U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ crit
                   w :: GHC.Show.Show crit
                   w1 :: GHC.Types.Int
                   w2 :: Types.GenRule crit ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Types.Rule ww3 ww4 ww5 ->
                 Types.$w$cshowsPrec5 @ crit w ww1 ww3 ww4 ww5 } }) -}
c86273e8d5a2db581a040f85173b28c7
  $fShowGenRule_$cshowsPrec1 ::
    GHC.Types.Int -> Types.Target -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fShowInputCriteria ::
    GHC.Show.Show a => GHC.Show.Show (Types.InputCriteria a)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a $dShow :: GHC.Show.Show a.
                  @ (Types.InputCriteria a)
                  (Types.$fShowInputCriteria_$cshowsPrec @ a $dShow)
                  (Types.$fShowInputCriteria_$cshow @ a $dShow)
                  (Types.$fShowInputCriteria_$cshowList @ a $dShow) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fShowInputCriteria_$cshow ::
    GHC.Show.Show a => Types.InputCriteria a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(C(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a $dShow :: GHC.Show.Show a x :: Types.InputCriteria a ->
                 Types.$fShowInputCriteria_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fShowInputCriteria_$cshowList ::
    GHC.Show.Show a => [Types.InputCriteria a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   $dShow :: GHC.Show.Show a
                   eta :: [Types.InputCriteria a]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Types.InputCriteria a)
                   (Types.$fShowInputCriteria_$cshowsPrec
                      @ a
                      $dShow
                      Types.$fShowGenRule1)
                   eta
                   eta1) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $fShowInputCriteria_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Types.InputCriteria a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   w :: GHC.Show.Show a
                   w1 :: GHC.Types.Int
                   w2 :: Types.InputCriteria a ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Types.$w$cshowsPrec6 @ a w ww1 w2 }) -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fShowState :: GHC.Show.Show Types.State
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.State
                  Types.$fShowState_$cshowsPrec
                  Types.$fShowState_$cshow
                  Types.$fShowState_$cshowList -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fShowState1 :: Types.State -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Types.State w1 :: GHC.Base.String ->
                 case w of ww { Types.Time ww1 ->
                 Types.$w$cshowsPrec2 0 ww1 w1 }) -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fShowState_$cshow :: Types.State -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.State ->
                 Types.$fShowState_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fShowState_$cshowList :: [Types.State] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.State
                   Types.$fShowState1) -}
de92fe5b7c87fc4f092b6c97d49d061f
  $fShowState_$cshowsPrec ::
    GHC.Types.Int -> Types.State -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Types.State w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Types.Time ww3 ->
                 Types.$w$cshowsPrec2 ww1 ww3 w2 } }) -}
2d45766896fc1eac836fade4900804ad
  $fShowSynthInstruction ::
    GHC.Show.Show r => GHC.Show.Show (Types.SynthInstruction r)
  DFunId[0]
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ r $dShow :: GHC.Show.Show r.
                  @ (Types.SynthInstruction r)
                  (Types.$fShowSynthInstruction_$cshowsPrec @ r $dShow)
                  (Types.$fShowSynthInstruction_$cshow @ r $dShow)
                  (Types.$fShowSynthInstruction_$cshowList @ r $dShow) -}
d5fd1cdfde79c82c0c0699c4b9f9e58e
  $fShowSynthInstruction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoInstruction {"#) -}
8cbafb84264fcbfa78254e343ab3f501
  $fShowSynthInstruction2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "insRule = "#) -}
275d1b7bc46599703a07bc5e35815f60
  $fShowSynthInstruction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chainName = "#) -}
4fcb1ec2290f2c9d0f9cceea84a88a71
  $fShowSynthInstruction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ToChainNamed {"#) -}
2d45766896fc1eac836fade4900804ad
  $fShowSynthInstruction_$cshow ::
    GHC.Show.Show r => Types.SynthInstruction r -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ r $dShow :: GHC.Show.Show r x :: Types.SynthInstruction r ->
                 Types.$fShowSynthInstruction_$cshowsPrec
                   @ r
                   $dShow
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
2d45766896fc1eac836fade4900804ad
  $fShowSynthInstruction_$cshowList ::
    GHC.Show.Show r => [Types.SynthInstruction r] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   $dShow :: GHC.Show.Show r
                   eta :: [Types.SynthInstruction r]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (Types.SynthInstruction r)
                   (Types.$fShowSynthInstruction_$cshowsPrec
                      @ r
                      $dShow
                      Types.$fShowGenRule1)
                   eta
                   eta1) -}
2d45766896fc1eac836fade4900804ad
  $fShowSynthInstruction_$cshowsPrec ::
    GHC.Show.Show r =>
    GHC.Types.Int -> Types.SynthInstruction r -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U(U)><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ r
                   w :: GHC.Show.Show r
                   w1 :: GHC.Types.Int
                   w2 :: Types.SynthInstruction r ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Types.$w$cshowsPrec7 @ r w ww1 w2 }) -}
c86273e8d5a2db581a040f85173b28c7
  $fShowTarget :: GHC.Show.Show Types.Target
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Types.Target
                  Types.$fShowGenRule_$cshowsPrec1
                  Types.$fShowTarget_$cshow
                  Types.$fShowTarget_$cshowList -}
c86273e8d5a2db581a040f85173b28c7
  $fShowTarget1 :: Types.Target -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Types.$fShowGenRule_$cshowsPrec1
                   Types.$fShowGenRule1) -}
c86273e8d5a2db581a040f85173b28c7
  $fShowTarget_$cshow :: Types.Target -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Target ->
                 Types.$fShowGenRule_$cshowsPrec1
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c86273e8d5a2db581a040f85173b28c7
  $fShowTarget_$cshowList :: [Types.Target] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Types.Target
                   Types.$fShowTarget1) -}
33ae5d8b19ea2f2317f3565122997902
  $fToStringChar :: Data.String.ToString.ToString GHC.Types.Char
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringChar_$ctoString
                  `cast`
                (Sym (Data.String.ToString.NTCo:ToString[0] <GHC.Types.Char>_N)) -}
6b8d8cc0e786c6703f42e2426b5ba3ce
  $fToStringChar_$ctoString :: GHC.Types.Char -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: GHC.Types.Char ->
                 GHC.Types.: @ GHC.Types.Char x (GHC.Types.[] @ GHC.Types.Char)) -}
234bf9dd9eb040c563aedf7faf9a9d81
  $fToStringInt :: Data.String.ToString.ToString GHC.Types.Int
  DFunId[0]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                Types.$fToStringInt_$ctoString
                  `cast`
                (Sym (Data.String.ToString.NTCo:ToString[0] <GHC.Types.Int>_N)) -}
07880c5c41c52e5267732da9fe80737b
  $fToStringInt_$ctoString :: GHC.Types.Int -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m2,
     Unfolding: InlineRule (0, True, True) GHC.Show.$fShowInt_$cshow -}
35b3fa811bccd7f4f16f0fd4017aec33
  $s$fShow(,) :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (GHC.Types.Int, GHC.Types.Int)
                  (GHC.Show.$fShow(,)_$cshowsPrec
                     @ GHC.Types.Int
                     @ GHC.Types.Int
                     GHC.Show.$fShowInt
                     GHC.Show.$fShowInt)
                  Types.$s$fShow(,)_$s$fShow(,)_$cshow
                  Types.$s$fShow(,)_$s$fShow(,)_$cshowList -}
f2924be10a90a0186b399809837cf167
  $s$fShow(,)_$s$fShow(,)_$cshow ::
    (GHC.Types.Int, GHC.Types.Int) -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(1*U(U),U(U))>m2,
     Unfolding: InlineRule (1, True, False)
                (\ x :: (GHC.Types.Int, GHC.Types.Int) ->
                 GHC.Show.$fShow(,)_$cshowsPrec
                   @ GHC.Types.Int
                   @ GHC.Types.Int
                   GHC.Show.$fShowInt
                   GHC.Show.$fShowInt
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
87ce232c44ef923f656e8e6cad5985e5
  $s$fShow(,)_$s$fShow(,)_$cshowList ::
    [(GHC.Types.Int, GHC.Types.Int)] -> GHC.Show.ShowS
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ eta :: [(GHC.Types.Int, GHC.Types.Int)]
                   eta1 :: GHC.Base.String ->
                 GHC.Show.showList__
                   @ (GHC.Types.Int, GHC.Types.Int)
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ GHC.Types.Int
                      @ GHC.Types.Int
                      GHC.Show.$fShowInt
                      GHC.Show.$fShowInt
                      GHC.Show.shows18)
                   eta
                   eta1) -}
6116014f7d8ca04cf206a2110e8284c5
  $sfromList :: [(Types.Flag, a)] -> Data.Map.Base.Map Types.Flag a
  {- Arity: 1, Strictness: <S,1*U> -}
131ff6a6f4d2687e3fe12384233af019
  $sfromList1 ::
    [(GHC.Base.String, a)] -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a ds :: [(GHC.Base.String, a)] ->
                 case ds of wild {
                   [] -> Data.Map.Base.Tip @ GHC.Base.String @ a
                   : ds1 ds2
                   -> case ds1 of wild1 { (,) kx x ->
                      case ds2 of wild2 {
                        []
                        -> case kx of dt { DEFAULT ->
                           Data.Map.Base.Bin
                             @ GHC.Base.String
                             @ a
                             1
                             dt
                             x
                             (Data.Map.Base.Tip @ GHC.Base.String @ a)
                             (Data.Map.Base.Tip @ GHC.Base.String @ a) }
                        : ipv ipv1
                        -> case ipv of wild3 { (,) ky ds3 ->
                           case GHC.Classes.$fOrd[]_$s$ccompare1 kx ky of wild4 {
                             DEFAULT
                             -> case kx of dt { DEFAULT ->
                                Types.$sfromList2
                                  @ a
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 }
                             GHC.Types.LT
                             -> case kx of dt { DEFAULT ->
                                Types.$wpoly_go10
                                  @ a
                                  1
                                  (Data.Map.Base.Bin
                                     @ GHC.Base.String
                                     @ a
                                     1
                                     dt
                                     x
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a)
                                     (Data.Map.Base.Tip @ GHC.Base.String @ a))
                                  wild2 } } } } } }) -}
4acf68a411c8367a97a1faaca967be54
  $sfromList2 ::
    Data.Map.Base.Map GHC.Base.String a1
    -> [(GHC.Base.String, a1)] -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
cd14340079ae700f4a159d0dbcfada5d
  $sinsert_$sgo1 ::
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
68e17ccedf68a210dfdd2d83ec15a8cf
  $sinsert_$sgo10 ::
    Types.Flag
    -> a1
    -> Data.Map.Base.Map Types.Flag a1
    -> Data.Map.Base.Map Types.Flag a1
  {- Arity: 3, Strictness: <S,1*U><L,U><S,1*U> -}
89405310f4a4f475562a9bc2ca3af37c
  $slookup1 ::
    Types.Flag -> Data.Map.Base.Map Types.Flag a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
239e5c2f48124edfd4eebe7c94a4c2b7
  $w$c== ::
    [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> [Types.State]
    -> [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> [Types.State]
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U(U)><L,1*U><S,1*U><L,1*U><L,1*U(U)><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: [Types.Criteria]
                   ww1 :: [Types.Target]
                   ww2 :: Types.Label
                   ww3 :: [Types.State]
                   ww4 :: [Types.Criteria]
                   ww5 :: [Types.Target]
                   ww6 :: Types.Label
                   ww7 :: [Types.State] ->
                 case GHC.Classes.$fEq[]_$c==
                        @ Types.Criteria
                        Types.$fEqCriteria
                        ww
                        ww4 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ Types.Target
                             Types.$fEqTarget
                             ww1
                             ww5 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww2 of wild2 { GHC.Types.I# x ->
                           case ww6 of wild3 { GHC.Types.I# y ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.==# x y) of wild4 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.$fEq[]_$c==
                                  @ Types.State
                                  Types.$fEqState
                                  ww3
                                  ww7 } } } } }) -}
1a5b5663bd6e0b4a7402fc63cd296182
  $w$c==1 ::
    GHC.Classes.Eq crit =>
    [crit]
    -> [Types.Target]
    -> Types.Label
    -> [crit]
    -> [Types.Target]
    -> Types.Label
    -> GHC.Types.Bool
  {- Arity: 7, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><L,1*U><L,1*U(U)><S,1*U><L,1*U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ @ crit
                   w :: GHC.Classes.Eq crit
                   ww :: [crit]
                   ww1 :: [Types.Target]
                   ww2 :: Types.Label
                   ww3 :: [crit]
                   ww4 :: [Types.Target]
                   ww5 :: Types.Label ->
                 case GHC.Classes.$fEq[]_$c== @ crit w ww ww3 of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ Types.Target
                             Types.$fEqTarget
                             ww1
                             ww4 of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True -> GHC.Classes.eqInt ww2 ww5 } }) -}
cd9fa80f07dac492cd3e2abc1ff8b6ce
  $w$cshowsPrec :: GHC.Prim.Int# -> Types.Criteria -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0] -}
3759f6209a2d33d77762d0e252a5b5a9
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> Types.Rule
    -> [Types.State]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <L,U><L,1*U(1*U,1*U,1*U(U))><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Types.Rule
                   ww2 :: [Types.State]
                   w :: GHC.Base.String ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Types.$fShowExample7
                       (case ww1 of ww3 { Types.Rule ww4 ww5 ww6 ->
                        Types.$w$s$cshowsPrec
                          0
                          ww4
                          ww5
                          ww6
                          (GHC.Base.++
                             @ GHC.Types.Char
                             Types.$fShowExample6
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.$fShowExample5
                                (let {
                                   s :: GHC.Base.String
                                   = GHC.Base.++ @ GHC.Types.Char Types.$fShowExample4 x
                                 } in
                                 case ww2 of wild {
                                   [] -> GHC.CString.unpackAppendCString# "[]"# s
                                   : x1 xs
                                   -> GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showList__3
                                        (case x1 of ww7 { Types.Time ww8 ->
                                         Types.$w$cshowsPrec2
                                           0
                                           ww8
                                           (let {
                                              lvl41 :: [GHC.Types.Char]
                                              = GHC.Types.: @ GHC.Types.Char GHC.Show.showList__2 s
                                            } in
                                            letrec {
                                              showl :: [Types.State] -> [GHC.Types.Char]
                                                {- Arity: 1, Strictness: <S,1*U> -}
                                              = \ ds2 :: [Types.State] ->
                                                case ds2 of wild1 {
                                                  [] -> lvl41
                                                  : y ys
                                                  -> GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.showList__1
                                                       (case y of ww9 { Types.Time ww10 ->
                                                        Types.$w$cshowsPrec2 0 ww10 (showl ys) }) }
                                            } in
                                            showl xs) }) }))) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Types.$fShowExample2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Types.$fShowExample2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w))) }) -}
287212ef758d6354b120f877cfd68516
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Types.Seconds -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Types.Seconds
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Types.$fShowExample3
                        (case ww1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11 ww3 w of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Types.$fShowExample3
                           (case ww1 of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows8
                                      w) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
89a04067a57a11855a548d82893fcb82
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> Types.FileInput -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   w :: Types.FileInput
                   w1 :: GHC.Base.String ->
                 case w of wild {
                   Types.InCLimit b1 b2 b3
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.$fShowFileInput3
                            (case b1 of ww2 { GHC.Types.I# ww3 ->
                             case GHC.Show.$wshowSignedInt
                                    11
                                    ww3
                                    (GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.showSpace1
                                       (case b2 of ww1 { GHC.Types.I# ww5 ->
                                        case GHC.Show.$wshowSignedInt
                                               11
                                               ww5
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.showSpace1
                                                  (case b3 of ww6 { GHC.Types.I# ww7 ->
                                                   case GHC.Show.$wshowSignedInt
                                                          11
                                                          ww7
                                                          x of ww4 { (#,#) ww8 ww9 ->
                                                   GHC.Types.:
                                                     @ GHC.Types.Char
                                                     ww8
                                                     ww9 } })) of ww4 { (#,#) ww6 ww7 ->
                                        GHC.Types.:
                                          @ GHC.Types.Char
                                          ww6
                                          ww7 } })) of ww4 { (#,#) ww5 ww6 ->
                             GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p w1
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }
                   Types.InCUnrecognizedCriteria b1
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> GHC.Base.++
                             @ GHC.Types.Char
                             Types.$fShowFileInput2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows6
                                (GHC.Show.showLitString
                                   b1
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1)))
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Types.$fShowFileInput2
                                (GHC.Types.:
                                   @ GHC.Types.Char
                                   GHC.Show.shows6
                                   (GHC.Show.showLitString
                                      b1
                                      (GHC.Types.:
                                         @ GHC.Types.Char
                                         GHC.Show.shows6
                                         (GHC.Types.:
                                            @ GHC.Types.Char
                                            GHC.Show.shows8
                                            w1))))) } }) -}
8787caaca59e38ad2a9bb8caed366b89
  $w$cshowsPrec4 :: Types.Flag -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Types.Flag w1 :: GHC.Base.String ->
                 case w of wild {
                   Types.SYN -> GHC.Base.++ @ GHC.Types.Char Types.$fShowFlag5 w1
                   Types.ACK -> GHC.Base.++ @ GHC.Types.Char Types.$fShowFlag4 w1
                   Types.FIN -> GHC.Base.++ @ GHC.Types.Char Types.$fShowFlag3 w1
                   Types.RST -> GHC.Base.++ @ GHC.Types.Char Types.$fShowFlag2 w1
                   Types.URG
                   -> GHC.Base.++ @ GHC.Types.Char Types.$fShowFlag1 w1 }) -}
5e5f89b6a1bb744f94060a5103c1e7c6
  $w$cshowsPrec5 ::
    GHC.Show.Show crit =>
    GHC.Prim.Int#
    -> [crit] -> [Types.Target] -> Types.Label -> GHC.Show.ShowS
  {- Arity: 5,
     Strictness: <L,1*U(A,A,1*C1(U))><L,U><L,U><L,U><L,U(U)>,
     Inline: [0],
     Unfolding: (\ @ crit
                   w :: GHC.Show.Show crit
                   ww :: GHC.Prim.Int#
                   ww1 :: [crit]
                   ww2 :: [Types.Target]
                   ww3 :: Types.Label ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showList @ crit w ww1
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Types.$fShowGenRule5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Types.$fShowGenRule4
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                Types.$fShowExample6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Types.$fShowGenRule3
                                   (let {
                                      s :: GHC.Base.String
                                      = GHC.Base.++
                                          @ GHC.Types.Char
                                          Types.$fShowExample6
                                          (GHC.Base.++
                                             @ GHC.Types.Char
                                             Types.$fShowGenRule2
                                             (case ww3 of ww4 { GHC.Types.I# ww5 ->
                                              case GHC.Show.$wshowSignedInt
                                                     0
                                                     ww5
                                                     (GHC.Base.++
                                                        @ GHC.Types.Char
                                                        Types.$fShowExample4
                                                        x) of ww6 { (#,#) ww7 ww8 ->
                                              GHC.Types.: @ GHC.Types.Char ww7 ww8 } }))
                                    } in
                                    case ww2 of wild {
                                      [] -> GHC.CString.unpackAppendCString# "[]"# s
                                      : x1 xs
                                      -> GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.showList__3
                                           (Types.$fShowGenRule_$cshowsPrec1
                                              Types.$fShowGenRule1
                                              x1
                                              (let {
                                                 lvl41 :: [GHC.Types.Char]
                                                 = GHC.Types.:
                                                     @ GHC.Types.Char
                                                     GHC.Show.showList__2
                                                     s
                                               } in
                                               letrec {
                                                 showl :: [Types.Target] -> [GHC.Types.Char]
                                                   {- Arity: 1, Strictness: <S,1*U> -}
                                                 = \ ds2 :: [Types.Target] ->
                                                   case ds2 of wild1 {
                                                     [] -> lvl41
                                                     : y ys
                                                     -> GHC.Types.:
                                                          @ GHC.Types.Char
                                                          GHC.Show.showList__1
                                                          (Types.$fShowGenRule_$cshowsPrec1
                                                             Types.$fShowGenRule1
                                                             y
                                                             (showl ys)) }
                                               } in
                                               showl xs)) })))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
f9dd8015851b3b1a4f6aafd664bf2e83
  $w$cshowsPrec6 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Types.InputCriteria a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0] -}
2d45766896fc1eac836fade4900804ad
  $w$cshowsPrec7 ::
    GHC.Show.Show r =>
    GHC.Prim.Int# -> Types.SynthInstruction r -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><L,U><S,1*U>,
     Inline: [0],
     Unfolding: (\ @ r
                   w :: GHC.Show.Show r
                   ww :: GHC.Prim.Int#
                   w1 :: Types.SynthInstruction r ->
                 case w1 of wild {
                   Types.ToChainNamed b1 b2
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ r w Types.$fShowGenRule1 b2
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.$fShowSynthInstruction4
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Types.$fShowSynthInstruction3
                               (GHC.Types.:
                                  @ GHC.Types.Char
                                  GHC.Show.shows6
                                  (GHC.Show.showLitString
                                     b1
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.shows6
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           Types.$fShowExample6
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Types.$fShowSynthInstruction2
                                              (f (GHC.Base.++
                                                    @ GHC.Types.Char
                                                    Types.$fShowExample4
                                                    x))))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   Types.NoInstruction b1
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = GHC.Show.showsPrec @ r w Types.$fShowGenRule1 b1
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Types.$fShowSynthInstruction1
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Types.$fShowSynthInstruction2
                               (f (GHC.Base.++ @ GHC.Types.Char Types.$fShowExample4 x)))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) } }) -}
931527dd5be4956305a1b4b7161c83ad
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> [Types.Criteria]
    -> [Types.Target]
    -> Types.Label
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Inline: [0] -}
3dc6d62e77db94c517aa1b70e09fcbe3
  $wgo ::
    [Types.Rule] -> (# [Types.Criteria], [Types.Target], Types.Label #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
eb4b25a94be2a342ce54e1529853a712
  $wgo1 ::
    GHC.Prim.Int#
    -> GHC.Word.Word64
    -> GHC.Word.Word64
    -> (# GHC.Word.Word64, GHC.Word.Word64 #)
  {- Arity: 3, Strictness: <S,U><L,1*U(U)><L,1*U(U)>, Inline: [0] -}
2d88199270b5539806778fef639af817
  $wgo2 :: GHC.Prim.Int# -> GHC.Prim.Word# -> GHC.Prim.Word#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
d350e3c33fa9cba723b4fec3016ffa8d
  $wgo3 ::
    [GHC.Types.Int]
    -> GHC.Word.Word64
    -> GHC.Word.Word64
    -> (# GHC.Word.Word64, GHC.Word.Word64 #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>, Inline: [0] -}
7fc6d8ca75d1bfaaac1d44ba8ea05de5
  $wgo4 :: [GHC.Types.Int] -> GHC.Prim.Word# -> GHC.Prim.Word#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
dfe032430ec449bef505cbaea13d9c2a
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Base.String a
    -> [(GHC.Base.String, a)]
    -> Data.Map.Base.Map GHC.Base.String a
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U>, Inline: [0] -}
3dbdd334c06dc203715a96fc567f1d9d
  type Chain = [Types.Rule]
c884b4bd8354c5f5ad5e611c0e6a2eb5
  type ChainId = GHC.Types.Int
cd9fa80f07dac492cd3e2abc1ff8b6ce
  data Criteria
    = BoolFlag Types.Flag
    | IPAddress Types.Endpoint Data.IP.Range.IPRange
    | Limit GHC.Types.Int GHC.Types.Int GHC.Types.Int GHC.Types.Int
    | Not Types.Criteria
    | Port Types.Endpoint
           (Data.Either.Either GHC.Types.Int (GHC.Types.Int, GHC.Types.Int))
    | PropVariableCriteria GHC.Types.Int
    | Protocol GHC.Types.Int
    | UnrecognizedCriteria GHC.Types.Int GHC.Base.String
    | SC GHC.Base.String
55973a7fc1eaa199e3fcffaea36f620c
  data Endpoint = Source | Destination
    Promotable
5d53fcbd3679645285b943aca51fb623
  data Example
    = Example {exRule :: Types.Rule, state :: [Types.State]}
71691c2d6c12b8de8269debd25ac2113
  type ExampleChain = [Types.Example]
c215d7344184927d45448be7f685ebd6
  type ExampleCriteria = Types.InputCriteria Types.State
3b01b508ea36d48a33c260bcddd81cec
  type ExampleInstruction = Types.SynthInstruction Types.Example
447fb30f3a0896a0958314ee1ccab876
  type ExampleRule = Types.GenRule Types.ExampleCriteria
46f347b42af3a8727d29e0c088cd167a
  type ExampleRuleInstruction =
    Types.SynthInstruction Types.ExampleRule
afffda57cf84b65c064abb67c0359334
  type FileChain = [Types.FileRule]
c97d8c97ce717d48999c803dd9ea2e81
  type FileCriteria = Types.InputCriteria Types.FileInput
89a04067a57a11855a548d82893fcb82
  data FileInput
    = InCLimit GHC.Types.Int GHC.Types.Int GHC.Types.Int
    | InCUnrecognizedCriteria GHC.Base.String
f0746210ee13027b6ae5867e8a7de3c9
  type FileInstruction = Types.SynthInstruction Types.FileRule
fc4d7c4fd549d01bfb03cec8d4f44ac3
  type FileRule = Types.GenRule Types.FileCriteria
8787caaca59e38ad2a9bb8caed366b89
  data Flag = SYN | ACK | FIN | RST | URG
    Promotable
3dc6d62e77db94c517aa1b70e09fcbe3
  data GenRule crit
    = Rule {criteria :: [crit],
            targets :: [Types.Target],
            label :: Types.Label}
265e9adb66422320621b5370de654514
  type InputChain a = [Types.InputRule a]
f9dd8015851b3b1a4f6aafd664bf2e83
  data InputCriteria a
    = InC Types.Criteria
    | Ext a
    | InCNot (Types.InputCriteria a)
    | And [Types.InputCriteria a]
    | Or [Types.InputCriteria a]
0bdaa4f442c452db1e8c138c216895ed
  type InputInstruction a =
    Types.SynthInstruction (Types.InputRule a)
3dc6d62e77db94c517aa1b70e09fcbe3
  type InputRule a = Types.GenRule (Types.InputCriteria a)
e8272939ad2c8b0969c48a3271151491
  type Instruction = Types.SynthInstruction Types.Rule
8ea1cbc35ff6354c4e178e365701b867
  type Label = GHC.Types.Int
a1a12e9eec1af74eb394d30b1e30a4e7
  type ModuleFunc =
    [GHC.Base.String]
    -> (GHC.Base.Maybe
          [Data.Either.Either Types.FileCriteria Types.Target],
        [GHC.Base.String])
3dc6d62e77db94c517aa1b70e09fcbe3
  type Rule = Types.GenRule Types.Criteria
ec4e9c89174bda268454f41b7b334f61
  type RuleInd = GHC.Types.Int
3e95ccfa4501046b7b6ccde5e31c35cc
  type Seconds = GHC.Types.Int
de92fe5b7c87fc4f092b6c97d49d061f
  data State = Time Types.Seconds
2d45766896fc1eac836fade4900804ad
  data SynthInstruction r
    = ToChainNamed {chainName :: GHC.Base.String, insRule :: r}
    | NoInstruction {insRule :: r}
c86273e8d5a2db581a040f85173b28c7
  data Target
    = Jump GHC.Base.String
    | GoTo GHC.Base.String
    | Go Types.ChainId Types.RuleInd
    | GoReturn Types.ChainId Types.RuleInd
    | ACCEPT
    | DROP
    | RETURN
    | PropVariableTarget GHC.Types.Int GHC.Types.Bool
    | UnrecognizedTarget GHC.Types.Int GHC.Base.String
    | ST GHC.Base.String
5684b30639c8102820ab42b9d83729d5
  boolFlagToFlag :: Types.Criteria -> Types.Flag
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Criteria ->
                 case ds of wild {
                   DEFAULT -> Types.boolFlagToFlag1 Types.BoolFlag x -> x }) -}
a9cf845751aeeea2dfec56d27a2172f2
  boolFlagToFlag1 :: Types.Flag
  {- Strictness: b -}
a80867638159762b187444a25391a975
  chainName :: Types.SynthInstruction r -> GHC.Base.String
  RecSel Types.SynthInstruction
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ r ds :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed ds1 ds2 -> ds1
                   Types.NoInstruction ipv -> Types.chainName1 }) -}
86cc83d13a5267976d269d3f766b53e3
  chainName1 :: GHC.Base.String
  {- Strictness: b -}
b74a79f7f223d4d90fb85353a46cfd8a
  criteria :: Types.GenRule crit -> [crit]
  RecSel Types.GenRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ crit ds :: Types.GenRule crit ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds1 }) -}
df9a0dee781d0940aa9fc67a16da01b9
  eitherToRule ::
    Data.Either.Either Types.FileCriteria Types.Target
    -> Types.FileRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Data.Either.Either Types.FileCriteria Types.Target ->
                 case ds of wild {
                   Data.Either.Left c
                   -> Types.Rule
                        @ Types.FileCriteria
                        (GHC.Types.:
                           @ Types.FileCriteria
                           c
                           (GHC.Types.[] @ Types.FileCriteria))
                        (GHC.Types.[] @ Types.Target)
                        Types.eitherToRule1
                   Data.Either.Right t
                   -> Types.Rule
                        @ Types.FileCriteria
                        (GHC.Types.[] @ Types.FileCriteria)
                        (GHC.Types.: @ Types.Target t (GHC.Types.[] @ Types.Target))
                        Types.eitherToRule1 }) -}
d5047859311ee035e97cb438f461adf1
  eitherToRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# (-1)) -}
f6cf230b9e31ca2f3452a2782b1c01fc
  exRule :: Types.Example -> Types.Rule
  RecSel Types.Example
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U,U,U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Example ->
                 case ds of wild { Types.Example ds1 ds2 -> ds1 }) -}
feb87806fdb6054e1c0f05d3d8a19500
  flagsToStrings :: Types.Criteria -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Criteria ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   Types.BoolFlag f
                   -> case Types.$slookup1
                             @ [GHC.Types.Char]
                             f
                             Types.flagsToStrings' of wild1 {
                        GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Base.String
                        GHC.Base.Just x -> x } }) -}
626a3cc914295e52f49ff5df282e5ad0
  flagsToStrings' :: Data.Map.Base.Map Types.Flag GHC.Base.String
  {- Unfolding: (Types.$sfromList
                   @ [GHC.Types.Char]
                   Types.flagsToStrings'1) -}
151825845c9dc695b20cb138bcafadec
  flagsToStrings'1 :: [(Types.Flag, GHC.Base.String)]
  {- Unfolding: (GHC.Types.:
                   @ (Types.Flag, GHC.Base.String)
                   Types.flagsToStrings'10
                   Types.flagsToStrings'2) -}
0b6ef93617d2ab1c9217648546a13ece
  flagsToStrings'10 :: (Types.Flag, [GHC.Types.Char])
  {- Unfolding: ((Types.SYN, Types.$fShowFlag5)) -}
df119d97dca274bbb444e0bc9c0e0f7e
  flagsToStrings'2 :: [(Types.Flag, GHC.Base.String)]
  {- Unfolding: (GHC.Types.:
                   @ (Types.Flag, GHC.Base.String)
                   Types.flagsToStrings'9
                   Types.flagsToStrings'3) -}
dcc49d33f152a84ed991ce7f0c02cce2
  flagsToStrings'3 :: [(Types.Flag, GHC.Base.String)]
  {- Unfolding: (GHC.Types.:
                   @ (Types.Flag, GHC.Base.String)
                   Types.flagsToStrings'8
                   Types.flagsToStrings'4) -}
80d37730a0b11330f1cc82dbee9217a6
  flagsToStrings'4 :: [(Types.Flag, GHC.Base.String)]
  {- Unfolding: (GHC.Types.:
                   @ (Types.Flag, GHC.Base.String)
                   Types.flagsToStrings'7
                   Types.flagsToStrings'5) -}
9f8fdf4c783aa25ce51f563997c9dfb9
  flagsToStrings'5 :: [(Types.Flag, GHC.Base.String)]
  {- Unfolding: (GHC.Types.:
                   @ (Types.Flag, GHC.Base.String)
                   Types.flagsToStrings'6
                   (GHC.Types.[] @ (Types.Flag, GHC.Base.String))) -}
0d5b1f8e8699806f50bafbf2b063bf61
  flagsToStrings'6 :: (Types.Flag, [GHC.Types.Char])
  {- Unfolding: ((Types.URG, Types.$fShowFlag1)) -}
04ed2c6bf39d900a3286e0d2f8edf249
  flagsToStrings'7 :: (Types.Flag, [GHC.Types.Char])
  {- Unfolding: ((Types.RST, Types.$fShowFlag2)) -}
4ba6d6e4a82e75c36a9d57002b2d8182
  flagsToStrings'8 :: (Types.Flag, [GHC.Types.Char])
  {- Unfolding: ((Types.FIN, Types.$fShowFlag3)) -}
8315aa7b41e5d57cf113e4647c48068e
  flagsToStrings'9 :: (Types.Flag, [GHC.Types.Char])
  {- Unfolding: ((Types.ACK, Types.$fShowFlag4)) -}
3a12accec2bba676c87960a5264f3df1
  ifNotRemoveNot :: Types.Criteria -> Types.Criteria
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
725e7647be6c577d6c99bb6dd004303f
  insRule :: Types.SynthInstruction r -> r
  RecSel Types.SynthInstruction
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ r ds :: Types.SynthInstruction r ->
                 case ds of wild {
                   Types.ToChainNamed ds1 ds2 -> ds2
                   Types.NoInstruction ds1 -> ds1 }) -}
fdbee042de6ad89db4d1b84222f17fcf
  ipAddr :: Data.IP.Range.IPRange -> Data.IP.Addr.IP
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Data.IP.Range.IPRange ->
                 case ds of wild {
                   Data.IP.Range.IPv4Range a
                   -> Data.IP.Addr.IPv4 (Data.IP.Range.addr @ Data.IP.Addr.IPv4 a)
                   Data.IP.Range.IPv6Range a
                   -> Data.IP.Addr.IPv6
                        (Data.IP.Range.addr @ Data.IP.Addr.IPv6 a) }) -}
612c59eb7075659d1f69c9ff4bc9cad3
  ipMask ::
    Data.IP.Range.IPRange
    -> Data.Either.Either GHC.Word.Word32 Data.LargeWord.Word128
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Data.IP.Range.IPRange ->
                 case ds of wild {
                   Data.IP.Range.IPv4Range a
                   -> Data.Either.Left
                        @ GHC.Word.Word32
                        @ Data.LargeWord.Word128
                        (case a of wild1 { Data.IP.Range.AddrRange ds1 ds2 dt ->
                         let {
                           x0 :: GHC.Prim.Int# = GHC.Prim.-# 32 dt
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># x0 31) of wild2 {
                           GHC.Types.False
                           -> case Types.$wgo2 x0 __word 0 of ww { DEFAULT ->
                              GHC.Word.W32# ww }
                           GHC.Types.True -> Types.ipMask3 } })
                   Data.IP.Range.IPv6Range a
                   -> Data.Either.Right
                        @ GHC.Word.Word32
                        @ Data.LargeWord.Word128
                        (case a of wild1 { Data.IP.Range.AddrRange ds1 ds2 dt ->
                         let {
                           x0 :: GHC.Prim.Int# = GHC.Prim.-# 128 dt
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># x0 127) of wild2 {
                           GHC.Types.False
                           -> case Types.ipMask1 of ww { Data.LargeWord.LargeKey ww1 ww2 ->
                              case Types.$wgo1 x0 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                              Data.LargeWord.LargeKey
                                @ GHC.Word.Word64
                                @ GHC.Word.Word64
                                ww4
                                ww5 } }
                           GHC.Types.True -> Types.ipMask1 } }) }) -}
73f110f4850f78dea095068bb05d34bf
  ipMask1 :: Data.LargeWord.LargeKey GHC.Word.Word64 GHC.Word.Word64
  {- Unfolding: (case Data.LargeWord.$w$cintegerToLargeWord
                        @ GHC.Word.Word64
                        @ GHC.Word.Word64
                        GHC.Word.$fFiniteBitsWord64
                        Data.LargeWord.$fLargeWordWord64
                        Data.LargeWord.$fLargeWordWord64
                        Types.ipMask2 of ww { (#,#) ww1 ww2 ->
                 Data.LargeWord.LargeKey
                   @ GHC.Word.Word64
                   @ GHC.Word.Word64
                   ww1
                   ww2 }) -}
73a2bbc195fee8790995f5dabc0336dd
  ipMask2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
06fde5da93da834a557657407fabf3e7
  ipMask3 :: GHC.Word.Word32
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Word.W32# __word 0) -}
6bc11b980f10dee2e61d9b0b9569787e
  ipToWord ::
    Data.IP.Addr.IP
    -> Data.Either.Either GHC.Word.Word32 Data.LargeWord.Word128
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Data.IP.Addr.IP ->
                 case ds of wild {
                   Data.IP.Addr.IPv4 i
                   -> Data.Either.Left
                        @ GHC.Word.Word32
                        @ Data.LargeWord.Word128
                        (case Types.$wgo4
                                (Data.IP.Addr.fromIPv4 i)
                                __word 0 of ww { DEFAULT ->
                         GHC.Word.W32# ww })
                   Data.IP.Addr.IPv6 i
                   -> Data.Either.Right
                        @ GHC.Word.Word32
                        @ Data.LargeWord.Word128
                        (case Types.ipMask1 of ww { Data.LargeWord.LargeKey ww1 ww2 ->
                         case Types.$wgo3
                                (Data.IP.Addr.fromIPv6 i)
                                ww1
                                ww2 of ww3 { (#,#) ww4 ww5 ->
                         Data.LargeWord.LargeKey
                           @ GHC.Word.Word64
                           @ GHC.Word.Word64
                           ww4
                           ww5 } }) }) -}
c76e5bacc864bc47a7c3293b36d3b943
  isNot :: Types.Criteria -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Criteria ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False Types.Not ds1 -> GHC.Types.True }) -}
0341d7159f08cb2301ad0191a82f607e
  isStateful :: Types.Criteria -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Types.Criteria ->
                 case Types.isStateless x of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a7dafc21e31af611e8dd8a5e9f8ffe90
  isStateless :: Types.Criteria -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U> -}
f7075d026a31f1475fa9bcc64ff2fcf1
  label :: Types.GenRule crit -> Types.Label
  RecSel Types.GenRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ crit ds :: Types.GenRule crit ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds3 }) -}
f212cf20f9f1fb7cbe1c6fba554e082c
  state :: Types.Example -> [Types.State]
  RecSel Types.Example
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Types.Example ->
                 case ds of wild { Types.Example ds1 ds2 -> ds2 }) -}
574be1a19f736a3b96198282cabeefad
  stringsToFlags :: Data.Map.Base.Map GHC.Base.String Types.Criteria
  {- Unfolding: (Types.$sfromList1
                   @ Types.Criteria
                   Types.stringsToFlags1) -}
8c881ec3f664c8770193a1b01a48de1a
  stringsToFlags1 :: [(GHC.Base.String, Types.Criteria)]
  {- Unfolding: (GHC.Types.:
                   @ (GHC.Base.String, Types.Criteria)
                   Types.stringsToFlags14
                   Types.stringsToFlags2) -}
8ad61f61af839e1dbd4931e6d54532a9
  stringsToFlags10 :: ([GHC.Types.Char], Types.Criteria)
  {- Unfolding: ((Types.$fShowFlag3, Types.stringsToFlags11)) -}
4fd3bd5d98691baa7f726c221a7d7699
  stringsToFlags11 :: Types.Criteria
  {- HasNoCafRefs, Unfolding: (Types.BoolFlag Types.FIN) -}
a1330445e5042ac33e0f1badfc10cc4a
  stringsToFlags12 :: ([GHC.Types.Char], Types.Criteria)
  {- Unfolding: ((Types.$fShowFlag4, Types.stringsToFlags13)) -}
53d87cd1124cf8eeeda0bd4be328ac60
  stringsToFlags13 :: Types.Criteria
  {- HasNoCafRefs, Unfolding: (Types.BoolFlag Types.ACK) -}
121c44f51ce39792332ebee45919ecba
  stringsToFlags14 :: ([GHC.Types.Char], Types.Criteria)
  {- Unfolding: ((Types.$fShowFlag5, Types.stringsToFlags15)) -}
4844f4b423b72894d5cb308f62ca4d28
  stringsToFlags15 :: Types.Criteria
  {- HasNoCafRefs, Unfolding: (Types.BoolFlag Types.SYN) -}
b351e662cd208138a7c44c0429bee0a4
  stringsToFlags2 :: [(GHC.Base.String, Types.Criteria)]
  {- Unfolding: (GHC.Types.:
                   @ (GHC.Base.String, Types.Criteria)
                   Types.stringsToFlags12
                   Types.stringsToFlags3) -}
4e36b0f22f4ec37e3cc84284af5f73e9
  stringsToFlags3 :: [(GHC.Base.String, Types.Criteria)]
  {- Unfolding: (GHC.Types.:
                   @ (GHC.Base.String, Types.Criteria)
                   Types.stringsToFlags10
                   Types.stringsToFlags4) -}
120c4b0bcc0f5321295adef04854d568
  stringsToFlags4 :: [(GHC.Base.String, Types.Criteria)]
  {- Unfolding: (GHC.Types.:
                   @ (GHC.Base.String, Types.Criteria)
                   Types.stringsToFlags8
                   Types.stringsToFlags5) -}
f4a70d5f6f9299f4c49f95acbd9c5b89
  stringsToFlags5 :: [(GHC.Base.String, Types.Criteria)]
  {- Unfolding: (GHC.Types.:
                   @ (GHC.Base.String, Types.Criteria)
                   Types.stringsToFlags6
                   (GHC.Types.[] @ (GHC.Base.String, Types.Criteria))) -}
a5fde935749cf8cbceea75a8890b23d1
  stringsToFlags6 :: ([GHC.Types.Char], Types.Criteria)
  {- Unfolding: ((Types.$fShowFlag1, Types.stringsToFlags7)) -}
f9232aa856e745334545d3700e632e61
  stringsToFlags7 :: Types.Criteria
  {- HasNoCafRefs, Unfolding: (Types.BoolFlag Types.URG) -}
93594292160acc3795d89d541bcfe4a9
  stringsToFlags8 :: ([GHC.Types.Char], Types.Criteria)
  {- Unfolding: ((Types.$fShowFlag2, Types.stringsToFlags9)) -}
cce5905a4df79b52408cdb0077d334cb
  stringsToFlags9 :: Types.Criteria
  {- HasNoCafRefs, Unfolding: (Types.BoolFlag Types.RST) -}
f70e06da4eb5a74e71183801cbf417b6
  targets :: Types.GenRule crit -> [Types.Target]
  RecSel Types.GenRule
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ crit ds :: Types.GenRule crit ->
                 case ds of wild { Types.Rule ds1 ds2 ds3 -> ds2 }) -}
bf82e278c105ca2541e1755d8ad2f90e
  targetsToChainIds :: [Types.Target] -> [Types.ChainId]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ad27115d47e70cf4bf18c6f6002efb91
  toIPRange :: GHC.Base.String -> Data.IP.Range.IPRange
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: GHC.Base.String ->
                 case GHC.List.elem
                        @ GHC.Types.Char
                        GHC.Classes.$fEqChar
                        Types.toIPRange8
                        s of wild {
                   GHC.Types.False
                   -> case Text.Read.readEither6
                             @ Data.IP.Range.IPRange
                             (Text.ParserCombinators.ReadP.run
                                @ Data.IP.Range.IPRange
                                Types.toIPRange6
                                (GHC.Base.++ @ GHC.Types.Char s Types.toIPRange5)) of wild1 {
                        [] -> Types.toIPRange4
                        : x ds
                        -> case ds of wild2 { [] -> x : ipv ipv1 -> Types.toIPRange3 } }
                   GHC.Types.True
                   -> case Text.Read.readEither6
                             @ Data.IP.Range.IPRange
                             (Text.ParserCombinators.ReadP.run
                                @ Data.IP.Range.IPRange
                                Types.toIPRange1
                                s) of wild1 {
                        [] -> Types.toIPRange4
                        : x ds
                        -> case ds of wild2 {
                             [] -> x : ipv ipv1 -> Types.toIPRange3 } } }) -}
bbbd6686284369e159a7fe30a9a68d0e
  toIPRange1 :: Text.ParserCombinators.ReadP.P Data.IP.Range.IPRange
  {- Unfolding: (Text.ParserCombinators.ReadP.Look
                   @ Data.IP.Range.IPRange
                   Types.toIPRange2) -}
c229131da735b243a5f13ccb5d3fde85
  toIPRange2 ::
    GHC.Base.String
    -> Text.ParserCombinators.ReadP.P Data.IP.Range.IPRange
  {- Arity: 1,
     Unfolding: (\ s :: GHC.Base.String ->
                 case Types.toIPRange_go (Data.IP.Range.parseIPRange s) of wild {
                   [] -> Text.ParserCombinators.ReadP.Fail @ Data.IP.Range.IPRange
                   : ipv ipv1
                   -> Text.ParserCombinators.ReadP.Final
                        @ Data.IP.Range.IPRange
                        wild }) -}
70fbb829cf26ce769061e8004134a639
  toIPRange3 :: Data.IP.Range.IPRange
  {- Strictness: b -}
b86f93a482fc69bd1cc7d46e1a83a965
  toIPRange4 :: Data.IP.Range.IPRange
  {- Strictness: b -}
2112a1049cebf55f4349d82cfdfdcb31
  toIPRange5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "/32"#) -}
e72a52e1f8927fa8bbeff8417a18a4e8
  toIPRange6 :: Text.ParserCombinators.ReadP.P Data.IP.Range.IPRange
  {- Unfolding: (Text.ParserCombinators.ReadP.Look
                   @ Data.IP.Range.IPRange
                   Types.toIPRange7) -}
ed2176930778f3723134a4ffdf6e204b
  toIPRange7 ::
    GHC.Base.String
    -> Text.ParserCombinators.ReadP.P Data.IP.Range.IPRange
  {- Arity: 1,
     Unfolding: (\ s :: GHC.Base.String ->
                 case Types.toIPRange_go1 (Data.IP.Range.parseIPRange s) of wild {
                   [] -> Text.ParserCombinators.ReadP.Fail @ Data.IP.Range.IPRange
                   : ipv ipv1
                   -> Text.ParserCombinators.ReadP.Final
                        @ Data.IP.Range.IPRange
                        wild }) -}
f0cbd00d4a9168be09de2073d4e052e5
  toIPRange8 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '/') -}
aa9c101fc71ec538ea409dafcc3d3b82
  toIPRange_go ::
    [(Data.IP.Range.IPRange, GHC.Base.String)]
    -> [(Data.IP.Range.IPRange, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
cabc810d0f6291f640866a93ae8cd03f
  toIPRange_go1 ::
    [(Data.IP.Range.IPRange, GHC.Base.String)]
    -> [(Data.IP.Range.IPRange, GHC.Base.String)]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
instance GHC.Classes.Eq [Types.Criteria] = Types.$fEqCriteria
instance GHC.Classes.Eq [Types.Endpoint] = Types.$fEqEndpoint
instance GHC.Classes.Eq [Types.Example] = Types.$fEqExample
instance GHC.Classes.Eq [Types.FileInput] = Types.$fEqFileInput
instance GHC.Classes.Eq [Types.Flag] = Types.$fEqFlag
instance GHC.Classes.Eq [Types.GenRule] = Types.$fEqGenRule
instance GHC.Classes.Eq [Types.InputCriteria]
  = Types.$fEqInputCriteria
instance GHC.Classes.Eq [Types.State] = Types.$fEqState
instance GHC.Classes.Eq [Types.SynthInstruction]
  = Types.$fEqSynthInstruction
instance GHC.Classes.Eq [Types.Target] = Types.$fEqTarget
instance GHC.Base.Monoid [Types.GenRule] = Types.$fMonoidGenRule
instance GHC.Base.Monoid [Types.GenRule] = Types.$fMonoidGenRule0
instance GHC.Classes.Ord [Types.Flag] = Types.$fOrdFlag
instance GHC.Show.Show [Types.Criteria] = Types.$fShowCriteria
instance GHC.Show.Show [Types.Endpoint] = Types.$fShowEndpoint
instance GHC.Show.Show [Types.Example] = Types.$fShowExample
instance GHC.Show.Show [Types.FileInput] = Types.$fShowFileInput
instance GHC.Show.Show [Types.Flag] = Types.$fShowFlag
instance GHC.Show.Show [Types.GenRule] = Types.$fShowGenRule
instance GHC.Show.Show [Types.InputCriteria]
  = Types.$fShowInputCriteria
instance GHC.Show.Show [Types.State] = Types.$fShowState
instance GHC.Show.Show [Types.SynthInstruction]
  = Types.$fShowSynthInstruction
instance GHC.Show.Show [Types.Target] = Types.$fShowTarget
instance Data.String.ToString.ToString [GHC.Types.Char]
  = Types.$fToStringChar
instance Data.String.ToString.ToString [GHC.Types.Int]
  = Types.$fToStringInt
"SPEC/Types $fShow(,) @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                               GHC.Types.Int
                                                   $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,) @ GHC.Types.Int @ GHC.Types.Int $dShow $dShow1
  = Types.$s$fShow(,)
"SPEC/Types $fShow(,)_$cshow @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                      GHC.Types.Int
                                                          $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshow @ GHC.Types.Int
                            @ GHC.Types.Int
                            $dShow
                            $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshow
"SPEC/Types $fShow(,)_$cshowList @ Int @ Int" [ALWAYS] forall $dShow :: GHC.Show.Show
                                                                          GHC.Types.Int
                                                              $dShow1 :: GHC.Show.Show GHC.Types.Int
  GHC.Show.$fShow(,)_$cshowList @ GHC.Types.Int
                                @ GHC.Types.Int
                                $dShow
                                $dShow1
  = Types.$s$fShow(,)_$s$fShow(,)_$cshowList
"SPEC/Types fromList @ Flag _" [ALWAYS] forall @ a
                                               $dOrd :: GHC.Classes.Ord Types.Flag
  Data.Map.Base.fromList @ Types.Flag @ a $dOrd
  = Types.$sfromList @ a
"SPEC/Types fromList @ String _" [ALWAYS] forall @ a
                                                 $dOrd :: GHC.Classes.Ord GHC.Base.String
  Data.Map.Base.fromList @ [GHC.Types.Char] @ a $dOrd
  = Types.$sfromList1 @ a
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

