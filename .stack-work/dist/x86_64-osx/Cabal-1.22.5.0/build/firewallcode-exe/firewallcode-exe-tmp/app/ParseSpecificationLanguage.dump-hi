
==================== FINAL INTERFACE ====================
2016-08-06 05:37:26.734562 UTC

interface main@main:ParseSpecificationLanguage 7103
  interface hash: b6d398f54c6e0399c49df08e72cdd0c5
  ABI hash: 1afaff56f226ec283fea1aba7b7e9cfc
  export-list hash: 97b3a15dfab8f73d45ff5f6798ca2b79
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParseSpecificationLanguage.conjunctionAtFront
  ParseSpecificationLanguage.findAfterLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis'
  ParseSpecificationLanguage.isConjunction
  ParseSpecificationLanguage.lexer
  ParseSpecificationLanguage.parse
  ParseSpecificationLanguage.parseInstruction
  ParseSpecificationLanguage.parseRule
  ParseSpecificationLanguage.parseSpecificationCriteria
  ParseSpecificationLanguage.parseSpecificationCriteria'
  ParseSpecificationLanguage.parseSpecificationTarget
  ParseSpecificationLanguage.toConjunction
module dependencies: ParserHelp Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Unicode cdf84fc3abbaf34ba6b6645291cef991
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ParserHelp c7affdab4be2cddd08133e07d05d3b63
  exports: 4408f0f73d248a4701f2f315f854c188
  isInteger cc10131991668b1b7abaf3e084cfc260
import  -/  Types 07deaa85949e0404125659b7da182fb1
  exports: 308a8e9ef15b1d0368eef76fcb360a92
  ACCEPT a0e8bfb182327208223f4101204d01d3
  And 8afdac4ea0cf3b806d2949674630f53e
  DROP 030c92a184ce42e939e5fbc310e578ea
  Destination 922d80ba258cc0a086584d38ca75ebef
  InC b3987076ee8049ca72efdfca87e93bc5
  InCNot 70b651bc9f4bbd6d1338f64e0f05b4b9
  InputCriteria b903a15d973ba0103b2f1204aea183b5
  InputInstruction 742102be34dfed881af0ccc1ec2c73bd
  InputRule b903a15d973ba0103b2f1204aea183b5
  NoInstruction ce8140d8381d1bdf0643cc19c1dfff82
  Or 22d779d7e8a99d2b47a64b386e4698bb
  Port 7fac22dbdd5e01d480bf117c22f09521
  Protocol fe7579db3bf10f763094c06a95c77cb8
  Rule 8d9cf447e21b08fbe9de4980b6719bce
  SC cbdfae05d7e403e2dd5726187922bc4a
  Source b53eb4518fedc84d30c0b4327bd32c7d
  Target 96fab3e40e346c4a445f4966317f4361
  ToChainNamed 9b01eacb4b32e9bb84585005ccde771b
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split.Internals ec8cf5264ec78ab060cadb7ee5b994f0
a7729a09bb6f2d728d5707169b0b78c2
  $wparseRule ::
    [GHC.Base.String] -> (# [Types.InputCriteria], [Types.Target] #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 let {
                   ds :: ([[GHC.Types.Char]], [[GHC.Types.Char]])
                   = case GHC.List.$wbreak
                            @ [GHC.Types.Char]
                            ParseSpecificationLanguage.parseRule1
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (# case ds of wild { (,) c t ->
                    ParseSpecificationLanguage.parseSpecificationCriteria c },
                    case ds of wild { (,) c t ->
                    case t of wild1 {
                      [] -> GHC.Types.[] @ Types.Target
                      : ds1 ds2
                      -> ParseSpecificationLanguage.parseSpecificationTarget
                           ds2 } } #)) -}
922178a442b8d5aacd3834770adfcf00
  $wparseSpecificationCriteria' ::
    [GHC.Base.String] -> (# Types.InputCriteria, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
d301796655861c02a95511b817cccc5f
  $wparseSpecificationTarget ::
    [GHC.Base.String] -> (# Types.Target, [Types.Target] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> case ParseSpecificationLanguage.parseSpecificationTarget3
                      ret_ty (# Types.Target, [Types.Target] #)
                      of {}
                   : ds ds1
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.parseSpecificationTarget2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString
                                  ds
                                  ParseSpecificationLanguage.parseSpecificationTarget1 of wild2 {
                             GHC.Types.False
                             -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                ret_ty (# Types.Target, [Types.Target] #)
                                of {}
                             GHC.Types.True
                             -> case ds1 of wild3 {
                                  [] -> (# Types.DROP, GHC.Types.[] @ Types.Target #)
                                  : ipv ipv1
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } }
                        GHC.Types.True
                        -> case ds1 of wild2 {
                             [] -> (# Types.ACCEPT, GHC.Types.[] @ Types.Target #)
                             : ipv ipv1
                             -> case GHC.Base.eqString
                                       ds
                                       ParseSpecificationLanguage.parseSpecificationTarget1 of wild3 {
                                  GHC.Types.False
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {}
                                  GHC.Types.True
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } } } }) -}
1d067a16bba19928ef9d851108547edd
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
67d1dab5e45c008d6a3229093b7e7233
  conjunctionAtFront ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [GHC.Base.String] ->
                 case ds of wild {
                   []
                   -> GHC.Base.Nothing
                        @ ([Types.InputCriteria] -> Types.InputCriteria)
                   : ipv ipv1
                   -> case GHC.List.elem
                             @ GHC.Base.String
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ipv
                             ParseSpecificationLanguage.conjunctionAtFront2 of wild1 {
                        GHC.Types.False
                        -> ParseSpecificationLanguage.conjunctionAtFront1 wild
                        GHC.Types.True
                        -> ParseSpecificationLanguage.toConjunction ipv } }) -}
d1975d36a06d9cc7652c97aa85626267
  conjunctionAtFront1 ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <L,U>b -}
0527e616fe505f0e7e5090bb12d14955
  conjunctionAtFront2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction4
                   ParseSpecificationLanguage.conjunctionAtFront3) -}
6befb3cd238bc817cb5ed4ea04efd41e
  conjunctionAtFront3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
80262df2b8a7dd83f4893064da4ceae4
  findAfterLeadingParenthesis ::
    [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Base.String] ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        (ParseSpecificationLanguage.findInLeadingParenthesis s)
                        0 of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# 2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> ParseSpecificationLanguage.$wunsafeDrop @ GHC.Base.String x s
                   GHC.Types.True -> s } }) -}
958928b657f5fd8ba6ad4f3ba7b833f9
  findInLeadingParenthesis :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [GHC.Base.String] ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds1 xs
                   -> case ds1 of wild1 {
                        [] -> wild
                        : ds2 ds3
                        -> case ds2 of wild2 { GHC.Types.C# ds4 ->
                           case ds4 of ds5 {
                             DEFAULT -> wild
                             '('
                             -> case ds3 of wild3 {
                                  []
                                  -> ParseSpecificationLanguage.findInLeadingParenthesis'
                                       xs
                                       ParseSpecificationLanguage.findInLeadingParenthesis1
                                  : ipv ipv1 -> wild } } } } }) -}
ceb78809f0f26de26b2c1c90fdf4f3d4
  findInLeadingParenthesis' ::
    [GHC.Base.String] -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
b4bafc8d32969d530810c80050a7b061
  findInLeadingParenthesis1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
f36dcc62cf478c86855b3b8802eeb668
  isConjunction :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   s
                   ParseSpecificationLanguage.conjunctionAtFront2) -}
77c583e36e586e5038c1f8ebe9f4eeb6
  lexer :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
559e89d27186ce235fecd32be44bdad6
  parse :: [GHC.Base.String] -> [Types.InputInstruction]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: [GHC.Base.String] ->
                 GHC.Base.build
                   @ (Types.SynthInstruction Types.InputRule)
                   (\ @ b1
                      c :: Types.SynthInstruction Types.InputRule -> b1 -> b1[OneShot]
                      n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ (Types.SynthInstruction Types.InputRule)
                         @ b1
                         @ [GHC.Base.String]
                         c
                         ParseSpecificationLanguage.parse3)
                      n2
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Base.String
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         ParseSpecificationLanguage.parse1
                         s))) -}
58b324383b26a2c39973a350073b7c40
  parse1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.parse2
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c4898de41ab3d8d4b34ee3e497f85e
  parse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
0a78c5a0458c5a58a67593a337f6b362
  parse3 ::
    [GHC.Base.String] -> Types.SynthInstruction Types.InputRule
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: [GHC.Base.String] ->
                 case x of wild {
                   [] -> ParseSpecificationLanguage.parse5
                   : ds ds1
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.parse4 of wild1 {
                        GHC.Types.False
                        -> Types.NoInstruction
                             @ Types.InputRule
                             (case ParseSpecificationLanguage.$wparseRule
                                     wild of ww { (#,#) ww1 ww2 ->
                              Types.Rule @ Types.InputCriteria ww1 ww2 })
                        GHC.Types.True
                        -> case ds1 of wild2 {
                             []
                             -> Types.NoInstruction
                                  @ Types.InputRule
                                  (case ParseSpecificationLanguage.$wparseRule
                                          wild of ww { (#,#) ww1 ww2 ->
                                   Types.Rule @ Types.InputCriteria ww1 ww2 })
                             : c ds2
                             -> case ds2 of wild3 {
                                  []
                                  -> Types.NoInstruction
                                       @ Types.InputRule
                                       (case ParseSpecificationLanguage.$wparseRule
                                               wild of ww { (#,#) ww1 ww2 ->
                                        Types.Rule @ Types.InputCriteria ww1 ww2 })
                                  : ds3 xs
                                  -> case ds3 of wild4 {
                                       []
                                       -> Types.NoInstruction
                                            @ Types.InputRule
                                            (case ParseSpecificationLanguage.$wparseRule
                                                    wild of ww { (#,#) ww1 ww2 ->
                                             Types.Rule @ Types.InputCriteria ww1 ww2 })
                                       : ds4 ds5
                                       -> case ds4 of wild5 { GHC.Types.C# ds6 ->
                                          case ds6 of ds7 {
                                            DEFAULT
                                            -> Types.NoInstruction
                                                 @ Types.InputRule
                                                 (case ParseSpecificationLanguage.$wparseRule
                                                         wild of ww { (#,#) ww1 ww2 ->
                                                  Types.Rule @ Types.InputCriteria ww1 ww2 })
                                            ':'
                                            -> case ds5 of wild6 {
                                                 []
                                                 -> Types.ToChainNamed
                                                      @ Types.InputRule
                                                      c
                                                      (ParseSpecificationLanguage.parseRule xs)
                                                 : ipv ipv1
                                                 -> Types.NoInstruction
                                                      @ Types.InputRule
                                                      (case ParseSpecificationLanguage.$wparseRule
                                                              wild of ww { (#,#) ww1 ww2 ->
                                                       Types.Rule
                                                         @ Types.InputCriteria
                                                         ww1
                                                         ww2 }) } } } } } } } }) -}
3d31f5ae555e1bef9519a34be4da0816
  parse4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chain"#) -}
4319466fd350a798474bb03e3585511a
  parse5 :: Types.SynthInstruction Types.InputRule
  {- Unfolding: (Types.NoInstruction
                   @ Types.InputRule
                   ParseSpecificationLanguage.parse6) -}
241a4e2db98d6e749bba54dfaf4fa6d4
  parse6 :: Types.InputRule
  {- Unfolding: (case ParseSpecificationLanguage.$wparseRule
                        (GHC.Types.[] @ GHC.Base.String) of ww { (#,#) ww1 ww2 ->
                 Types.Rule @ Types.InputCriteria ww1 ww2 }) -}
e08a5a18d754516d58489caab36ebe90
  parseInstruction ::
    [GHC.Base.String]
    -> ([GHC.Base.String], Types.InputRule -> Types.InputInstruction)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> (GHC.Types.[] @ GHC.Base.String,
                       Types.NoInstruction @ Types.InputRule)
                   : ds ds1
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.parse4 of wild1 {
                        GHC.Types.False -> (wild, Types.NoInstruction @ Types.InputRule)
                        GHC.Types.True
                        -> case ds1 of wild2 {
                             [] -> (wild, Types.NoInstruction @ Types.InputRule)
                             : c ds2
                             -> case ds2 of wild3 {
                                  [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                  : ds3 xs
                                  -> case ds3 of wild4 {
                                       [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                       : ds4 ds5
                                       -> case ds4 of wild5 { GHC.Types.C# ds6 ->
                                          case ds6 of ds7 {
                                            DEFAULT -> (wild, Types.NoInstruction @ Types.InputRule)
                                            ':'
                                            -> case ds5 of wild6 {
                                                 [] -> (xs, Types.ToChainNamed @ Types.InputRule c)
                                                 : ipv ipv1
                                                 -> (wild,
                                                     Types.NoInstruction
                                                       @ Types.InputRule) } } } } } } } }) -}
6871bc263a66a2d2bf48270d75a27690
  parseRule :: [GHC.Base.String] -> Types.InputRule
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseRule
                        w of ww { (#,#) ww1 ww2 ->
                 Types.Rule @ Types.InputCriteria ww1 ww2 }) -}
b256f34ce26b465d8782f95fb8d6ec61
  parseRule1 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (GHC.Base.eqString
                   ParseSpecificationLanguage.parseRule2) -}
6027a873224657de753abea80999bf24
  parseRule2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=>"#) -}
5fed0221105d39fe024b6b25c69cf25d
  parseSpecificationCriteria ::
    [GHC.Base.String] -> [Types.InputCriteria]
  {- Arity: 1, Strictness: <S,1*U> -}
ff41449b89da1e6b1f571ceb6aa506bb
  parseSpecificationCriteria' ::
    [GHC.Base.String] -> (Types.InputCriteria, [GHC.Base.String])
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationCriteria'
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
def321a540af9a208c72596ba7c496ef
  parseSpecificationTarget :: [GHC.Base.String] -> [Types.Target]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationTarget
                        w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.Target ww1 ww2 }) -}
62df66a2d2ef0c5b358cb09be796dd0d
  parseSpecificationTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
14dfb52ab0a9d18677968e9cc9ff000f
  parseSpecificationTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
048f964a0b52daf32099aab96605153c
  parseSpecificationTarget3 :: [Types.Target]
  {- Strictness: b -}
33896c556c4a64db28c979bfe622b6ac
  toConjunction ::
    GHC.Base.String
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ ds :: [GHC.Types.Char] ->
                 case GHC.Base.eqString
                        ds
                        ParseSpecificationLanguage.toConjunction4 of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.toConjunction3 of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ ([Types.InputCriteria] -> Types.InputCriteria)
                        GHC.Types.True -> ParseSpecificationLanguage.toConjunction2 }
                   GHC.Types.True -> ParseSpecificationLanguage.toConjunction1 }) -}
25f81f5b3f3eb70a7881bade2a9bd102
  toConjunction1 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.And) -}
5a1cd7f482de8c9868f1295a7001435c
  toConjunction2 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.Or) -}
32411603950933f2263a8a8ea34cdb04
  toConjunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OR"#) -}
25d50274f34a8034738a2d09fa7b7918
  toConjunction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AND"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

