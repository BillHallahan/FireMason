
==================== FINAL INTERFACE ====================
2016-08-12 06:30:50.405036 UTC

interface main@main:ParseSpecificationLanguage 7103
  interface hash: ba406732c6957c16343e8a6cff6f57f6
  ABI hash: 17e773777cd1975f0e40667b8c1bf881
  export-list hash: 97b3a15dfab8f73d45ff5f6798ca2b79
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParseSpecificationLanguage.conjunctionAtFront
  ParseSpecificationLanguage.findAfterLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis'
  ParseSpecificationLanguage.isConjunction
  ParseSpecificationLanguage.lexer
  ParseSpecificationLanguage.parse
  ParseSpecificationLanguage.parseInstruction
  ParseSpecificationLanguage.parseRule
  ParseSpecificationLanguage.parseSpecificationCriteria
  ParseSpecificationLanguage.parseSpecificationCriteria'
  ParseSpecificationLanguage.parseSpecificationTarget
  ParseSpecificationLanguage.toConjunction
module dependencies: ParserHelp Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Unicode cdf84fc3abbaf34ba6b6645291cef991
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base c921f79770a215e3f4c72c747cb6a28a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ParserHelp c7affdab4be2cddd08133e07d05d3b63
  exports: 4408f0f73d248a4701f2f315f854c188
  isInteger cc10131991668b1b7abaf3e084cfc260
import  -/  Types 6431681dc34ef43a214b91e643fcdb3f
  exports: c34153ed7d511df2e0480a8ee9e21474
  ACCEPT a0e8bfb182327208223f4101204d01d3
  And 4073486fc2b2dc4fde9f66dd09188def
  DROP 030c92a184ce42e939e5fbc310e578ea
  Destination 922d80ba258cc0a086584d38ca75ebef
  InC e8435baf0c10d62acf1ff9d35ad4c6de
  InCNot 886dc7f5a8dd4563d3f11675bf619db0
  InputCriteria ee544870784f76612208ff970967bdd1
  InputInstruction 7da4d53d977e868e08e7c777e47cb171
  InputRule ee544870784f76612208ff970967bdd1
  NoInstruction b969e22921f283e869a0720ab3777dec
  Or 2827dba042335b659dd538c55f73dd89
  Port 0cdcd795ebd2c331c1401f6cf3404c99
  Protocol d38fdc887d9a0e7c53d19d8b463500f3
  Rule b5742fecd8c62d0db5b3ac3928e2c24a
  SC f35e0e42ed4e3547fc06c148eeae6c66
  Source b53eb4518fedc84d30c0b4327bd32c7d
  Target 96fab3e40e346c4a445f4966317f4361
  ToChainNamed ce4c7bf5b328004ab15754446244f326
  stringsToFlags 1b67ff14d71794063a3d844602d37d18
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split.Internals ec8cf5264ec78ab060cadb7ee5b994f0
d600ab7acfa7e844b6d4a81e4b2c2483
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
4cd3a793d6c6666f4743994dda6dd56a
  $wparseSpecificationCriteria' ::
    [GHC.Base.String] -> (# Types.InputCriteria, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
ed7a173cab1bb10bd86703c768aa35ff
  $wparseSpecificationTarget ::
    [GHC.Base.String] -> (# Types.Target, [Types.Target] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> case ParseSpecificationLanguage.parseSpecificationTarget3
                      ret_ty (# Types.Target, [Types.Target] #)
                      of {}
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseSpecificationTarget2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString
                                  ds1
                                  ParseSpecificationLanguage.parseSpecificationTarget1 of wild2 {
                             GHC.Types.False
                             -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                ret_ty (# Types.Target, [Types.Target] #)
                                of {}
                             GHC.Types.True
                             -> case ds2 of wild3 {
                                  [] -> (# Types.DROP, GHC.Types.[] @ Types.Target #)
                                  : ipv ipv1
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } }
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (# Types.ACCEPT, GHC.Types.[] @ Types.Target #)
                             : ipv ipv1
                             -> case GHC.Base.eqString
                                       ds1
                                       ParseSpecificationLanguage.parseSpecificationTarget1 of wild3 {
                                  GHC.Types.False
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {}
                                  GHC.Types.True
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } } } }) -}
1d067a16bba19928ef9d851108547edd
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
c967fb08506d82b96712dbecae8cee30
  conjunctionAtFront ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   []
                   -> GHC.Base.Nothing
                        @ ([Types.InputCriteria] -> Types.InputCriteria)
                   : ipv ipv1
                   -> case GHC.List.elem
                             @ GHC.Base.String
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ipv
                             ParseSpecificationLanguage.conjunctionAtFront2 of wild1 {
                        GHC.Types.False
                        -> ParseSpecificationLanguage.conjunctionAtFront1 wild
                        GHC.Types.True
                        -> ParseSpecificationLanguage.toConjunction ipv } }) -}
bb0d1d5055e481e5c1640d6aa605b199
  conjunctionAtFront1 ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <L,U>b -}
0527e616fe505f0e7e5090bb12d14955
  conjunctionAtFront2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction4
                   ParseSpecificationLanguage.conjunctionAtFront3) -}
6befb3cd238bc817cb5ed4ea04efd41e
  conjunctionAtFront3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
4d7761683ba7c466d784334245bc7025
  findAfterLeadingParenthesis ::
    [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Base.String] ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        (ParseSpecificationLanguage.findInLeadingParenthesis s)
                        0 of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# 2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> ParseSpecificationLanguage.$wunsafeDrop @ GHC.Base.String x s
                   GHC.Types.True -> s } }) -}
d0b74c6656242cb7c2ad3fe0ed1c40ae
  findInLeadingParenthesis :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds2 xs
                   -> case ds2 of wild1 {
                        [] -> wild
                        : ds3 ds4
                        -> case ds3 of wild2 { GHC.Types.C# ds5 ->
                           case ds5 of ds6 {
                             DEFAULT -> wild
                             '('
                             -> case ds4 of wild3 {
                                  []
                                  -> ParseSpecificationLanguage.findInLeadingParenthesis'
                                       xs
                                       ParseSpecificationLanguage.findInLeadingParenthesis1
                                  : ipv ipv1 -> wild } } } } }) -}
ceb78809f0f26de26b2c1c90fdf4f3d4
  findInLeadingParenthesis' ::
    [GHC.Base.String] -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
b4bafc8d32969d530810c80050a7b061
  findInLeadingParenthesis1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
f36dcc62cf478c86855b3b8802eeb668
  isConjunction :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   s
                   ParseSpecificationLanguage.conjunctionAtFront2) -}
77c583e36e586e5038c1f8ebe9f4eeb6
  lexer :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
49dfc062f2fc45fc120d3bef3cd05553
  parse :: [GHC.Base.String] -> [Types.InputInstruction]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: [GHC.Base.String] ->
                 GHC.Base.build
                   @ (Types.SynthInstruction Types.InputRule)
                   (\ @ b1
                      c :: Types.SynthInstruction Types.InputRule -> b1 -> b1[OneShot]
                      n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ (Types.SynthInstruction Types.InputRule)
                         @ b1
                         @ [GHC.Base.String]
                         c
                         ParseSpecificationLanguage.parse3)
                      n2
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Base.String
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         ParseSpecificationLanguage.parse1
                         s))) -}
58b324383b26a2c39973a350073b7c40
  parse1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.parse2
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c4898de41ab3d8d4b34ee3e497f85e
  parse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
e3a8ee66408e154b1bdcfc8b12825759
  parse3 ::
    [GHC.Base.String] -> Types.SynthInstruction Types.InputRule
  {- Arity: 1, Strictness: <S,1*U> -}
6768a74a5d927b92d8258bb261596489
  parseInstruction ::
    [GHC.Base.String]
    -> ([GHC.Base.String], Types.InputRule -> Types.InputInstruction)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> (GHC.Types.[] @ GHC.Base.String,
                       Types.NoInstruction @ Types.InputRule)
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseInstruction1 of wild1 {
                        GHC.Types.False -> (wild, Types.NoInstruction @ Types.InputRule)
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (wild, Types.NoInstruction @ Types.InputRule)
                             : c ds3
                             -> case ds3 of wild3 {
                                  [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                  : ds4 xs
                                  -> case ds4 of wild4 {
                                       [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                       : ds5 ds6
                                       -> case ds5 of wild5 { GHC.Types.C# ds7 ->
                                          case ds7 of ds8 {
                                            DEFAULT -> (wild, Types.NoInstruction @ Types.InputRule)
                                            ':'
                                            -> case ds6 of wild6 {
                                                 [] -> (xs, Types.ToChainNamed @ Types.InputRule c)
                                                 : ipv ipv1
                                                 -> (wild,
                                                     Types.NoInstruction
                                                       @ Types.InputRule) } } } } } } } }) -}
802964f1452876f449be5fd1ce6d8d33
  parseInstruction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chain"#) -}
418d24d34d39b702a6ce236e61c5b418
  parseRule :: [GHC.Base.String] -> Types.InputRule
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 let {
                   ds1 :: ([[GHC.Types.Char]], [[GHC.Types.Char]])
                   = case GHC.List.$wbreak
                            @ [GHC.Types.Char]
                            ParseSpecificationLanguage.parseRule2
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 Types.Rule
                   @ Types.InputCriteria
                   (case ds1 of wild { (,) c t ->
                    ParseSpecificationLanguage.parseSpecificationCriteria c })
                   (case ds1 of wild { (,) c t ->
                    case t of wild1 {
                      [] -> GHC.Types.[] @ Types.Target
                      : ds2 ds3
                      -> ParseSpecificationLanguage.parseSpecificationTarget ds3 } })
                   ParseSpecificationLanguage.parseRule1) -}
4e1aa3c7235175078574a6fe2ace1dff
  parseRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# (-1)) -}
f11aeed7f40136dbbadae8dd00d82bac
  parseRule2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (GHC.Base.eqString
                   ParseSpecificationLanguage.parseRule3) -}
dbee4f01564b53798434edbcb7966178
  parseRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=>"#) -}
97446a27dadc952d8f7e3f6221db2411
  parseSpecificationCriteria ::
    [GHC.Base.String] -> [Types.InputCriteria]
  {- Arity: 1, Strictness: <S,1*U> -}
57e77209b38bfb910301fe3e4ed8c404
  parseSpecificationCriteria' ::
    [GHC.Base.String] -> (Types.InputCriteria, [GHC.Base.String])
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationCriteria'
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
5605e0568d173de7edacb3abcc79f348
  parseSpecificationTarget :: [GHC.Base.String] -> [Types.Target]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationTarget
                        w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.Target ww1 ww2 }) -}
62df66a2d2ef0c5b358cb09be796dd0d
  parseSpecificationTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
14dfb52ab0a9d18677968e9cc9ff000f
  parseSpecificationTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
048f964a0b52daf32099aab96605153c
  parseSpecificationTarget3 :: [Types.Target]
  {- Strictness: b -}
7fccf678e4a995d3de3f4aaae8dfdbb3
  toConjunction ::
    GHC.Base.String
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ ds1 :: [GHC.Types.Char] ->
                 case GHC.Base.eqString
                        ds1
                        ParseSpecificationLanguage.toConjunction4 of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.toConjunction3 of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ ([Types.InputCriteria] -> Types.InputCriteria)
                        GHC.Types.True -> ParseSpecificationLanguage.toConjunction2 }
                   GHC.Types.True -> ParseSpecificationLanguage.toConjunction1 }) -}
ea0328173236a676b1e24c2ab040bcfa
  toConjunction1 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.And) -}
22d6f95d98bd6a090be6cb1683024319
  toConjunction2 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.Or) -}
32411603950933f2263a8a8ea34cdb04
  toConjunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OR"#) -}
25d50274f34a8034738a2d09fa7b7918
  toConjunction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AND"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

