
==================== FINAL INTERFACE ====================
2016-08-11 00:33:27.18176 UTC

interface main@main:ParseSpecificationLanguage 7103
  interface hash: 0449f16293a91b99fd96a991f9a0cc7c
  ABI hash: c76f7c5a07bccbc6d8df86be67eebf50
  export-list hash: 97b3a15dfab8f73d45ff5f6798ca2b79
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParseSpecificationLanguage.conjunctionAtFront
  ParseSpecificationLanguage.findAfterLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis'
  ParseSpecificationLanguage.isConjunction
  ParseSpecificationLanguage.lexer
  ParseSpecificationLanguage.parse
  ParseSpecificationLanguage.parseInstruction
  ParseSpecificationLanguage.parseRule
  ParseSpecificationLanguage.parseSpecificationCriteria
  ParseSpecificationLanguage.parseSpecificationCriteria'
  ParseSpecificationLanguage.parseSpecificationTarget
  ParseSpecificationLanguage.toConjunction
module dependencies: ParserHelp Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Unicode cdf84fc3abbaf34ba6b6645291cef991
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ParserHelp c7affdab4be2cddd08133e07d05d3b63
  exports: 4408f0f73d248a4701f2f315f854c188
  isInteger cc10131991668b1b7abaf3e084cfc260
import  -/  Types 22400a5faae8b7e0ddaf8e819accc2b5
  exports: 543a62a9d1b1c5a4ade5b8a7472fb031
  ACCEPT a0e8bfb182327208223f4101204d01d3
  And 6f9bf0163ff27e2a03199030eb3d0445
  DROP 030c92a184ce42e939e5fbc310e578ea
  Destination 922d80ba258cc0a086584d38ca75ebef
  InC 6c0d1368639dd5a4ac0527e46326621f
  InCNot b117f7befd6efbd09704f41fc25cc327
  InputCriteria e40faf9184c5e56de440c7debe74a4a8
  InputInstruction 59fc02937cc01a8a91bd460221924af6
  InputRule e40faf9184c5e56de440c7debe74a4a8
  NoInstruction b969e22921f283e869a0720ab3777dec
  Or d0cd109da857d4a68fc590655040fcf8
  Port 8a0ec73e1ab267e270216694792c8d9b
  Protocol 4dac2e327a2d0444c30af9bf1df029cc
  Rule 2df5292164aa863af871847a92afc898
  SC a0c12a74ff86c6759b737c5fbe6a4a9b
  Source b53eb4518fedc84d30c0b4327bd32c7d
  Target 96fab3e40e346c4a445f4966317f4361
  ToChainNamed ce4c7bf5b328004ab15754446244f326
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split.Internals ec8cf5264ec78ab060cadb7ee5b994f0
f8705defb6c00f2ca605c7f24840ddc4
  $wparseSpecificationCriteria' ::
    [GHC.Base.String] -> (# Types.InputCriteria, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
ed7a173cab1bb10bd86703c768aa35ff
  $wparseSpecificationTarget ::
    [GHC.Base.String] -> (# Types.Target, [Types.Target] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> case ParseSpecificationLanguage.parseSpecificationTarget3
                      ret_ty (# Types.Target, [Types.Target] #)
                      of {}
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseSpecificationTarget2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString
                                  ds1
                                  ParseSpecificationLanguage.parseSpecificationTarget1 of wild2 {
                             GHC.Types.False
                             -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                ret_ty (# Types.Target, [Types.Target] #)
                                of {}
                             GHC.Types.True
                             -> case ds2 of wild3 {
                                  [] -> (# Types.DROP, GHC.Types.[] @ Types.Target #)
                                  : ipv ipv1
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } }
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (# Types.ACCEPT, GHC.Types.[] @ Types.Target #)
                             : ipv ipv1
                             -> case GHC.Base.eqString
                                       ds1
                                       ParseSpecificationLanguage.parseSpecificationTarget1 of wild3 {
                                  GHC.Types.False
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {}
                                  GHC.Types.True
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } } } }) -}
1d067a16bba19928ef9d851108547edd
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
dfd5f87bf375344ed1a219110a9e2d6d
  conjunctionAtFront ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   []
                   -> GHC.Base.Nothing
                        @ ([Types.InputCriteria] -> Types.InputCriteria)
                   : ipv ipv1
                   -> case GHC.List.elem
                             @ GHC.Base.String
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ipv
                             ParseSpecificationLanguage.conjunctionAtFront2 of wild1 {
                        GHC.Types.False
                        -> ParseSpecificationLanguage.conjunctionAtFront1 wild
                        GHC.Types.True
                        -> ParseSpecificationLanguage.toConjunction ipv } }) -}
80a69a484986852619a6334e3aa518f7
  conjunctionAtFront1 ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <L,U>b -}
0527e616fe505f0e7e5090bb12d14955
  conjunctionAtFront2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction4
                   ParseSpecificationLanguage.conjunctionAtFront3) -}
6befb3cd238bc817cb5ed4ea04efd41e
  conjunctionAtFront3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
4d7761683ba7c466d784334245bc7025
  findAfterLeadingParenthesis ::
    [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Base.String] ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        (ParseSpecificationLanguage.findInLeadingParenthesis s)
                        0 of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# 2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> ParseSpecificationLanguage.$wunsafeDrop @ GHC.Base.String x s
                   GHC.Types.True -> s } }) -}
d0b74c6656242cb7c2ad3fe0ed1c40ae
  findInLeadingParenthesis :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds2 xs
                   -> case ds2 of wild1 {
                        [] -> wild
                        : ds3 ds4
                        -> case ds3 of wild2 { GHC.Types.C# ds5 ->
                           case ds5 of ds6 {
                             DEFAULT -> wild
                             '('
                             -> case ds4 of wild3 {
                                  []
                                  -> ParseSpecificationLanguage.findInLeadingParenthesis'
                                       xs
                                       ParseSpecificationLanguage.findInLeadingParenthesis1
                                  : ipv ipv1 -> wild } } } } }) -}
ceb78809f0f26de26b2c1c90fdf4f3d4
  findInLeadingParenthesis' ::
    [GHC.Base.String] -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
b4bafc8d32969d530810c80050a7b061
  findInLeadingParenthesis1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
f36dcc62cf478c86855b3b8802eeb668
  isConjunction :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   s
                   ParseSpecificationLanguage.conjunctionAtFront2) -}
77c583e36e586e5038c1f8ebe9f4eeb6
  lexer :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
0b735943707edd23c4987a5954e979de
  parse :: [GHC.Base.String] -> [Types.InputInstruction]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: [GHC.Base.String] ->
                 GHC.Base.build
                   @ (Types.SynthInstruction Types.InputRule)
                   (\ @ b1
                      c :: Types.SynthInstruction Types.InputRule -> b1 -> b1[OneShot]
                      n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ (Types.SynthInstruction Types.InputRule)
                         @ b1
                         @ [GHC.Base.String]
                         c
                         ParseSpecificationLanguage.parse3)
                      n2
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Base.String
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         ParseSpecificationLanguage.parse1
                         s))) -}
58b324383b26a2c39973a350073b7c40
  parse1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.parse2
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c4898de41ab3d8d4b34ee3e497f85e
  parse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
be006590d0c8447e733141ee58cea154
  parse3 ::
    [GHC.Base.String] -> Types.SynthInstruction Types.InputRule
  {- Arity: 1, Strictness: <S,1*U> -}
1c3e1edb6e007620ea777f497d8d169c
  parseInstruction ::
    [GHC.Base.String]
    -> ([GHC.Base.String], Types.InputRule -> Types.InputInstruction)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> (GHC.Types.[] @ GHC.Base.String,
                       Types.NoInstruction @ Types.InputRule)
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseInstruction1 of wild1 {
                        GHC.Types.False -> (wild, Types.NoInstruction @ Types.InputRule)
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (wild, Types.NoInstruction @ Types.InputRule)
                             : c ds3
                             -> case ds3 of wild3 {
                                  [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                  : ds4 xs
                                  -> case ds4 of wild4 {
                                       [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                       : ds5 ds6
                                       -> case ds5 of wild5 { GHC.Types.C# ds7 ->
                                          case ds7 of ds8 {
                                            DEFAULT -> (wild, Types.NoInstruction @ Types.InputRule)
                                            ':'
                                            -> case ds6 of wild6 {
                                                 [] -> (xs, Types.ToChainNamed @ Types.InputRule c)
                                                 : ipv ipv1
                                                 -> (wild,
                                                     Types.NoInstruction
                                                       @ Types.InputRule) } } } } } } } }) -}
802964f1452876f449be5fd1ce6d8d33
  parseInstruction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chain"#) -}
ec17c60c75ec8f13a3992b0dd7e6fb16
  parseRule :: [GHC.Base.String] -> Types.InputRule
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 let {
                   ds1 :: ([[GHC.Types.Char]], [[GHC.Types.Char]])
                   = case GHC.List.$wbreak
                            @ [GHC.Types.Char]
                            ParseSpecificationLanguage.parseRule2
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 Types.Rule
                   @ Types.InputCriteria
                   (case ds1 of wild { (,) c t ->
                    ParseSpecificationLanguage.parseSpecificationCriteria c })
                   (case ds1 of wild { (,) c t ->
                    case t of wild1 {
                      [] -> GHC.Types.[] @ Types.Target
                      : ds2 ds3
                      -> ParseSpecificationLanguage.parseSpecificationTarget ds3 } })
                   ParseSpecificationLanguage.parseRule1) -}
4e1aa3c7235175078574a6fe2ace1dff
  parseRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# (-1)) -}
f11aeed7f40136dbbadae8dd00d82bac
  parseRule2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (GHC.Base.eqString
                   ParseSpecificationLanguage.parseRule3) -}
dbee4f01564b53798434edbcb7966178
  parseRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=>"#) -}
9bfb979f16bbf2f8b91fa60d1a067d42
  parseSpecificationCriteria ::
    [GHC.Base.String] -> [Types.InputCriteria]
  {- Arity: 1, Strictness: <S,1*U> -}
f9e3a074d99c132db38b0c61f7a45b3e
  parseSpecificationCriteria' ::
    [GHC.Base.String] -> (Types.InputCriteria, [GHC.Base.String])
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationCriteria'
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
5605e0568d173de7edacb3abcc79f348
  parseSpecificationTarget :: [GHC.Base.String] -> [Types.Target]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationTarget
                        w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.Target ww1 ww2 }) -}
62df66a2d2ef0c5b358cb09be796dd0d
  parseSpecificationTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
14dfb52ab0a9d18677968e9cc9ff000f
  parseSpecificationTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
048f964a0b52daf32099aab96605153c
  parseSpecificationTarget3 :: [Types.Target]
  {- Strictness: b -}
5fb791d79146a26c32275fe3462f8462
  toConjunction ::
    GHC.Base.String
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ ds1 :: [GHC.Types.Char] ->
                 case GHC.Base.eqString
                        ds1
                        ParseSpecificationLanguage.toConjunction4 of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.toConjunction3 of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ ([Types.InputCriteria] -> Types.InputCriteria)
                        GHC.Types.True -> ParseSpecificationLanguage.toConjunction2 }
                   GHC.Types.True -> ParseSpecificationLanguage.toConjunction1 }) -}
42b5931b7dd446d1d52374343e2d1a05
  toConjunction1 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.And) -}
d1ef3ccea95f542d79936e33e790f7a5
  toConjunction2 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.Or) -}
32411603950933f2263a8a8ea34cdb04
  toConjunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OR"#) -}
25d50274f34a8034738a2d09fa7b7918
  toConjunction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AND"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

