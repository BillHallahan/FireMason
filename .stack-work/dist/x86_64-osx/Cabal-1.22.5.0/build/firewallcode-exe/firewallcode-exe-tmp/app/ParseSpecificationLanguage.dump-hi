
==================== FINAL INTERFACE ====================
2016-07-23 20:29:39.640036 UTC

interface main@main:ParseSpecificationLanguage 7103
  interface hash: a4407ec6f8dd22985ce7d96de0351a1c
  ABI hash: b31339ee762e54e69a2f46fc85314850
  export-list hash: 18b78b5e45df71d295885bec234dff07
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParseSpecificationLanguage.conjunctionAtFront
  ParseSpecificationLanguage.findAfterLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis'
  ParseSpecificationLanguage.isConjunction
  ParseSpecificationLanguage.lexer
  ParseSpecificationLanguage.parse
  ParseSpecificationLanguage.parseRule
  ParseSpecificationLanguage.parseSpecificationCriteria
  ParseSpecificationLanguage.parseSpecificationCriteria'
  ParseSpecificationLanguage.parseSpecificationTarget
  ParseSpecificationLanguage.toConjunction
module dependencies: ParserHelp Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Char c8f827952d4111ae2e47c0b105217cdb
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Unicode cdf84fc3abbaf34ba6b6645291cef991
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:Text.Read ef0ef92fb7358ae94bab089940adfd2a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ParserHelp c7affdab4be2cddd08133e07d05d3b63
  exports: 4408f0f73d248a4701f2f315f854c188
  isInteger cc10131991668b1b7abaf3e084cfc260
import  -/  Types 04c5d15b9d7273cc2ee1e20f9be4a3ba
  exports: fd7624f994dcfddcd82d0e50111df34c
  ACCEPT a0e8bfb182327208223f4101204d01d3
  And 5195d3774cf1942d5e58caa42d70af54
  DROP 030c92a184ce42e939e5fbc310e578ea
  InC 3539351cc3e190855338110f4e6790ab
  InCNot 8ff5abb66a695df32bcc8089f70a3b3c
  InputCriteria 2b7688b3d0767262f8baee17da5df09c
  InputRule 2b7688b3d0767262f8baee17da5df09c
  Or de825078084cdb216f3a58cabf01cca3
  Port d7bc2cb09990c77f5ec8875ceaee31f7
  Protocol 29c2a667093165aebd30cf9c8335414a
  Rule 8ed946244beed4239f95e13f25795a2d
  SC 6471a949fdcd21a63f604423808813f9
  Target 96fab3e40e346c4a445f4966317f4361
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split 487cc1966f0f25916f1ba58bdff4b0ee
import  -/  split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE:Data.List.Split.Internals ec8cf5264ec78ab060cadb7ee5b994f0
e2b561bf0a3b6b0e813d19fb28c2b96a
  $wparseSpecificationCriteria' ::
    [GHC.Base.String] -> (# Types.InputCriteria, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
d301796655861c02a95511b817cccc5f
  $wparseSpecificationTarget ::
    [GHC.Base.String] -> (# Types.Target, [Types.Target] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> case ParseSpecificationLanguage.parseSpecificationTarget3
                      ret_ty (# Types.Target, [Types.Target] #)
                      of {}
                   : ds ds1
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.parseSpecificationTarget2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString
                                  ds
                                  ParseSpecificationLanguage.parseSpecificationTarget1 of wild2 {
                             GHC.Types.False
                             -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                ret_ty (# Types.Target, [Types.Target] #)
                                of {}
                             GHC.Types.True
                             -> case ds1 of wild3 {
                                  [] -> (# Types.DROP, GHC.Types.[] @ Types.Target #)
                                  : ipv ipv1
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } }
                        GHC.Types.True
                        -> case ds1 of wild2 {
                             [] -> (# Types.ACCEPT, GHC.Types.[] @ Types.Target #)
                             : ipv ipv1
                             -> case GHC.Base.eqString
                                       ds
                                       ParseSpecificationLanguage.parseSpecificationTarget1 of wild3 {
                                  GHC.Types.False
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {}
                                  GHC.Types.True
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } } } }) -}
1d067a16bba19928ef9d851108547edd
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
b594c585d35e5bcc4ab338493e1d1c8a
  conjunctionAtFront ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [GHC.Base.String] ->
                 case ds of wild {
                   []
                   -> GHC.Base.Nothing
                        @ ([Types.InputCriteria] -> Types.InputCriteria)
                   : ipv ipv1
                   -> case GHC.List.elem
                             @ GHC.Base.String
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ipv
                             ParseSpecificationLanguage.conjunctionAtFront2 of wild1 {
                        GHC.Types.False
                        -> ParseSpecificationLanguage.conjunctionAtFront1 wild
                        GHC.Types.True
                        -> ParseSpecificationLanguage.toConjunction ipv } }) -}
ec7c4e32a35d0dbf1e7765db461ffcfc
  conjunctionAtFront1 ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <L,U>b -}
0527e616fe505f0e7e5090bb12d14955
  conjunctionAtFront2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction4
                   ParseSpecificationLanguage.conjunctionAtFront3) -}
6befb3cd238bc817cb5ed4ea04efd41e
  conjunctionAtFront3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
80262df2b8a7dd83f4893064da4ceae4
  findAfterLeadingParenthesis ::
    [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Base.String] ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        (ParseSpecificationLanguage.findInLeadingParenthesis s)
                        0 of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# 2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> ParseSpecificationLanguage.$wunsafeDrop @ GHC.Base.String x s
                   GHC.Types.True -> s } }) -}
958928b657f5fd8ba6ad4f3ba7b833f9
  findInLeadingParenthesis :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: [GHC.Base.String] ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds1 xs
                   -> case ds1 of wild1 {
                        [] -> wild
                        : ds2 ds3
                        -> case ds2 of wild2 { GHC.Types.C# ds4 ->
                           case ds4 of ds5 {
                             DEFAULT -> wild
                             '('
                             -> case ds3 of wild3 {
                                  []
                                  -> ParseSpecificationLanguage.findInLeadingParenthesis'
                                       xs
                                       ParseSpecificationLanguage.findInLeadingParenthesis1
                                  : ipv ipv1 -> wild } } } } }) -}
ceb78809f0f26de26b2c1c90fdf4f3d4
  findInLeadingParenthesis' ::
    [GHC.Base.String] -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
b4bafc8d32969d530810c80050a7b061
  findInLeadingParenthesis1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
f36dcc62cf478c86855b3b8802eeb668
  isConjunction :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   s
                   ParseSpecificationLanguage.conjunctionAtFront2) -}
77c583e36e586e5038c1f8ebe9f4eeb6
  lexer :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
d7a646f3f6be88dcf8ac67cb7b71b8d4
  parse :: [GHC.Base.String] -> [Types.InputRule]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: [GHC.Base.String] ->
                 GHC.Base.build
                   @ (Types.GenRule Types.InputCriteria)
                   (\ @ b1
                      c :: Types.GenRule Types.InputCriteria -> b1 -> b1[OneShot]
                      n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ (Types.GenRule Types.InputCriteria)
                         @ b1
                         @ [GHC.Base.String]
                         c
                         ParseSpecificationLanguage.parseRule)
                      n2
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Base.String
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         ParseSpecificationLanguage.parse1
                         s))) -}
58b324383b26a2c39973a350073b7c40
  parse1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.parse2
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c4898de41ab3d8d4b34ee3e497f85e
  parse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
6fc7a0eae0e9ebadaa97af8e8efd8b4a
  parseRule :: [GHC.Base.String] -> Types.InputRule
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 let {
                   ds :: ([[GHC.Types.Char]], [[GHC.Types.Char]])
                   = case GHC.List.$wbreak
                            @ [GHC.Types.Char]
                            ParseSpecificationLanguage.parseRule2
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 Types.Rule
                   @ Types.InputCriteria
                   (case ds of wild { (,) c t ->
                    ParseSpecificationLanguage.parseSpecificationCriteria c })
                   (case ds of wild { (,) c t ->
                    case t of wild1 {
                      [] -> GHC.Types.[] @ Types.Target
                      : ds1 ds2
                      -> ParseSpecificationLanguage.parseSpecificationTarget ds2 } })
                   ParseSpecificationLanguage.parseRule1) -}
b6957a8a8c0657978d7e8c83d146a5f7
  parseRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
f11aeed7f40136dbbadae8dd00d82bac
  parseRule2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (GHC.Base.eqString
                   ParseSpecificationLanguage.parseRule3) -}
dbee4f01564b53798434edbcb7966178
  parseRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=>"#) -}
941448efc877069794f08f39c3502501
  parseSpecificationCriteria ::
    [GHC.Base.String] -> [Types.InputCriteria]
  {- Arity: 1, Strictness: <S,1*U> -}
493cd3e00e903fcd4f9d80d27d49ad29
  parseSpecificationCriteria' ::
    [GHC.Base.String] -> (Types.InputCriteria, [GHC.Base.String])
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationCriteria'
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
def321a540af9a208c72596ba7c496ef
  parseSpecificationTarget :: [GHC.Base.String] -> [Types.Target]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationTarget
                        w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.Target ww1 ww2 }) -}
62df66a2d2ef0c5b358cb09be796dd0d
  parseSpecificationTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
14dfb52ab0a9d18677968e9cc9ff000f
  parseSpecificationTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
048f964a0b52daf32099aab96605153c
  parseSpecificationTarget3 :: [Types.Target]
  {- Strictness: b -}
894d2f06423286ccd5f6b2b258227d83
  toConjunction ::
    GHC.Base.String
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ ds :: [GHC.Types.Char] ->
                 case GHC.Base.eqString
                        ds
                        ParseSpecificationLanguage.toConjunction4 of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             ds
                             ParseSpecificationLanguage.toConjunction3 of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ ([Types.InputCriteria] -> Types.InputCriteria)
                        GHC.Types.True -> ParseSpecificationLanguage.toConjunction2 }
                   GHC.Types.True -> ParseSpecificationLanguage.toConjunction1 }) -}
1c133e20414aceabbeffc72dd87f7de9
  toConjunction1 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.And) -}
4f8ea4f36cb54d95af06c20c6e5d561f
  toConjunction2 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.Or) -}
32411603950933f2263a8a8ea34cdb04
  toConjunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OR"#) -}
25d50274f34a8034738a2d09fa7b7918
  toConjunction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AND"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

