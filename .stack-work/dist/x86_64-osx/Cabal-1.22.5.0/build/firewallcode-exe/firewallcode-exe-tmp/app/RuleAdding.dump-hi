
==================== FINAL INTERFACE ====================
2016-08-01 22:24:18.331903 UTC

interface main@main:RuleAdding 7103
  interface hash: d435d1f4b9e5c19ffdbdcc74c4e65050
  ABI hash: c934e04e80db2e41075ddc6682d53c1a
  export-list hash: eb7d3d9ba91c4dd200996c613845cb34
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRuleToChainAtPos
  RuleAdding.addRules
  RuleAdding.findBestPointCut
  RuleAdding.findPointCut
  RuleAdding.scoreCriteria
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: ChainsToSMT2 NameIdChain ParserHelp SMT Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  ChainsToSMT2 cde751d47b63a853512dfd91fc117aa1
  exports: 116a23a42f5b28b393be927d1dd4514a
  convertChainsCheckSMT bb220a39a738f6670a6ce17997da3e9e
  toSMT 62d5b1442b3b246e3d0d5d1e1b0d610d
import  -/  NameIdChain a3f302b52e0ae93eec39f653620979f7
  exports: 067093adcf19cf9b7d63999521430201
  increaseIndexes df3c8ef3d435c447bd63cbf64b7bc9bc
  maxId ef983ad837a964f6934fb100f5971864
  nameIdChainWithId 826e861ef0c4d81dbca085a8fe21789a
import  -/  SMT ad5cc286b4b8f93c12204fc2a9edd888
  exports: a94561e4d0f7927a3335aa58f6911b1b
  checkSat d00f4563ef5e93aab3e28f39e86ea9fc
import  -/  Types 7934cc096ad4ac018aac4adeb7e3cd39
  exports: 39af0f5b1cafb87923b315bfa9b266b9
  Chain 63cc581b204b4367506f8067294b4375
  Criteria 61b02b594ef3ae008da99e5e81a331ad
  Instruction 961d9c37c629f8d37f154cc6c8c8d7ef
  NameIdChain a3dc641cee892e9ac581c09c512122d9
  NameIdChain 8291be8a39ca8cfd31ec21359b660c7b
  Rule 68d00fff6301ed891d230229e52bda64
  Rule b6d94cfe05ce24ee2081c8f355e279c9
  Target 96fab3e40e346c4a445f4966317f4361
  chain 8bbf7e1f27cb638d758b4325f96d5592
  chainName ab0cf82ed436ae66ad6a67c8d1630804
  criteria b22504e024f4f0f8636519bee4a7a9bb
  ids 0dea467f3f42cf574dc9487e2404f4af
  insRule a9610eb0bc656025132274d219858804
  name a8e6111a530434eb1f97885d78c94099
516ed4e8614814c43c2206f54642cd6e
  $waddRuleToChainAtPos ::
    Types.Rule
    -> Types.Chain -> GHC.Prim.Int# -> [Types.GenRule Types.Criteria]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: Types.Chain
                   ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        []
                        -> GHC.Base.++
                             @ (Types.GenRule Types.Criteria)
                             (GHC.Types.[] @ Types.Rule)
                             (GHC.Types.: @ Types.Rule w (GHC.Types.[] @ Types.Rule))
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([Types.Rule], [Types.Rule])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ Types.Rule
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.:
                                     @ Types.Rule
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (GHC.Types.:
                                     @ Types.Rule
                                     w
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs'' }))
                             1
                             -> GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.: @ Types.Rule ipv (GHC.Types.[] @ Types.Rule))
                                  (GHC.Types.: @ Types.Rule w ipv1) } }
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (Types.GenRule Types.Criteria)
                        (GHC.Types.[] @ Types.Rule)
                        (GHC.Types.: @ Types.Rule w w1) }) -}
d5bb99c40d45e5b58debdc5ac37087ed
  $wscoreRules ::
    [Types.Criteria]
    -> [Types.Target]
    -> [Types.Criteria]
    -> [Types.Target]
    -> GHC.Types.Int
  {- Arity: 4, Strictness: <B,1*U><B,1*U><B,U><B,U>b, Inline: [0] -}
32629b4c3c8f62305a61b0fe429a708c
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule -> [Types.NameIdChain] -> [Types.NameIdChain]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U>,
     Unfolding: (\ s :: GHC.Base.String
                   r :: Types.Rule
                   n :: [Types.NameIdChain] ->
                 letrec {
                   $wgo :: [Types.NameIdChain]
                           -> (# [Types.NameIdChain], [Types.NameIdChain] #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ w :: [Types.NameIdChain] ->
                     case w of wild {
                       []
                       -> (# GHC.Types.[] @ Types.NameIdChain,
                             GHC.Types.[] @ Types.NameIdChain #)
                       : y ys
                       -> case y of wild1 { Types.NameIdChain ds1 ds2 ds3 ->
                          let {
                            w2 :: ([Types.NameIdChain], [Types.NameIdChain])
                            = case $wgo ys of ww { (#,#) ww1 ww2 -> (ww1, ww2) }
                          } in
                          case GHC.Base.eqString ds1 s of wild2 {
                            GHC.Types.False
                            -> (# case w2 of wild3 { (,) ts fs -> ts },
                                  GHC.Types.:
                                    @ Types.NameIdChain
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> fs }) #)
                            GHC.Types.True
                            -> (# GHC.Types.:
                                    @ Types.NameIdChain
                                    wild1
                                    (case w2 of wild3 { (,) ts fs -> ts }),
                                  case w2 of wild3 { (,) ts fs -> fs } #) } } }
                 } in
                 case $wgo n of ww { (#,#) ww1 ww2 ->
                 letrec {
                   go :: [Types.NameIdChain] -> [Types.NameIdChain]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [Types.NameIdChain] ->
                     case ds of wild {
                       [] -> ww2
                       : y ys
                       -> GHC.Types.:
                            @ Types.NameIdChain
                            (case y of wild1 { Types.NameIdChain name i c ->
                             Types.NameIdChain name i (GHC.Types.: @ Types.Rule r c) })
                            (go ys) }
                 } in
                 go ww1 }) -}
89d77198b5cc32280cd5d335ae7e791e
  addRuleToChainAtPos ::
    Types.Rule -> Types.Chain -> GHC.Types.Int -> Types.Chain
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: Types.Chain w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 RuleAdding.$waddRuleToChainAtPos w w1 ww1 }) -}
8fddb97c315dff9b365211fd7e6e9efc
  addRules ::
    [Types.Instruction] -> [Types.NameIdChain] -> [Types.NameIdChain]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
8e094204cc804e39cc06eda9ae6517f2
  findBestPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> [Types.NameIdChain]
    -> GHC.Types.IO GHC.Types.Int
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.findBestPointCut1
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <[Types.NameIdChain]>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
bca6784dcb600e91d45853c0051c540f
  findBestPointCut1 ::
    Types.Rule
    -> GHC.Types.Int
    -> [Types.NameIdChain]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><L,U> -}
b87e1e665e53c4fab66726d90f346631
  findPointCut :: Types.Rule -> Types.Chain -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U>,
     Unfolding: (\ r :: Types.Rule c :: Types.Chain ->
                 let {
                   scores :: [GHC.Types.Int]
                   = GHC.Base.map
                       @ (Types.GenRule Types.Criteria)
                       @ GHC.Types.Int
                       (RuleAdding.scoreRules r)
                       c
                 } in
                 case Data.OldList.findIndex
                        @ GHC.Types.Int
                        (GHC.Classes.eqInt
                           (GHC.List.strictMaximum
                              @ GHC.Types.Int
                              GHC.Classes.$fOrdInt
                              scores))
                        scores of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                   GHC.Base.Just x -> x }) -}
f609981890bfb5584e3f1c6699388293
  scoreCriteria ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
a6a7c13855da8f1aaa38580b6ae2361f
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U(1*U,1*U)><B,1*U(U,U)>b,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ->
                 case w1 of ww3 { Types.Rule ww4 ww5 ->
                 RuleAdding.$wscoreRules ww1 ww2 ww4 ww5 } }) -}
e613cb7727aedb776158a5590d14f56d
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

