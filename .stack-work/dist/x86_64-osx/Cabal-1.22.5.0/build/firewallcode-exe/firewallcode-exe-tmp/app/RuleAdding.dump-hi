
==================== FINAL INTERFACE ====================
2016-08-14 02:36:05.27115 UTC

interface main@main:RuleAdding 7103
  interface hash: ea014678ca1d3a74871dbad38cee3b05
  ABI hash: 4baa44d2471a01ba3e68b7a38461e21f
  export-list hash: d21197875f79cbcd5006d1bf1cd8f842
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRuleToChainAtPos
  RuleAdding.addRules
  RuleAdding.findBestPointCut
  RuleAdding.findBestPointCut'
  RuleAdding.findPointCut
  RuleAdding.instructionsToAddAtPos
  RuleAdding.scm
  RuleAdding.scoreCriteria
  RuleAdding.scoreCriteriaList
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: ChainsToSMT2 NameIdChain ParserHelp SMT Types
package dependencies: MissingH-1.3.0.2@Missi_0LYz2ExiF1QEfGgduKzSaZ
                      array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA base-4.8.2.0
                      bytestring-0.10.6.0@bytes_6VWy06pWzJq9evDvK2d4w6
                      containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 mtl-2.2.1@mtl_Aue4leSeVkpKLsfHIV51E8
                      process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      regex-base-0.93.2@regex_47KXx9dLqeO8MNJeizLKhP
                      regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89
                      regex-compat-0.95.1@regex_EyUO1k1s8YNJ81jSdgVW1z
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
         regex-base-0.93.2@regex_47KXx9dLqeO8MNJeizLKhP:Text.Regex.Base.Context
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.ByteString
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.Sequence
         regex-posix-0.95.2@regex_ClFHQvfj6rtJ1Pxo4OAy89:Text.Regex.Posix.String
         transformers-0.4.2.0@trans_GZTjP9K5WFq01xC9BAGQpF:Control.Monad.Trans.Error
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Sequence
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Debug.Trace 6660afb6094d69397ea084364da8f950
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base c921f79770a215e3f4c72c747cb6a28a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  ChainsToSMT2 bd0abae7f1eb76631d40f6d6e62e5a30
  exports: 6df6e3c5db831fd5191a0f08e93d7557
  convertChainsCheckSMT 91ccda924edbb9d04b7f1e8b3a72632d
  toSMT 92b11cee6e6519b6991a844d99c112a5
import  -/  NameIdChain e4993fa1089d01db5aa4adb7e637ba97
  exports: 9ff82ba4aa39e1eb044c914702771b51
  idsWithName 9f17a1463ff6c660774be6154912dba6
  increaseIndexes 19a7f85e4eedd8359d8f10d9feb99351
  maxId 7ed30ffaae6d20f317a2ed30f1b60bf6
import  -/  SMT 78b6ee582b4c547d861399edd96af15b
  exports: bdc12074afdd6621e65d5072296d84d4
  checkSat 670eb44a961dd0fbcf136213f196bd85
  printSMTFunc1 6dadeb978a815eb5e980d7f89ff0b9c4
  printSMTFunc2 243e9871a211ea0f88b6b96fd7bf09ab
  printSMTFunc3 df48ad66d0f6827890c4de0dc9297b70
import  -/  Types 8e5d6bf8bd4e68da2c2990dcc945144b
  exports: 8b870742f535852668b544f1c644b52e
  Chain 7fe252100536b1dde81007f7021906c4
  Criteria 605b90b34d99bcf3227a69e454b38e17
  IdNameChain 7b509ac5537dcded5517545ca40b718e
  Instruction 1d8db10fc22bb8af140c62e812849076
  Not b8339c1be2f1b9a12b2b3eb568593726
  Port 0cdcd795ebd2c331c1401f6cf3404c99
  Protocol d38fdc887d9a0e7c53d19d8b463500f3
  Rule 6664d15e2c4eb242c5746c483f2eae4f
  Rule 58833ff10314ee54807ea6dd5e748524
  Target a705ec2694e0279dfa3beac89f166c0d
  chainName 8821439aec3279dd9572bf6c8c110567
  criteria 7bbfe7454258bffec8dcff73bff88073
  insRule 8e138eb267aaea8894463ffcac20987b
  label 2ed2a5bcb6d1dd562fbd4c9ce09e9c09
  targets 3abe713ecb24e9d24b96a6af1d80bc91
574baebeb07ec08f39a9e8555fc8e570
  $w$sgo10 ::
    GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Int a1
    -> Data.Map.Base.Map GHC.Types.Int a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
435103ae91b1ba010286477602c6f822
  $waddRuleToChainAtPos ::
    Types.Rule
    -> Types.Chain -> GHC.Prim.Int# -> [Types.GenRule Types.Criteria]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: Types.Chain
                   ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        []
                        -> GHC.Base.++
                             @ (Types.GenRule Types.Criteria)
                             (GHC.Types.[] @ Types.Rule)
                             (GHC.Types.: @ Types.Rule w (GHC.Types.[] @ Types.Rule))
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([Types.Rule], [Types.Rule])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ Types.Rule
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.:
                                     @ Types.Rule
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (GHC.Types.:
                                     @ Types.Rule
                                     w
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs'' }))
                             1
                             -> GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.: @ Types.Rule ipv (GHC.Types.[] @ Types.Rule))
                                  (GHC.Types.: @ Types.Rule w ipv1) } }
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (Types.GenRule Types.Criteria)
                        (GHC.Types.[] @ Types.Rule)
                        (GHC.Types.: @ Types.Rule w w1) }) -}
e2c97d1f8aaa5e50e392959cfa5ac7b1
  $wfindPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: GHC.Types.Int
                   w2 :: Types.IdNameChain ->
                 (# w1,
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case RuleAdding.$wpoly_go10
                           @ (GHC.Base.String, Types.Chain)
                           ww1
                           w2 of wild {
                      GHC.Base.Nothing
                      -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Int of {}
                      GHC.Base.Just x
                      -> case x of wild1 { (,) ds c ->
                         case GHC.Base.map
                                @ (Types.GenRule Types.Criteria)
                                @ GHC.Types.Int
                                (RuleAdding.scoreRules w)
                                c of wild2 {
                           [] -> RuleAdding.findPointCut1
                           : ds1 ds2
                           -> case Data.OldList.findIndex
                                     @ GHC.Types.Int
                                     (GHC.Classes.eqInt
                                        (GHC.List.strictMaximum
                                           @ GHC.Types.Int
                                           GHC.Classes.$fOrdInt
                                           wild2))
                                     wild2 of wild3 {
                                GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                                GHC.Base.Just x1 -> x1 } } } } } #)) -}
1c8d97bb4af95ee56ab398f5bbb65144
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Types.Int a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
ff9754bd748d7e4a9fd151eb58e58021
  $wscoreCriteria ::
    Types.Criteria -> Types.Criteria -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
f222fdd577a45a78a872a0fe7b4ba007
  $wscoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
252f85c3ee389dcb9ddb3b3e089b08ef
  $wscoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
53b19266a70a6bb91b6520a0faa84525
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Types.IO Types.IdNameChain
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <Types.Rule>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
ec263232608c15d477600d1f23d50092
  addRuleToChain1 ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: (\ s :: GHC.Base.String
                   r :: Types.Rule
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 let {
                   ds :: (Data.Map.Base.Map
                            GHC.Types.Int (GHC.Base.String, Types.Chain),
                          Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain))
                   = case Data.Map.Base.$wpoly_go2
                            @ GHC.Types.Int
                            @ (GHC.Base.String, Types.Chain)
                            (\ ds1 :: GHC.Types.Int
                               x :: (GHC.Base.String, Types.Chain)[OneShot] ->
                             case x of wild { (,) s' ds2 -> GHC.Base.eqString s' s })
                            n of ww { (#,#) ww6 ww7 ->
                     (ww6, ww7) }
                 } in
                 let {
                   change :: Data.Map.Base.Map
                               GHC.Types.Int (GHC.Base.String, Types.Chain)
                   = case ds of wild { (,) change1 noChange -> change1 }
                 } in
                 case RuleAdding.addRuleToChain2
                        r
                        (RuleAdding.addRuleToChain_go10
                           (GHC.List.badHead @ GHC.Types.Int)
                           change)
                        n
                        n
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case Data.Map.Base.map
                           @ (GHC.Base.String, Types.Chain)
                           @ (GHC.Base.String, Types.Chain)
                           @ GHC.Types.Int
                           (\ ds2 :: (GHC.Base.String, Types.Chain) ->
                            case ds2 of wild { (,) s' c ->
                            (s', RuleAdding.addRuleToChainAtPos r c ipv1) })
                           change of wild {
                      Data.Map.Base.Bin ipv2 ipv3 ipv4 ipv5 ipv6
                      -> case ds of wild1 { (,) change1 noChange ->
                         case noChange of wild2 {
                           Data.Map.Base.Bin ipv7 ipv8 ipv9 ipv10 ipv11
                           -> Data.Map.Base.union_$shedgeUnion
                                @ GHC.Types.Int
                                @ (GHC.Base.String, Types.Chain)
                                GHC.Classes.$fOrdInt
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                ipv2
                                ipv3
                                ipv4
                                ipv5
                                ipv6
                                ipv7
                                ipv8
                                ipv9
                                ipv10
                                ipv11
                           Data.Map.Base.Tip -> wild } }
                      Data.Map.Base.Tip
                      -> case ds of wild1 { (,) change1 noChange -> noChange } } #) }) -}
c063d8af6e99279cad2ce9af9782e9c2
  addRuleToChain2 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U> -}
e82885c100f0d6a048276cf611a30dfd
  addRuleToChainAtPos ::
    Types.Rule -> Types.Chain -> GHC.Types.Int -> Types.Chain
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: Types.Chain w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 RuleAdding.$waddRuleToChainAtPos w w1 ww1 }) -}
af6eac0bda77138192789ea316924b35
  addRuleToChain_go10 ::
    GHC.Types.Int
    -> Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain)
    -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U> -}
47d8f4ea1fe34ec6c4aad18152a61bb0
  addRules ::
    [Types.Instruction]
    -> Types.IdNameChain -> GHC.Types.IO Types.IdNameChain
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRules1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
2b74e824d5c8a4cd472a226e26f49fe6
  addRules1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
8ec0aba062d81e0d58c4b1dfc5e83daa
  findBestPointCut ::
    Types.Rule
    -> GHC.Types.Int -> Types.IdNameChain -> GHC.Types.IO GHC.Types.Int
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.findBestPointCut1
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
65f4b0c70527b482b2efca5166252d18
  findBestPointCut' ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Types.IO GHC.Types.Int
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain2
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
c0314a81da953ecc1e4dc30116d599b6
  findBestPointCut1 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ r :: Types.Rule
                   i :: GHC.Types.Int
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 RuleAdding.addRuleToChain2 r i n n eta) -}
68bbe5d0ab786eb0a3bf388e9a4840e1
  findPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: GHC.Types.Int w2 :: Types.IdNameChain ->
                 case RuleAdding.$wfindPointCut w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
93aa8eca446235fa4fa16c54bcfedf0d
  findPointCut1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
75c3ca0e6a45f17849c5b8d8acda4b54
  instructionsToAddAtPos ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Types.IO [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.instructionsToAddAtPos1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <[(Types.Rule, GHC.Base.String, GHC.Types.Int)]>_R)) -}
6f03788f8e2b56a305e4cc621c986102
  instructionsToAddAtPos1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(Types.Rule, GHC.Base.String, GHC.Types.Int)] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
d157374e39c64bd204cbd7d3b7da04ad
  scm :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 100000) -}
6d4deb915663a07606c30fd0ed61552e
  scoreCriteria :: Types.Criteria -> Types.Criteria -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Criteria w1 :: Types.Criteria ->
                 case RuleAdding.$wscoreCriteria w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
d7555902c10d47e502c469b89ecff0b0
  scoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Criteria] w1 :: [Types.Criteria] ->
                 case RuleAdding.$wscoreCriteriaList w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
4b3945c727d4a36578b25b575c68fc75
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2,
     Strictness: <S(SSL),1*U(1*U,1*U,A)><S(SLL),1*U(1*U,U,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 case RuleAdding.$wscoreCriteriaList ww1 ww5 of ww8 { DEFAULT ->
                 case RuleAdding.$wscoreTargets ww2 ww6 of ww9 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.+# ww8 ww9) } } } }) -}
162aaa22e2dad3d68eb6f721f2589905
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Target] w1 :: [Types.Target] ->
                 case RuleAdding.$wscoreTargets w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

