
==================== FINAL INTERFACE ====================
2016-08-12 02:32:35.21079 UTC

interface main@main:RuleAdding 7103
  interface hash: e897cc427d1b0be8ffe184fc0bf2f163
  ABI hash: 116184339278fd6f93d81acd6c68701f
  export-list hash: c601277d6f45448f107a8f0e2e533ab9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRuleToChainAtPos
  RuleAdding.addRules
  RuleAdding.findBestPointCut
  RuleAdding.findBestPointCut'
  RuleAdding.findPointCut
  RuleAdding.instructionsToAddAtPos
  RuleAdding.scm
  RuleAdding.scoreCriteria
  RuleAdding.scoreCriteriaList
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: ChainsToSMT2 NameIdChain ParserHelp SMT Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Debug.Trace 6660afb6094d69397ea084364da8f950
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base c921f79770a215e3f4c72c747cb6a28a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  ChainsToSMT2 22457663f2e9c1348cd2043a3e305570
  exports: bf82e6218314de1c92ec260984842012
  convertChainsCheckSMT 45931d98655e34cc8748a7c827209618
  toSMT f66506931f9f4741044df686ab4ae18d
import  -/  NameIdChain d5b73c8017c24fa66ee55766a6a7357d
  exports: 9ff82ba4aa39e1eb044c914702771b51
  idsWithName 72c446122553b9196290e3e82688fcc0
  increaseIndexes 4f0397597ebf9bbf5b430bd6e122980b
  maxId a8b7e16dc84b3a85ad7c38edf4ff051a
import  -/  SMT 78b6ee582b4c547d861399edd96af15b
  exports: bdc12074afdd6621e65d5072296d84d4
  checkSat 670eb44a961dd0fbcf136213f196bd85
  printSMTFunc1 6dadeb978a815eb5e980d7f89ff0b9c4
  printSMTFunc2 243e9871a211ea0f88b6b96fd7bf09ab
  printSMTFunc3 df48ad66d0f6827890c4de0dc9297b70
import  -/  Types 22400a5faae8b7e0ddaf8e819accc2b5
  exports: 543a62a9d1b1c5a4ade5b8a7472fb031
  Chain ca4dfb51f2b7cc7fafbf4845e3e2a14f
  Criteria 78201c2df366762ffa256db3fa879d5e
  IdNameChain 71992cd51761be36ec48a20089be240b
  Instruction 90e65e2dfea234f40917867645605383
  Not c51190b692ad0139f0c5c973f7d65e98
  Port 8a0ec73e1ab267e270216694792c8d9b
  Protocol 4dac2e327a2d0444c30af9bf1df029cc
  Rule 2df5292164aa863af871847a92afc898
  Rule 4d0f6eb3092e6e02df1b61348eb8fdee
  Target 96fab3e40e346c4a445f4966317f4361
  chainName 8821439aec3279dd9572bf6c8c110567
  criteria e73f0ec970096c1c807e629c9074593d
  insRule 8e138eb267aaea8894463ffcac20987b
  label 662cde7fa163f597123a90cbed5ff308
  targets 3a1999badf380f23aac258a2bf76a66a
574baebeb07ec08f39a9e8555fc8e570
  $w$sgo10 ::
    GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Int a1
    -> Data.Map.Base.Map GHC.Types.Int a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
eff0e8f3d18d4156750e5fc027f6a2f1
  $waddRuleToChainAtPos ::
    Types.Rule
    -> Types.Chain -> GHC.Prim.Int# -> [Types.GenRule Types.Criteria]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: Types.Chain
                   ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        []
                        -> GHC.Base.++
                             @ (Types.GenRule Types.Criteria)
                             (GHC.Types.[] @ Types.Rule)
                             (GHC.Types.: @ Types.Rule w (GHC.Types.[] @ Types.Rule))
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([Types.Rule], [Types.Rule])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ Types.Rule
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.:
                                     @ Types.Rule
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (GHC.Types.:
                                     @ Types.Rule
                                     w
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs'' }))
                             1
                             -> GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.: @ Types.Rule ipv (GHC.Types.[] @ Types.Rule))
                                  (GHC.Types.: @ Types.Rule w ipv1) } }
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (Types.GenRule Types.Criteria)
                        (GHC.Types.[] @ Types.Rule)
                        (GHC.Types.: @ Types.Rule w w1) }) -}
7fe3d09f6de31edf33404101890970e5
  $wfindPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: GHC.Types.Int
                   w2 :: Types.IdNameChain ->
                 (# w1,
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case RuleAdding.$wpoly_go10
                           @ (GHC.Base.String, Types.Chain)
                           ww1
                           w2 of wild {
                      GHC.Base.Nothing
                      -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Int of {}
                      GHC.Base.Just x
                      -> case x of wild1 { (,) ds c ->
                         case GHC.Base.map
                                @ (Types.GenRule Types.Criteria)
                                @ GHC.Types.Int
                                (RuleAdding.scoreRules w)
                                c of wild2 {
                           [] -> RuleAdding.findPointCut1
                           : ds1 ds2
                           -> case Data.OldList.findIndex
                                     @ GHC.Types.Int
                                     (GHC.Classes.eqInt
                                        (GHC.List.strictMaximum
                                           @ GHC.Types.Int
                                           GHC.Classes.$fOrdInt
                                           wild2))
                                     wild2 of wild3 {
                                GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                                GHC.Base.Just x1 -> x1 } } } } } #)) -}
1c8d97bb4af95ee56ab398f5bbb65144
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Types.Int a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
62f95b9caea73aa21c93176d46bceb97
  $wscoreCriteria ::
    Types.Criteria -> Types.Criteria -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
48b668cc095124513302cf856ba4612d
  $wscoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
da843c5cba52940bed4aa1ab0b8bae6a
  $wscoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
425c82516dcc0ca4a48da00a40545ad1
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Types.IO Types.IdNameChain
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <Types.Rule>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
451dcb21d8ce38fe7c2347e5bc25df19
  addRuleToChain1 ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: (\ s :: GHC.Base.String
                   r :: Types.Rule
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 let {
                   ds :: (Data.Map.Base.Map
                            GHC.Types.Int (GHC.Base.String, Types.Chain),
                          Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain))
                   = case Data.Map.Base.$wpoly_go2
                            @ GHC.Types.Int
                            @ (GHC.Base.String, Types.Chain)
                            (\ ds1 :: GHC.Types.Int
                               x :: (GHC.Base.String, Types.Chain)[OneShot] ->
                             case x of wild { (,) s' ds2 -> GHC.Base.eqString s' s })
                            n of ww { (#,#) ww6 ww7 ->
                     (ww6, ww7) }
                 } in
                 let {
                   change :: Data.Map.Base.Map
                               GHC.Types.Int (GHC.Base.String, Types.Chain)
                   = case ds of wild { (,) change1 noChange -> change1 }
                 } in
                 case RuleAdding.addRuleToChain2
                        r
                        (RuleAdding.addRuleToChain_go10
                           (GHC.List.badHead @ GHC.Types.Int)
                           change)
                        n
                        n
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case Data.Map.Base.map
                           @ (GHC.Base.String, Types.Chain)
                           @ (GHC.Base.String, Types.Chain)
                           @ GHC.Types.Int
                           (\ ds2 :: (GHC.Base.String, Types.Chain) ->
                            case ds2 of wild { (,) s' c ->
                            (s', RuleAdding.addRuleToChainAtPos r c ipv1) })
                           change of wild {
                      Data.Map.Base.Bin ipv2 ipv3 ipv4 ipv5 ipv6
                      -> case ds of wild1 { (,) change1 noChange ->
                         case noChange of wild2 {
                           Data.Map.Base.Bin ipv7 ipv8 ipv9 ipv10 ipv11
                           -> Data.Map.Base.union_$shedgeUnion
                                @ GHC.Types.Int
                                @ (GHC.Base.String, Types.Chain)
                                GHC.Classes.$fOrdInt
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                ipv2
                                ipv3
                                ipv4
                                ipv5
                                ipv6
                                ipv7
                                ipv8
                                ipv9
                                ipv10
                                ipv11
                           Data.Map.Base.Tip -> wild } }
                      Data.Map.Base.Tip
                      -> case ds of wild1 { (,) change1 noChange -> noChange } } #) }) -}
6042194548e23052fa637f9e7f5fcef7
  addRuleToChain2 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U> -}
5138fa4253226793301f370800c6fe9f
  addRuleToChainAtPos ::
    Types.Rule -> Types.Chain -> GHC.Types.Int -> Types.Chain
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: Types.Chain w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 RuleAdding.$waddRuleToChainAtPos w w1 ww1 }) -}
65a77856319511dfbff527d26feccaea
  addRuleToChain_go10 ::
    GHC.Types.Int
    -> Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain)
    -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U> -}
a8c94f5cdb4d368547f55354ced4abb9
  addRules ::
    [Types.Instruction]
    -> Types.IdNameChain -> GHC.Types.IO Types.IdNameChain
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRules1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
4908fa9eda9cf72b333a0eea40428c5d
  addRules1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
8f9eae680175382d6a468443a7269503
  findBestPointCut ::
    Types.Rule
    -> GHC.Types.Int -> Types.IdNameChain -> GHC.Types.IO GHC.Types.Int
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.findBestPointCut1
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
de98bba3e656ea51eee89507210a7ad3
  findBestPointCut' ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Types.IO GHC.Types.Int
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain2
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
6c147e785ee11bb7f660cc92300dfb9a
  findBestPointCut1 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ r :: Types.Rule
                   i :: GHC.Types.Int
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 RuleAdding.addRuleToChain2 r i n n eta) -}
dc20261071df653a49929367389cddf7
  findPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: GHC.Types.Int w2 :: Types.IdNameChain ->
                 case RuleAdding.$wfindPointCut w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
93aa8eca446235fa4fa16c54bcfedf0d
  findPointCut1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
7ef298b8428aeb7552d68a8d35a7600e
  instructionsToAddAtPos ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Types.IO [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.instructionsToAddAtPos1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <[(Types.Rule, GHC.Base.String, GHC.Types.Int)]>_R)) -}
7dcbc21b5b0be8fd26583f6aa95791d1
  instructionsToAddAtPos1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(Types.Rule, GHC.Base.String, GHC.Types.Int)] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
d157374e39c64bd204cbd7d3b7da04ad
  scm :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 100000) -}
330369cec4d90045bba1069b4e66ca1e
  scoreCriteria :: Types.Criteria -> Types.Criteria -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Criteria w1 :: Types.Criteria ->
                 case RuleAdding.$wscoreCriteria w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
359c22f1915ef40a3e61895d253ca714
  scoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Criteria] w1 :: [Types.Criteria] ->
                 case RuleAdding.$wscoreCriteriaList w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
4e1a1c91922f5be38f18e12d6f9ff14c
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2,
     Strictness: <S(SSL),1*U(1*U,1*U,A)><S(SLL),1*U(1*U,U,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 case RuleAdding.$wscoreCriteriaList ww1 ww5 of ww8 { DEFAULT ->
                 case RuleAdding.$wscoreTargets ww2 ww6 of ww9 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.+# ww8 ww9) } } } }) -}
920e07e5691b657bb3a4a89557bbe34b
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Target] w1 :: [Types.Target] ->
                 case RuleAdding.$wscoreTargets w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

