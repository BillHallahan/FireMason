
==================== FINAL INTERFACE ====================
2016-08-10 02:27:15.224142 UTC

interface main@main:RuleAdding 7103
  interface hash: 3588e0da42af52a6de9420d7e957f608
  ABI hash: 3e781a8a78d86d75e2d9552c6fca1a86
  export-list hash: c601277d6f45448f107a8f0e2e533ab9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRuleToChainAtPos
  RuleAdding.addRules
  RuleAdding.findBestPointCut
  RuleAdding.findBestPointCut'
  RuleAdding.findPointCut
  RuleAdding.instructionsToAddAtPos
  RuleAdding.scm
  RuleAdding.scoreCriteria
  RuleAdding.scoreCriteriaList
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: ChainsToSMT2 NameIdChain ParserHelp SMT Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Either e8724afd65fd432cfe9a54014f5f762d
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Ord 66127262fc269c8a61d7d87ba94bd4d2
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:Debug.Trace 6660afb6094d69397ea084364da8f950
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Real 1281efa9baf803bc7859d7efb89a38b3
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  base-4.8.2.0:System.IO 0899686bfc1d9ef72dff3de85e99862a
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base c921f79770a215e3f4c72c747cb6a28a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  ChainsToSMT2 28a958e0c48e26b196f2f6d285ff4e06
  exports: 116a23a42f5b28b393be927d1dd4514a
  convertChainsCheckSMT bb358ff59f8d2f868c3d78f8f0d557fa
  toSMT 7f63ff953314f471b1268a21248ac49f
import  -/  NameIdChain cd667049268bb2a1da8bd1324af4ecdb
  exports: 9ff82ba4aa39e1eb044c914702771b51
  idsWithName 5f09dc73b2ebb6e2f0a51587e0c87dd6
  increaseIndexes 713a6c2cf01e90b6ba5504b79251844b
  maxId 55c158389232b1277d245652b8cbab33
import  -/  SMT 1e2f1cd31ff32fe5acdf5504946c9bf3
  exports: bdc12074afdd6621e65d5072296d84d4
  checkSat 2d6ef5dc9b7b794d33b49d559783a5e5
  printSMTFunc1 6dadeb978a815eb5e980d7f89ff0b9c4
  printSMTFunc2 243e9871a211ea0f88b6b96fd7bf09ab
  printSMTFunc3 df48ad66d0f6827890c4de0dc9297b70
import  -/  Types 40fb64e93a610ce366a87f59754aaa8a
  exports: c5dd2fdaee99eeddeac00fda32d7be65
  Chain fdabad52d3e9945bd1fdc190af510a61
  Criteria b2ef1250414b0e6b2678227af251a7bc
  IdNameChain bf1c002cd2b335785f24574ffacbdbc8
  Instruction e117c4b6bc059e4f4046a003b87006df
  Not 4c108d6b8d28d69ef551773a5b7fd604
  Port 7fac22dbdd5e01d480bf117c22f09521
  Protocol fe7579db3bf10f763094c06a95c77cb8
  Rule 9482d4c7de3ec7cf655ed4494ac94a4c
  Rule 709e69aef0024dfd7fca01b519b8602d
  Target 96fab3e40e346c4a445f4966317f4361
  chainName 3e07f02bf6df42dabd65c0a1ca57407e
  criteria 688a2ae712a56f16d00b8fab86921db7
  insRule e1211389d67a08d554e2ed04cedf1020
  label 4cdd83b4363dab9de270c2fbfa3bd4b9
  targets a8abd9dc3ae8891ba9d35052418c63f0
574baebeb07ec08f39a9e8555fc8e570
  $w$sgo10 ::
    GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Int a1
    -> Data.Map.Base.Map GHC.Types.Int a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
37677c1ea0555a8ba54aeebea65c73bb
  $waddRuleToChainAtPos ::
    Types.Rule
    -> Types.Chain -> GHC.Prim.Int# -> [Types.GenRule Types.Criteria]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: Types.Chain
                   ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        []
                        -> GHC.Base.++
                             @ (Types.GenRule Types.Criteria)
                             (GHC.Types.[] @ Types.Rule)
                             (GHC.Types.: @ Types.Rule w (GHC.Types.[] @ Types.Rule))
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([Types.Rule], [Types.Rule])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ Types.Rule
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.:
                                     @ Types.Rule
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (GHC.Types.:
                                     @ Types.Rule
                                     w
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs'' }))
                             1
                             -> GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.: @ Types.Rule ipv (GHC.Types.[] @ Types.Rule))
                                  (GHC.Types.: @ Types.Rule w ipv1) } }
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (Types.GenRule Types.Criteria)
                        (GHC.Types.[] @ Types.Rule)
                        (GHC.Types.: @ Types.Rule w w1) }) -}
212e1db3c2c6ab860c469f2a939aa5d9
  $wfindPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: GHC.Types.Int
                   w2 :: Types.IdNameChain ->
                 (# w1,
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case RuleAdding.$wpoly_go10
                           @ (GHC.Base.String, Types.Chain)
                           ww1
                           w2 of wild {
                      GHC.Base.Nothing
                      -> case Data.Maybe.fromJust1 ret_ty GHC.Types.Int of {}
                      GHC.Base.Just x
                      -> case x of wild1 { (,) ds c ->
                         case GHC.Base.map
                                @ (Types.GenRule Types.Criteria)
                                @ GHC.Types.Int
                                (RuleAdding.scoreRules w)
                                c of wild2 {
                           [] -> RuleAdding.findPointCut1
                           : ds1 ds2
                           -> case Data.OldList.findIndex
                                     @ GHC.Types.Int
                                     (GHC.Classes.eqInt
                                        (GHC.List.strictMaximum
                                           @ GHC.Types.Int
                                           GHC.Classes.$fOrdInt
                                           wild2))
                                     wild2 of wild3 {
                                GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                                GHC.Base.Just x1 -> x1 } } } } } #)) -}
1c8d97bb4af95ee56ab398f5bbb65144
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Types.Int a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
bad47acfd1c6e1320a711ed19a787851
  $wscoreCriteria ::
    Types.Criteria -> Types.Criteria -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
dacf3b8e6d0fd75b27fb7da21d2f1416
  $wscoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Prim.Int#
  {- Arity: 2, Strictness: <S,1*U><S,1*U>, Inline: [0] -}
da843c5cba52940bed4aa1ab0b8bae6a
  $wscoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>, Inline: [0] -}
cc047691e9f0733df5fa9514fead1106
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Types.IO Types.IdNameChain
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <Types.Rule>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
36cb27bf847c3ea93c7e42c23dd1895b
  addRuleToChain1 ::
    GHC.Base.String
    -> Types.Rule
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 4, Strictness: <L,U><L,U(U,U,U(U))><L,U><L,U>,
     Unfolding: (\ s :: GHC.Base.String
                   r :: Types.Rule
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 let {
                   ds :: (Data.Map.Base.Map
                            GHC.Types.Int (GHC.Base.String, Types.Chain),
                          Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain))
                   = case Data.Map.Base.$wpoly_go2
                            @ GHC.Types.Int
                            @ (GHC.Base.String, Types.Chain)
                            (\ ds1 :: GHC.Types.Int
                               x :: (GHC.Base.String, Types.Chain)[OneShot] ->
                             case x of wild { (,) s' ds2 -> GHC.Base.eqString s' s })
                            n of ww { (#,#) ww6 ww7 ->
                     (ww6, ww7) }
                 } in
                 let {
                   change :: Data.Map.Base.Map
                               GHC.Types.Int (GHC.Base.String, Types.Chain)
                   = case ds of wild { (,) change1 noChange -> change1 }
                 } in
                 case RuleAdding.addRuleToChain2
                        r
                        (RuleAdding.addRuleToChain_go10
                           (GHC.List.badHead @ GHC.Types.Int)
                           change)
                        n
                        n
                        eta of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    case Data.Map.Base.map
                           @ (GHC.Base.String, Types.Chain)
                           @ (GHC.Base.String, Types.Chain)
                           @ GHC.Types.Int
                           (\ ds2 :: (GHC.Base.String, Types.Chain) ->
                            case ds2 of wild { (,) s' c ->
                            (s', RuleAdding.addRuleToChainAtPos r c ipv1) })
                           change of wild {
                      Data.Map.Base.Bin ipv2 ipv3 ipv4 ipv5 ipv6
                      -> case ds of wild1 { (,) change1 noChange ->
                         case noChange of wild2 {
                           Data.Map.Base.Bin ipv7 ipv8 ipv9 ipv10 ipv11
                           -> Data.Map.Base.union_$shedgeUnion
                                @ GHC.Types.Int
                                @ (GHC.Base.String, Types.Chain)
                                GHC.Classes.$fOrdInt
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                (Data.Map.Base.NothingS @ GHC.Types.Int)
                                ipv2
                                ipv3
                                ipv4
                                ipv5
                                ipv6
                                ipv7
                                ipv8
                                ipv9
                                ipv10
                                ipv11
                           Data.Map.Base.Tip -> wild } }
                      Data.Map.Base.Tip
                      -> case ds of wild1 { (,) change1 noChange -> noChange } } #) }) -}
6f899f39555281632d9c8938fe33df7a
  addRuleToChain2 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U> -}
f5b93cf66e3426580bf745e59c7f6a04
  addRuleToChainAtPos ::
    Types.Rule -> Types.Chain -> GHC.Types.Int -> Types.Chain
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: Types.Chain w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 RuleAdding.$waddRuleToChainAtPos w w1 ww1 }) -}
4046fccb84d792a517da89cd47c072aa
  addRuleToChain_go10 ::
    GHC.Types.Int
    -> Data.Map.Base.Map GHC.Types.Int (GHC.Base.String, Types.Chain)
    -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(U)><S,1*U> -}
5e5b41f23b3c2da14ea2b76ef6756e19
  addRules ::
    [Types.Instruction]
    -> Types.IdNameChain -> GHC.Types.IO Types.IdNameChain
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRules1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Types.IdNameChain>_R)) -}
7d95abf5fae83057d7c1181780063bfa
  addRules1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Types.IdNameChain #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
3af573a528a8be16091d20b3a1cdad88
  findBestPointCut ::
    Types.Rule
    -> GHC.Types.Int -> Types.IdNameChain -> GHC.Types.IO GHC.Types.Int
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.findBestPointCut1
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
0936f0f9a76a0a14c476facc9ee35b00
  findBestPointCut' ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> Types.IdNameChain
    -> GHC.Types.IO GHC.Types.Int
  {- Arity: 5, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.addRuleToChain2
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
f46689d17c5be6a75ee52b38a93ddc8a
  findBestPointCut1 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 4, Strictness: <L,U(U,U,U(U))><L,U(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ r :: Types.Rule
                   i :: GHC.Types.Int
                   n :: Types.IdNameChain
                   eta :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 RuleAdding.addRuleToChain2 r i n n eta) -}
3c0afaf3ce87f62ecb0536902c80406a
  findPointCut ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <L,U(U,U,A)><L,U(U)><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: GHC.Types.Int w2 :: Types.IdNameChain ->
                 case RuleAdding.$wfindPointCut w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
93aa8eca446235fa4fa16c54bcfedf0d
  findPointCut1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
bae7f7cf632feaed3d22df5ce9ce3192
  instructionsToAddAtPos ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Types.IO [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.instructionsToAddAtPos1
                  `cast`
                (<[Types.Instruction]>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0]
                               <[(Types.Rule, GHC.Base.String, GHC.Types.Int)]>_R)) -}
f6994e0f75f741b9161921d88361ea5d
  instructionsToAddAtPos1 ::
    [Types.Instruction]
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          [(Types.Rule, GHC.Base.String, GHC.Types.Int)] #)
  {- Arity: 3, Strictness: <S,1*U><L,U><L,U> -}
d157374e39c64bd204cbd7d3b7da04ad
  scm :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 100000) -}
177a927e4f32abbebe3553ba3d565732
  scoreCriteria :: Types.Criteria -> Types.Criteria -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Criteria w1 :: Types.Criteria ->
                 case RuleAdding.$wscoreCriteria w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
aedb372811c43ca00e55b90ec3812815
  scoreCriteriaList ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <S,1*U><S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Criteria] w1 :: [Types.Criteria] ->
                 case RuleAdding.$wscoreCriteriaList w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
c24e83fb10011a4f8954a9698073f92c
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2,
     Strictness: <S(SSL),1*U(1*U,1*U,A)><S(SLL),1*U(1*U,U,A)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 case RuleAdding.$wscoreCriteriaList ww1 ww5 of ww8 { DEFAULT ->
                 case RuleAdding.$wscoreTargets ww2 ww6 of ww9 { DEFAULT ->
                 GHC.Types.I# (GHC.Prim.+# ww8 ww9) } } } }) -}
920e07e5691b657bb3a4a89557bbe34b
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: [Types.Target] w1 :: [Types.Target] ->
                 case RuleAdding.$wscoreTargets w w1 of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

