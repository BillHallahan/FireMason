
==================== FINAL INTERFACE ====================
2016-08-01 01:11:01.092944 UTC

interface main@main:RuleAdding 7103
  interface hash: 9d666b0f59db7aeccc5cdddad67616c7
  ABI hash: 9a49255ef38616689626749461c17917
  export-list hash: 2ff32032c83227163fe6f27f4ef7b0b9
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRules
  RuleAdding.findPointCut
  RuleAdding.scoreCriteria
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0* containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  Types 5bdb5f68fbf0a790a0e0d2c54cb48e55
  exports: 896880101ac839295e98cf60f693e54d
  Chain 3ef74e3624b38c4fea8d8b46f9f858c1
  Criteria 61b02b594ef3ae008da99e5e81a331ad
  Instruction 619fb196a55d168a4d05bed804283f35
  NameIdChain 0c4d7203db78c85c32c32bf62bf137e7
  Rule 4d5f5396220a571836d37b123a90c312
  Rule af528c7a21c4e5e2b22c75c0fa307886
  Target 96fab3e40e346c4a445f4966317f4361
  chainName 8821439aec3279dd9572bf6c8c110567
  insRule 8e138eb267aaea8894463ffcac20987b
  name 195a051a49795dd764e5754ad1f772ce
dd634c4577f0182344bba02d969c97f8
  $waddRuleToChain ::
    GHC.Base.String -> [Types.NameIdChain] -> [Types.NameIdChain]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ w :: GHC.Base.String w1 :: [Types.NameIdChain] ->
                 letrec {
                   $wgo :: [Types.NameIdChain]
                           -> (# [Types.NameIdChain], [Types.NameIdChain] #)
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ w2 :: [Types.NameIdChain] ->
                     case w2 of wild {
                       []
                       -> (# GHC.Types.[] @ Types.NameIdChain,
                             GHC.Types.[] @ Types.NameIdChain #)
                       : y ys
                       -> case y of wild1 { Types.NameIdChain ds1 ds2 ds3 ->
                          let {
                            w3 :: ([Types.NameIdChain], [Types.NameIdChain])
                            = case $wgo ys of ww { (#,#) ww1 ww2 -> (ww1, ww2) }
                          } in
                          case GHC.Base.eqString ds1 w of wild2 {
                            GHC.Types.False
                            -> (# case w3 of wild3 { (,) ts fs -> ts },
                                  GHC.Types.:
                                    @ Types.NameIdChain
                                    wild1
                                    (case w3 of wild3 { (,) ts fs -> fs }) #)
                            GHC.Types.True
                            -> (# GHC.Types.:
                                    @ Types.NameIdChain
                                    wild1
                                    (case w3 of wild3 { (,) ts fs -> ts }),
                                  case w3 of wild3 { (,) ts fs -> fs } #) } } }
                 } in
                 case $wgo w1 of ww { (#,#) ww1 ww2 ->
                 GHC.Base.++ @ Types.NameIdChain ww1 ww2 }) -}
d5bb99c40d45e5b58debdc5ac37087ed
  $wscoreRules ::
    [Types.Criteria]
    -> [Types.Target]
    -> [Types.Criteria]
    -> [Types.Target]
    -> GHC.Types.Int
  {- Arity: 4, Strictness: <B,1*U><B,1*U><B,U><B,U>b, Inline: [0] -}
d159a16aa1fdac230525a2c7ef120883
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule -> [Types.NameIdChain] -> [Types.NameIdChain]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Base.String
                   w1 :: Types.Rule
                   w2 :: [Types.NameIdChain] ->
                 RuleAdding.$waddRuleToChain w w2) -}
912de07102e93d8e6b000b02750d4de4
  addRules ::
    [Types.Instruction] -> [Types.NameIdChain] -> [Types.NameIdChain]
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
e8c4d7a913ca7e9d04ef9cf78b627d21
  findPointCut :: Types.Instruction -> Types.Chain -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ i :: Types.Instruction c :: Types.Chain ->
                 let {
                   scores :: [GHC.Types.Int]
                   = GHC.Base.map
                       @ (Types.GenRule Types.Criteria)
                       @ GHC.Types.Int
                       (\ ds :: Types.GenRule Types.Criteria ->
                        case i of wild {
                          Types.ToChainNamed ds1 ds2
                          -> case ds2 of wild1 { Types.Rule c1 t i1 ->
                             case ds of wild2 { Types.Rule c' t' i' ->
                             RuleAdding.scoreCriteria c1 c' } }
                          Types.NoInstruction ds1
                          -> case ds1 of wild1 { Types.Rule c1 t i1 ->
                             case ds of wild2 { Types.Rule c' t' i' ->
                             RuleAdding.scoreCriteria c1 c' } } })
                       c
                 } in
                 case Data.OldList.findIndex
                        @ GHC.Types.Int
                        (GHC.Classes.eqInt
                           (GHC.List.strictMaximum
                              @ GHC.Types.Int
                              GHC.Classes.$fOrdInt
                              scores))
                        scores of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                   GHC.Base.Just x -> x }) -}
f609981890bfb5584e3f1c6699388293
  scoreCriteria ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
7f6372134e523485ce3cd2a2ed2ffdbb
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U(1*U,1*U,A)><B,1*U(U,U,A)>b,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 case w1 of ww4 { Types.Rule ww5 ww6 ww7 ->
                 RuleAdding.$wscoreRules ww1 ww2 ww5 ww6 } }) -}
e613cb7727aedb776158a5590d14f56d
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

