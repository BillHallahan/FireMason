
==================== FINAL INTERFACE ====================
2016-08-02 04:07:39.010961 UTC

interface main@main:RuleAdding 7103
  interface hash: eda70770f0ea101eb9827e71a21c5e68
  ABI hash: 04d6756bea87091b958aadb14442316e
  export-list hash: eb7d3d9ba91c4dd200996c613845cb34
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 97344007ccf84cb5abb832d455d4804c
  sig of: Nothing
  used TH splices: False
  where
exports:
  RuleAdding.addRuleToChain
  RuleAdding.addRuleToChainAtPos
  RuleAdding.addRules
  RuleAdding.findBestPointCut
  RuleAdding.findPointCut
  RuleAdding.scoreCriteria
  RuleAdding.scoreRules
  RuleAdding.scoreTargets
module dependencies: ChainsToSMT2 NameIdChain ParserHelp SMT Types
package dependencies: array-0.5.1.0@array_67iodizgJQIIxYVTp4emlA
                      base-4.8.2.0 containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU
                      deepseq-1.4.1.1@deeps_6vMKxt5sPFR0XsbRWvvq59 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 process-1.2.3.0@proce_52AgREEfSrnJLlkGV9YZZJ
                      split-0.2.3.1@split_2IxbOPGrTSq7kFrJA7odmE
                      unix-2.7.1.0@unix_KZL8h98IqDM57kQSPo1mKx
orphans: base-4.8.2.0:GHC.Base base-4.8.2.0:GHC.Float
family instance modules: base-4.8.2.0:Control.Applicative
                         base-4.8.2.0:Data.Either base-4.8.2.0:Data.Functor.Identity
                         base-4.8.2.0:Data.Monoid base-4.8.2.0:Data.Type.Equality
                         base-4.8.2.0:Data.Void base-4.8.2.0:GHC.Exts
                         base-4.8.2.0:GHC.Generics
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base
                         containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Set.Base
import  -/  base-4.8.2.0:Data.Foldable 2ce969969ad5231eb40bd713f94f05ad
import  -/  base-4.8.2.0:Data.List 3f0782c8d4bf50eecefcd5ea1798aac8
import  -/  base-4.8.2.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.2.0:Data.OldList d8fd80b0e14aa085ce6219cd89dad356
import  -/  base-4.8.2.0:Data.Tuple 012ad951a59a9d85fe1de36a2f012986
import  -/  base-4.8.2.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.2.0:GHC.List 0c736920522bbd14b770342776012ab6
import  -/  base-4.8.2.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.2.0:GHC.Show 0e1d8380a8fb0cfb07ebeda3b70cbf38
import  -/  base-4.8.2.0:Prelude 694dcaf039efe62df1c44834e2dbd2fb
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map bf7758bd12b23a367777a33fd16e39de
import  -/  containers-0.5.6.2@conta_2C3ZI8RgPO2LBMidXKTvIU:Data.Map.Base c921f79770a215e3f4c72c747cb6a28a
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  ChainsToSMT2 f8a3b6a9828f9f09691d308a5dcd3512
  exports: 116a23a42f5b28b393be927d1dd4514a
  convertChainsCheckSMT c51d9ef0a90d8f04bbc35f45e4fca586
  toSMT 28d52cdacd14500ac52ea8e24ce55180
import  -/  NameIdChain 6195fb4e36abae14a6e3c1b0cdf0dceb
  exports: 587c46b8c3c4b153dcd3ee0ec1ca5dda
  increaseIndexes 3c5c2d5d713fd32182b476b32fdc3871
  maxId 3699a27dcd3f3c76a0209ee923158975
import  -/  SMT ad5cc286b4b8f93c12204fc2a9edd888
  exports: a94561e4d0f7927a3335aa58f6911b1b
  checkSat d00f4563ef5e93aab3e28f39e86ea9fc
import  -/  Types 1fa0e3470a993525fa413846f16fe57d
  exports: 832ead5b2ba1dd5b901ba211c8588da6
  Chain c5bf08697c645273b4267b6433d80fe6
  Criteria 61b02b594ef3ae008da99e5e81a331ad
  IdNameChain 1e051c17933667c2588a98b7f103a723
  Instruction ddd707d0e2401532735e3e59e68d0246
  Rule ecedd5d7e4257206aaf2f27fe228d521
  Rule ca1c9eeef684868b92691d9b4ce33d9e
  Target 96fab3e40e346c4a445f4966317f4361
  chainName 4cbdff5dcf4e2d494fca04b66b43fc5d
  criteria 5d1b02c3d1eeb9fa39cca95ac47b07ea
  insRule 49bd2294319d1e6a6a9a8bcc8f69666b
574baebeb07ec08f39a9e8555fc8e570
  $w$sgo10 ::
    GHC.Prim.Int#
    -> a1
    -> Data.Map.Base.Map GHC.Types.Int a1
    -> Data.Map.Base.Map GHC.Types.Int a1
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0] -}
c971e91b4a8be1a7a3ecaab8e4810498
  $waddRuleToChainAtPos ::
    Types.Rule
    -> Types.Chain -> GHC.Prim.Int# -> [Types.GenRule Types.Criteria]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ w :: Types.Rule
                   w1 :: Types.Chain
                   ww :: GHC.Prim.Int# ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 0) of wild1 {
                   GHC.Types.False
                   -> case w1 of wild {
                        []
                        -> GHC.Base.++
                             @ (Types.GenRule Types.Criteria)
                             (GHC.Types.[] @ Types.Rule)
                             (GHC.Types.: @ Types.Rule w (GHC.Types.[] @ Types.Rule))
                        : ipv ipv1
                        -> case ww of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([Types.Rule], [Types.Rule])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ Types.Rule
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.:
                                     @ Types.Rule
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (GHC.Types.:
                                     @ Types.Rule
                                     w
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs'' }))
                             1
                             -> GHC.Base.++
                                  @ (Types.GenRule Types.Criteria)
                                  (GHC.Types.: @ Types.Rule ipv (GHC.Types.[] @ Types.Rule))
                                  (GHC.Types.: @ Types.Rule w ipv1) } }
                   GHC.Types.True
                   -> GHC.Base.++
                        @ (Types.GenRule Types.Criteria)
                        (GHC.Types.[] @ Types.Rule)
                        (GHC.Types.: @ Types.Rule w w1) }) -}
1c8d97bb4af95ee56ab398f5bbb65144
  $wpoly_go10 ::
    GHC.Prim.Int#
    -> Data.Map.Base.Map GHC.Types.Int a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
d5bb99c40d45e5b58debdc5ac37087ed
  $wscoreRules ::
    [Types.Criteria]
    -> [Types.Target]
    -> [Types.Criteria]
    -> [Types.Target]
    -> GHC.Types.Int
  {- Arity: 4, Strictness: <B,1*U><B,1*U><B,U><B,U>b, Inline: [0] -}
c90600034470d3cb91327157d99988a8
  addRuleToChain ::
    GHC.Base.String
    -> Types.Rule -> Types.IdNameChain -> Types.IdNameChain
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>,
     Unfolding: (\ s :: GHC.Base.String
                   r :: Types.Rule
                   n :: Types.IdNameChain ->
                 case Data.Map.Base.$wpoly_go2
                        @ GHC.Types.Int
                        @ (GHC.Base.String, Types.Chain)
                        (\ ds :: GHC.Types.Int
                           x :: (GHC.Base.String, Types.Chain)[OneShot] ->
                         case x of wild { (,) s' ds1 -> GHC.Base.eqString s' s })
                        n of ww { (#,#) ww6 ww7 ->
                 case Data.Map.Base.map
                        @ (GHC.Base.String, [Types.Rule])
                        @ (GHC.Base.String, [Types.Rule])
                        @ GHC.Types.Int
                        (\ ds :: (GHC.Base.String, [Types.Rule]) ->
                         case ds of wild { (,) s' c -> (s', GHC.Types.: @ Types.Rule r c) })
                        ww6 of wild {
                   Data.Map.Base.Bin ipv ipv1 ipv2 ipv3 ipv4
                   -> case ww7 of wild1 {
                        Data.Map.Base.Bin ipv5 ipv6 ipv7 ipv8 ipv9
                        -> Data.Map.Base.union_$shedgeUnion
                             @ GHC.Types.Int
                             @ (GHC.Base.String, Types.Chain)
                             GHC.Classes.$fOrdInt
                             (Data.Map.Base.NothingS @ GHC.Types.Int)
                             (Data.Map.Base.NothingS @ GHC.Types.Int)
                             ipv
                             ipv1
                             ipv2
                             ipv3
                             ipv4
                             ipv5
                             ipv6
                             ipv7
                             ipv8
                             ipv9
                        Data.Map.Base.Tip -> wild }
                   Data.Map.Base.Tip -> ww7 } }) -}
68216ce7aec7d1454ec9212fab539b28
  addRuleToChainAtPos ::
    Types.Rule -> Types.Chain -> GHC.Types.Int -> Types.Chain
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Types.Rule w1 :: Types.Chain w2 :: GHC.Types.Int ->
                 case w2 of ww { GHC.Types.I# ww1 ->
                 RuleAdding.$waddRuleToChainAtPos w w1 ww1 }) -}
79c3c401fc48a1709d532b65991a23ec
  addRules ::
    [Types.Instruction] -> Types.IdNameChain -> Types.IdNameChain
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
6c497fa0c42b654546ca61bddbdbc8ac
  findBestPointCut ::
    Types.Rule
    -> GHC.Types.Int -> Types.IdNameChain -> GHC.Types.IO GHC.Types.Int
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                RuleAdding.findBestPointCut1
                  `cast`
                (<Types.Rule>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R <Types.IdNameChain>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Types.Int>_R)) -}
f27931956cf303a52aa49a064e66fdb4
  findBestPointCut1 ::
    Types.Rule
    -> GHC.Types.Int
    -> Types.IdNameChain
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Int #)
  {- Arity: 4, Strictness: <L,U(U,U)><L,U(U)><L,U><L,U> -}
50bb685405d79e0371f87c27fc90650a
  findPointCut :: Types.Rule -> Types.Chain -> GHC.Types.Int
  {- Arity: 2, Strictness: <L,U(U,U)><S,1*U>,
     Unfolding: (\ r :: Types.Rule c :: Types.Chain ->
                 let {
                   scores :: [GHC.Types.Int]
                   = GHC.Base.map
                       @ (Types.GenRule Types.Criteria)
                       @ GHC.Types.Int
                       (RuleAdding.scoreRules r)
                       c
                 } in
                 case Data.OldList.findIndex
                        @ GHC.Types.Int
                        (GHC.Classes.eqInt
                           (GHC.List.strictMaximum
                              @ GHC.Types.Int
                              GHC.Classes.$fOrdInt
                              scores))
                        scores of wild {
                   GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Types.Int
                   GHC.Base.Just x -> x }) -}
f609981890bfb5584e3f1c6699388293
  scoreCriteria ::
    [Types.Criteria] -> [Types.Criteria] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
1e2886ab6a114710cf16b886391507e5
  scoreRules :: Types.Rule -> Types.Rule -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U(1*U,1*U)><B,1*U(U,U)>b,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: Types.Rule ->
                 case w of ww { Types.Rule ww1 ww2 ->
                 case w1 of ww3 { Types.Rule ww4 ww5 ->
                 RuleAdding.$wscoreRules ww1 ww2 ww4 ww5 } }) -}
e613cb7727aedb776158a5590d14f56d
  scoreTargets :: [Types.Target] -> [Types.Target] -> GHC.Types.Int
  {- Arity: 2, Strictness: <B,1*U><B,U>b -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

