
==================== FINAL INTERFACE ====================
2016-09-05 18:31:06.402349 UTC

interface main@main:InstructionsToIptables 7102
  interface hash: f563bc2696e78ef0b6a0a926b29c2102
  ABI hash: 59c7b857b32ad7cecd5365d31666e113
  export-list hash: a47788424ebe0604624e93b60b4db587
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 12b31527c5068df65dd84ec1e013e42f
  sig of: Nothing
  used TH splices: False
  where
exports:
  InstructionsToIptables.addToIptables
  InstructionsToIptables.addToStringAtLine
  InstructionsToIptables.convertBoolFlags
  InstructionsToIptables.increaseLabelsAbove
  InstructionsToIptables.ToIptables{InstructionsToIptables.convert}
module dependencies: ConvertIptables ConvertIptablesPorts
                     IptablesTypes NameIdChain ParserHelp Types
package dependencies: MissingH-1.4.0.1@Missi_IUedVeBLJXI73qrXr2QSlw
                      array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ base-4.8.1.0
                      binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      case-insensitive-1.2.0.7@casei_I0T7EQSGXb8L7vKDNltr0H
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_7lZto9aEWI74IRoYrJM1Mm integer-gmp-1.0.0.0
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      regex-base-0.93.2@regex_2j0nR3pc4q24HZdEmShSMX
                      regex-posix-0.95.2@regex_6Fv9CTZU9JMB52PT4YRZTl
                      regex-compat-0.95.1@regex_LfevtAmd1jA93E87NZxMhh
                      semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I
                      split-0.2.3.1@split_Gd41gNkg1RrKgDS2jZ4Qe5
                      tagged-0.8.5@tagge_3xPBWzsl8Q1ImKSiXIolCi
                      text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010
                      tostring-0.2.1.1@tostr_9mRZFMcnuWXE8LUkKdBchW
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb
                      utf8-string-1.0.1.1@utf8s_HWC8Qen5AZrArJxFQJuE72
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_7lZto9aEWI74IRoYrJM1Mm:Data.Hashable.Generic
         main@main:Types
         regex-base-0.93.2@regex_2j0nR3pc4q24HZdEmShSMX:Text.Regex.Base.Context
         regex-posix-0.95.2@regex_6Fv9CTZU9JMB52PT4YRZTl:Text.Regex.Posix.ByteString
         regex-posix-0.95.2@regex_6Fv9CTZU9JMB52PT4YRZTl:Text.Regex.Posix.ByteString.Lazy
         regex-posix-0.95.2@regex_6Fv9CTZU9JMB52PT4YRZTl:Text.Regex.Posix.Sequence
         regex-posix-0.95.2@regex_6Fv9CTZU9JMB52PT4YRZTl:Text.Regex.Posix.String
         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text
         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Lazy
         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I:Data.List.NonEmpty
                         semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I:Data.Semigroup
                         tagged-0.8.5@tagge_3xPBWzsl8Q1ImKSiXIolCi:Data.Tagged
                         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text
                         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb:Data.HashMap.Base
                         unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb:Data.HashSet
import  -/  base-4.8.1.0:Data.Either bc9482e78cc431fce439b593377aa2e6
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.List 2a4f5f92892d432e7113f64cd9dcca53
import  -/  base-4.8.1.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.1.0:Data.OldList 21f46c368c20a00483b41333e53a55cb
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map 5e4cbf1ca2e6c8cfaecf2b4e95371357
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ConvertIptables 494bf2956f7e496c3d2de49a42875fc4
  exports: 3c7c649666962c3b5055861cfe511177
  convertScript' b551fc464a87c257aa1c5c599a5df5b0
import  -/  IptablesTypes 1ddf55e4553bf487a954b096da589c83
  exports: 4facbeac5c00aebe95278701f212ca21
  Append f94b47375030f76085f9b5fc6f03a2ca
  Command 4db06ce666ad374943ed57d7526293d3
  Insert 7ea17d1feb4563aaf2029349f7adb153
  comChainName f8707b38afb70baed6e837d50ab5d240
  command 02af45e5ca0458dec6f159cb5968f002
  fileline ae83a78289588cdfaf9420b2cf32ef20
import  -/  NameIdChain a65e4f5fe9a5ce7ad24c8183a8c914cc
  exports: b7ca760757feb67014dab71804222988
  IdNameChain 4f027086f050705bb246d9c6a97e7640
  lookupName 52d10d1431a9644fd7ad20ea37f9704f
import  -/  ParserHelp 2963101e3925b4b7443579b40db62a20
  exports: e7d64e37248c29bbbe084ee8d6572989
import  -/  Types 539e504492eacb62971b007037e46fe7
  exports: c4323cb63359ad0358876fdfba25ce76
  ACCEPT f6849424ce0242a5a46c02798e52f2f7
  BoolFlag c63d64d39616d4c6d93fef2910be9666
  Criteria 06ff56a5f2e549856785fb4c617e8e9a
  DROP a7dd49650f16feba32915c23abcd7cc2
  Destination bf0b836c6fdf993fa1278ff9317ec8f9
  Go 964278b56a8541509252d7c1625037b0
  Not a1696263dc6e755d9c9c7671f466a19e
  Port bc39a03feb63e6236cbedbfcdfc736da
  Protocol 1dd54f33dcea36ae94747ac76558d75a
  Rule 415230da6bf948321541e9ace77f4a95
  Rule f8cda0a866712c372c0afb7990e381cb
  Source 50b6d3438de54d28d9b9c458a48cedf9
  Target c2ab377181a680cc86186fdc5c3fa065
  flagsToStrings 1224c3ecee3a207a71464eb28a69df9d
  ifNotRemoveNot 733791607f4080eaceb6e1262b776379
  isNot 2c52a98c148bd326a8dcd24a1222e0fe
  stringsToFlags 035057b6fd3254f36db3f68f8c235237
d11493b2c722338ffeb5d3adfc289607
  $cconvert ::
    IptablesTypes.Command -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: IptablesTypes.Command w1 :: NameIdChain.IdNameChain ->
                 InstructionsToIptables.$w$cconvert w) -}
1e69622b366dcaf9f2936c2d3b21bdb7
  $cconvert1 :: GHC.Base.String
  {- Strictness: b -}
b4fb4abc806682546387a90526d2336d
  $cconvert2 ::
    [Types.Criteria] -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: [Types.Criteria] w1 :: NameIdChain.IdNameChain ->
                 InstructionsToIptables.$w$cconvert1 w) -}
fe5027465496af0d197dee3aa0d820b6
  $cconvert3 ::
    Types.Target -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 2,
     Strictness: <S,1*U><L,1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Types.Target n :: NameIdChain.IdNameChain ->
                 case ds of wild {
                   DEFAULT -> InstructionsToIptables.$cconvert7
                   Types.Go i ds1
                   -> case ds1 of wild1 { GHC.Types.I# ds2 ->
                      case ds2 of ds3 {
                        DEFAULT -> InstructionsToIptables.$cconvert7
                        0
                        -> case n of wild2 { NameIdChain.INC ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ds23 ds24 ->
                           case ds7 i of wild3 {
                             GHC.Base.Nothing -> InstructionsToIptables.$cconvert6
                             GHC.Base.Just ipv
                             -> GHC.CString.unpackAppendCString# "-j "# ipv } } } }
                   Types.ACCEPT -> InstructionsToIptables.$cconvert5
                   Types.DROP -> InstructionsToIptables.$cconvert4 }) -}
01865e6451b066518f84f512a7ba8c0e
  $cconvert4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-j DROP"#) -}
5389940f7c77d96680293af92ca3ea37
  $cconvert5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "-j ACCEPT"#) -}
b6cf90580e2d4200166dae5baa420b50
  $cconvert6 :: GHC.Base.String
  {- Strictness: b -}
da3ebc17c5929a9d19bcf3c0c0e8e6f4
  $cconvert7 :: GHC.Base.String
  {- Strictness: b -}
289c80f9c3405cfe3d75c53a11b9ad12
  $cconvert8 ::
    [Types.Target] -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 2,
     Strictness: <S,1*U><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ tx :: [Types.Target] n :: NameIdChain.IdNameChain ->
                 letrec {
                   go :: [Types.Target] -> [GHC.Types.Char]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ ds :: [Types.Target] ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ GHC.Types.Char
                       : y ys
                       -> GHC.Base.++
                            @ GHC.Types.Char
                            (InstructionsToIptables.$cconvert3 y n)
                            (go ys) }
                 } in
                 go tx) -}
1c2f8ba97cdeef9fee167d30fe8bb35c
  $cconvert9 ::
    Types.Rule -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 2,
     Strictness: <S(SLL),1*U(1*U,1*U,A)><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Types.Rule w1 :: NameIdChain.IdNameChain ->
                 case w of ww { Types.Rule ww1 ww2 ww3 ->
                 InstructionsToIptables.$w$cconvert2 ww1 ww2 w1 }) -}
492aba00e0dc7d678bdc3d4561da8583
  $fToIptablesCommand ::
    InstructionsToIptables.ToIptables IptablesTypes.Command
  DFunId[0]
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InstructionsToIptables.$cconvert
                  `cast`
                (Sym (InstructionsToIptables.NTCo:ToIptables[0]
                          <IptablesTypes.Command>_N)) -}
492aba00e0dc7d678bdc3d4561da8583
  $fToIptablesGenRule :: InstructionsToIptables.ToIptables Types.Rule
  DFunId[0]
  {- Arity: 2,
     Strictness: <S(SLL),1*U(1*U,1*U,A)><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InstructionsToIptables.$cconvert9
                  `cast`
                (Sym (InstructionsToIptables.NTCo:ToIptables[0] <Types.Rule>_N)) -}
492aba00e0dc7d678bdc3d4561da8583
  $fToIptablesTarget ::
    InstructionsToIptables.ToIptables Types.Target
  DFunId[0]
  {- Arity: 2,
     Strictness: <S,1*U><L,1*U(A,A,A,1*C1(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InstructionsToIptables.$cconvert3
                  `cast`
                (Sym (InstructionsToIptables.NTCo:ToIptables[0]
                          <Types.Target>_N)) -}
492aba00e0dc7d678bdc3d4561da8583
  $fToIptables[] :: InstructionsToIptables.ToIptables [Types.Target]
  DFunId[0]
  {- Arity: 2,
     Strictness: <S,1*U><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InstructionsToIptables.$cconvert8
                  `cast`
                (Sym (InstructionsToIptables.NTCo:ToIptables[0]
                          <[Types.Target]>_N)) -}
492aba00e0dc7d678bdc3d4561da8583
  $fToIptables[]0 ::
    InstructionsToIptables.ToIptables [Types.Criteria]
  DFunId[0]
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE (sat-args=0),
     Unfolding: InlineRule (0, False, True)
                InstructionsToIptables.$cconvert2
                  `cast`
                (Sym (InstructionsToIptables.NTCo:ToIptables[0]
                          <[Types.Criteria]>_N)) -}
ee2bfd9c0142bfb5e89e36a1ddb00313
  $s$fFoldableMap_$celem1 ::
    Types.Criteria
    -> Data.Map.Base.Map k Types.Criteria -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
cf1766087246db5e8b4586cb3f334c77
  $w$cconvert :: IptablesTypes.Command -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: IptablesTypes.Command ->
                 case w of wild {
                   DEFAULT -> InstructionsToIptables.$cconvert1
                   IptablesTypes.Append s -> GHC.CString.unpackAppendCString# "-A "# s
                   IptablesTypes.Insert s i
                   -> GHC.CString.unpackAppendCString#
                        "-I "#
                        (GHC.Base.++
                           @ GHC.Types.Char
                           s
                           (GHC.CString.unpackAppendCString#
                              " "#
                              (case i of ww2 { GHC.Types.I# ww3 ->
                               case GHC.Show.$wshowSignedInt
                                      0
                                      ww3
                                      (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                               GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))) }) -}
285d81f536ba5e2eb7368c0ecc16b4bb
  $w$cconvert1 :: [Types.Criteria] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
1a263c5368d8daf022aa8fecbc578487
  $w$cconvert2 ::
    [Types.Criteria]
    -> [Types.Target] -> NameIdChain.IdNameChain -> GHC.Base.String
  {- Arity: 3,
     Strictness: <S,1*U><L,1*U><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Inline: [0],
     Unfolding: (\ ww :: [Types.Criteria]
                   ww1 :: [Types.Target]
                   w :: NameIdChain.IdNameChain ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (InstructionsToIptables.$w$cconvert1 ww)
                   (InstructionsToIptables.$cconvert8 ww1 w)) -}
ff1640a7e1b8f85c5a370aa4d5fbb76e
  $waddToStringAtLine ::
    GHC.Base.String
    -> GHC.Prim.Int# -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,1*U>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Base.String
                   ww :: GHC.Prim.Int#
                   w1 :: GHC.Base.String ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.-# ww 1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> let {
                        $j :: [GHC.Base.String] -> [GHC.Base.String] -> [GHC.Types.Char]
                          {- Arity: 2, Strictness: <S,1*U><L,U> -}
                        = \ x1 :: [GHC.Base.String][OneShot]
                            xs :: [GHC.Base.String][OneShot] ->
                          let {
                            z :: [GHC.Types.Char]
                            = InstructionsToIptables.addToStringAtLine_go1
                                (GHC.Types.: @ GHC.Base.String w xs)
                          } in
                          letrec {
                            go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ ds :: [[GHC.Types.Char]] ->
                              case ds of wild {
                                [] -> z
                                : y ys
                                -> GHC.Base.++
                                     @ GHC.Types.Char
                                     y
                                     (GHC.CString.unpackAppendCString# "\n"# (go ys)) }
                          } in
                          go x1
                      } in
                      case Data.OldList.lines w1 of wild {
                        []
                        -> $j
                             (GHC.Types.[] @ GHC.Base.String)
                             (GHC.Types.[] @ GHC.Base.String)
                        : ipv ipv1
                        -> case x of ds1 {
                             DEFAULT
                             -> let {
                                  ds2 :: ([GHC.Base.String], [GHC.Base.String])
                                  = case GHC.List.splitAt_$s$wsplitAt'
                                           @ GHC.Base.String
                                           (GHC.Prim.-# ds1 1)
                                           ipv1 of ww1 { (#,#) ww2 ww3 ->
                                    (ww2, ww3) }
                                } in
                                $j
                                  (GHC.Types.:
                                     @ GHC.Base.String
                                     ipv
                                     (case ds2 of wild2 { (,) xs' xs'' -> xs' }))
                                  (case ds2 of wild2 { (,) xs' xs'' -> xs'' })
                             1
                             -> $j
                                  (GHC.Types.:
                                     @ GHC.Base.String
                                     ipv
                                     (GHC.Types.[] @ GHC.Base.String))
                                  ipv1 } }
                   GHC.Types.True
                   -> InstructionsToIptables.addToStringAtLine_go
                        (GHC.Types.: @ GHC.Base.String w (Data.OldList.lines w1)) }) -}
f45a0693d09c8a0c680195c2fe465697
  $wconvertBoolFlags ::
    [Types.Criteria] -> (# GHC.Base.String, [Types.Criteria] #)
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ w :: [Types.Criteria] ->
                 let {
                   ds :: ([Types.Criteria], [Types.Criteria])
                   = case InstructionsToIptables.$wgo1 w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (# GHC.CString.unpackAppendCString#
                      "--tcp-flags "#
                      (case ds of wild { (,) b' xs' ->
                       case InstructionsToIptables.$wgo b' of ww { (#,#) ww1 ww2 ->
                       let {
                         a :: [GHC.Types.Char]
                         = GHC.CString.unpackAppendCString#
                             " "#
                             (case ww2 of wild1 {
                                [] -> InstructionsToIptables.convertBoolFlags4
                                : ds1 ds2
                                -> case GHC.Base.map
                                          @ Types.Criteria
                                          @ [GHC.Types.Char]
                                          Types.flagsToStrings
                                          wild1 of wild2 {
                                     [] -> InstructionsToIptables.convertBoolFlags3
                                     : x xs
                                     -> GHC.Base.++
                                          @ GHC.Types.Char
                                          (InstructionsToIptables.convertBoolFlags_go1
                                             (GHC.Types.:
                                                @ [GHC.Types.Char]
                                                x
                                                (Data.OldList.prependToAll
                                                   @ [GHC.Types.Char]
                                                   InstructionsToIptables.convertBoolFlags2
                                                   xs)))
                                          InstructionsToIptables.convertBoolFlags3 } })
                       } in
                       let {
                         z :: [[GHC.Types.Char]]
                         = GHC.Base.map
                             @ Types.Criteria
                             @ [GHC.Types.Char]
                             InstructionsToIptables.convertBoolFlags1
                             ww1
                       } in
                       letrec {
                         go :: [Types.Criteria] -> [[GHC.Types.Char]]
                           {- Arity: 1, Strictness: <S,1*U> -}
                         = \ ds1 :: [Types.Criteria] ->
                           case ds1 of wild1 {
                             [] -> z
                             : y ys
                             -> GHC.Types.:
                                  @ [GHC.Types.Char]
                                  (Types.flagsToStrings y)
                                  (go ys) }
                       } in
                       case go ww2 of wild1 {
                         [] -> a
                         : x xs
                         -> GHC.Base.++
                              @ GHC.Types.Char
                              (InstructionsToIptables.convertBoolFlags_go
                                 (GHC.Types.:
                                    @ [GHC.Types.Char]
                                    x
                                    (Data.OldList.prependToAll
                                       @ [GHC.Types.Char]
                                       InstructionsToIptables.convertBoolFlags2
                                       xs)))
                              a } } }),
                    case ds of wild { (,) b' xs' -> xs' } #)) -}
37504d8c3b06c3c1762726bf8c1c9d63
  $wgo ::
    [Types.Criteria] -> (# [Types.Criteria], [Types.Criteria] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
0db34bd0e2e7aef27e8c418cbeb8e947
  $wgo1 ::
    [Types.Criteria] -> (# [Types.Criteria], [Types.Criteria] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
492aba00e0dc7d678bdc3d4561da8583
  class ToIptables a where
    convert :: a -> NameIdChain.IdNameChain -> GHC.Base.String
5e70fd44cd93390af23b44906d772580
  addToIptables ::
    [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
    -> NameIdChain.IdNameChain -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3,
     Strictness: <S,1*U><L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><L,U> -}
d23742ce09e574c000ce0db10583c848
  addToStringAtLine ::
    GHC.Base.String
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><S,1*U(U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Base.String
                   w1 :: GHC.Types.Int
                   w2 :: GHC.Base.String ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 InstructionsToIptables.$waddToStringAtLine w ww1 w2 }) -}
56a590abe56227e8c97dfe51d490d12d
  addToStringAtLine_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4972878bc093bcd7f00508eea5635419
  addToStringAtLine_go1 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
97dab626925b25761cd2dc8a0271b91a
  convertBoolFlags ::
    [Types.Criteria] -> (GHC.Base.String, [Types.Criteria])
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [Types.Criteria] ->
                 case InstructionsToIptables.$wconvertBoolFlags
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
6da4b30a6813b0bdb4f03f714d0ed471
  convertBoolFlags1 :: Types.Criteria -> [GHC.Types.Char]
  {- Arity: 1,
     Unfolding: (\ x :: Types.Criteria ->
                 case Types.ifNotRemoveNot x of wild {
                   DEFAULT -> GHC.Types.[] @ GHC.Types.Char
                   Types.BoolFlag f
                   -> case Types.$slookup1
                             @ [GHC.Types.Char]
                             f
                             Types.flagsToStrings' of wild1 {
                        GHC.Base.Nothing -> Data.Maybe.fromJust1 @ GHC.Base.String
                        GHC.Base.Just x1 -> x1 } }) -}
04f35b44354ec6f003f4d9581ab0f1e8
  convertBoolFlags2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
f1e567bc29467946a2bcb623ddb55a32
  convertBoolFlags3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " "#) -}
2cdaae0336ddb86bcc382ed31aaa6e31
  convertBoolFlags4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   InstructionsToIptables.convertBoolFlags5
                   InstructionsToIptables.convertBoolFlags3) -}
af64436500dbc9234f9880f3cb20923c
  convertBoolFlags5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NONE"#) -}
2bb1dfaf32dcc4560432ceadbf6f1c8b
  convertBoolFlags_go :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0a40f75dfbf26d2feced738320b8472c
  convertBoolFlags_go1 :: [[GHC.Types.Char]] -> [GHC.Types.Char]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
ec00b4af5245c8149ae3699f6707fa86
  increaseLabelsAbove ::
    GHC.Types.Int
    -> [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
    -> [(Types.Rule, GHC.Base.String, GHC.Types.Int)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U(U)><S,1*U> -}
instance InstructionsToIptables.ToIptables [IptablesTypes.Command]
  = InstructionsToIptables.$fToIptablesCommand
instance InstructionsToIptables.ToIptables [Types.GenRule]
  = InstructionsToIptables.$fToIptablesGenRule
instance InstructionsToIptables.ToIptables [Types.Target]
  = InstructionsToIptables.$fToIptablesTarget
instance InstructionsToIptables.ToIptables [[]]
  = InstructionsToIptables.$fToIptables[]
instance InstructionsToIptables.ToIptables [[]]
  = InstructionsToIptables.$fToIptables[]0
"SPEC/InstructionsToIptables convert @ Command" [ALWAYS] forall tpl :: InstructionsToIptables.ToIptables
                                                                         IptablesTypes.Command
  InstructionsToIptables.convert @ IptablesTypes.Command tpl
  = InstructionsToIptables.$cconvert
"SPEC/InstructionsToIptables convert @ Rule" [ALWAYS] forall tpl :: InstructionsToIptables.ToIptables
                                                                      Types.Rule
  InstructionsToIptables.convert @ (Types.GenRule Types.Criteria) tpl
  = InstructionsToIptables.$cconvert9
"SPEC/InstructionsToIptables convert @ Target" [ALWAYS] forall tpl :: InstructionsToIptables.ToIptables
                                                                        Types.Target
  InstructionsToIptables.convert @ Types.Target tpl
  = InstructionsToIptables.$cconvert3
"SPEC/InstructionsToIptables convert @ [Criteria]" [ALWAYS] forall tpl :: InstructionsToIptables.ToIptables
                                                                            [Types.Criteria]
  InstructionsToIptables.convert @ [Types.Criteria] tpl
  = InstructionsToIptables.$cconvert2
"SPEC/InstructionsToIptables convert @ [Target]" [ALWAYS] forall tpl :: InstructionsToIptables.ToIptables
                                                                          [Types.Target]
  InstructionsToIptables.convert @ [Types.Target] tpl
  = InstructionsToIptables.$cconvert8
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

