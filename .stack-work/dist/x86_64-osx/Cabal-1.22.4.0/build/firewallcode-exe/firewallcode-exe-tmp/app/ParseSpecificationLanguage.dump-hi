
==================== FINAL INTERFACE ====================
2016-09-05 18:30:59.964322 UTC

interface main@main:ParseSpecificationLanguage 7102
  interface hash: f33ceac8f8c8bff4f873b2a2dc3e51ab
  ABI hash: e7948a71fd5650447e740d5d4251cf75
  export-list hash: b805ccfb33b37dfdd4f2cd95d84acb07
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: dbae8b6274c43fc2a73ebb33608e06d9
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParseSpecificationLanguage.conjunctionAtFront
  ParseSpecificationLanguage.findAfterLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis
  ParseSpecificationLanguage.findInLeadingParenthesis'
  ParseSpecificationLanguage.isConjunction
  ParseSpecificationLanguage.lexer
  ParseSpecificationLanguage.parse
  ParseSpecificationLanguage.parseInstruction
  ParseSpecificationLanguage.parseRule
  ParseSpecificationLanguage.parseSpecificationCriteria
  ParseSpecificationLanguage.parseSpecificationCriteria'
  ParseSpecificationLanguage.parseSpecificationTarget
  ParseSpecificationLanguage.toConjunction
module dependencies: ParserHelp Types
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0* binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      case-insensitive-1.2.0.7@casei_I0T7EQSGXb8L7vKDNltr0H
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      hashable-1.2.4.0@hasha_7lZto9aEWI74IRoYrJM1Mm integer-gmp-1.0.0.0
                      semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I
                      split-0.2.3.1@split_Gd41gNkg1RrKgDS2jZ4Qe5
                      tagged-0.8.5@tagge_3xPBWzsl8Q1ImKSiXIolCi
                      text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010
                      tostring-0.2.1.1@tostr_9mRZFMcnuWXE8LUkKdBchW
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb
                      utf8-string-1.0.1.1@utf8s_HWC8Qen5AZrArJxFQJuE72
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         hashable-1.2.4.0@hasha_7lZto9aEWI74IRoYrJM1Mm:Data.Hashable.Generic
         main@main:Types text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text
         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Lazy
         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Show
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I:Data.List.NonEmpty
                         semigroups-0.18.2@semig_2XoUd9gQ2RU8GmCVR7Zp0I:Data.Semigroup
                         tagged-0.8.5@tagge_3xPBWzsl8Q1ImKSiXIolCi:Data.Tagged
                         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text
                         text-1.2.2.1@text_DHzFFGZ106YGOWoHRNT010:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb:Data.HashMap.Base
                         unordered-containers-0.2.7.1@unord_1LtcJdHkai20BJ4Qj1mjtb:Data.HashSet
import  -/  base-4.8.1.0:Data.Char ba93ec4ca3776f6d9a8c8a6223b2fb26
import  -/  base-4.8.1.0:Data.Either bc9482e78cc431fce439b593377aa2e6
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.List 2a4f5f92892d432e7113f64cd9dcca53
import  -/  base-4.8.1.0:Data.Maybe 1cb58de2b04ee3c0c0a7dc9201184aff
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Unicode bed09d5db094d4196c8520e6b25efaa4
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:Text.Read 30509137a501bd56d136aca29a7a35a6
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map 5e4cbf1ca2e6c8cfaecf2b4e95371357
import  -/  containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base 7ea108dc1481cad0b32efe810e49ad43
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ParserHelp 2963101e3925b4b7443579b40db62a20
  exports: e7d64e37248c29bbbe084ee8d6572989
  isInteger 6fd687954b869378a68326f1c0f508af
import  -/  Types 539e504492eacb62971b007037e46fe7
  exports: c4323cb63359ad0358876fdfba25ce76
  ACCEPT f6849424ce0242a5a46c02798e52f2f7
  And db4edde8823eace970274e7ccd21c4b1
  DROP a7dd49650f16feba32915c23abcd7cc2
  Destination bf0b836c6fdf993fa1278ff9317ec8f9
  InC d8169ce313a683f4e480862d7a1760ee
  InCNot 0a10d16082ef3abb0f0160fcac15b65f
  InputCriteria 72d95dc0eb482fd323c2578611b23498
  InputInstruction 88269c7e433cc7c68c295f52a518985a
  InputRule f8cda0a866712c372c0afb7990e381cb
  NoInstruction 7aa1252dfb7cbf67f127561bc2193fc8
  Or b2789a518060e8063e505536191bddbc
  Port bc39a03feb63e6236cbedbfcdfc736da
  Protocol 1dd54f33dcea36ae94747ac76558d75a
  Rule 415230da6bf948321541e9ace77f4a95
  SC 2a711fbf2e6141bf6b95795c34ceb2bb
  Source 50b6d3438de54d28d9b9c458a48cedf9
  Target c2ab377181a680cc86186fdc5c3fa065
  ToChainNamed 2f5a00e1e189a94530d72423141b9d45
  stringsToFlags 035057b6fd3254f36db3f68f8c235237
import  -/  split-0.2.3.1@split_Gd41gNkg1RrKgDS2jZ4Qe5:Data.List.Split d75b5c2f3d62635a3c6bc72afe2b6c2e
import  -/  split-0.2.3.1@split_Gd41gNkg1RrKgDS2jZ4Qe5:Data.List.Split.Internals ec4f367173781fb33bc362ea0d0a839b
53a74402e956a4cc892940e3ad0531e9
  $slookup1 ::
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
51718238157910387621a1723e734659
  $wparseSpecificationCriteria' ::
    [GHC.Base.String] -> (# Types.InputCriteria, [GHC.Base.String] #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
5600d42567e5666e1fb69bf50d48b14f
  $wparseSpecificationTarget ::
    [GHC.Base.String] -> (# Types.Target, [Types.Target] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> case ParseSpecificationLanguage.parseSpecificationTarget3
                      ret_ty (# Types.Target, [Types.Target] #)
                      of {}
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseSpecificationTarget2 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString
                                  ds1
                                  ParseSpecificationLanguage.parseSpecificationTarget1 of wild2 {
                             GHC.Types.False
                             -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                ret_ty (# Types.Target, [Types.Target] #)
                                of {}
                             GHC.Types.True
                             -> case ds2 of wild3 {
                                  [] -> (# Types.DROP, GHC.Types.[] @ Types.Target #)
                                  : ipv ipv1
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } }
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (# Types.ACCEPT, GHC.Types.[] @ Types.Target #)
                             : ipv ipv1
                             -> case GHC.Base.eqString
                                       ds1
                                       ParseSpecificationLanguage.parseSpecificationTarget1 of wild3 {
                                  GHC.Types.False
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {}
                                  GHC.Types.True
                                  -> case ParseSpecificationLanguage.parseSpecificationTarget3
                                     ret_ty (# Types.Target, [Types.Target] #)
                                     of {} } } } }) -}
1d067a16bba19928ef9d851108547edd
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
29ee2016f17a0ec981bf3020816c53bb
  conjunctionAtFront ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   []
                   -> GHC.Base.Nothing
                        @ ([Types.InputCriteria] -> Types.InputCriteria)
                   : ipv ipv1
                   -> case GHC.List.elem
                             @ GHC.Base.String
                             GHC.Classes.$fEq[]_$s$fEq[]1
                             ipv
                             ParseSpecificationLanguage.conjunctionAtFront2 of wild1 {
                        GHC.Types.False
                        -> ParseSpecificationLanguage.conjunctionAtFront1 wild
                        GHC.Types.True
                        -> ParseSpecificationLanguage.toConjunction ipv } }) -}
7eb6b40ff6651d299bc10fd3809f9b01
  conjunctionAtFront1 ::
    [GHC.Base.String]
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <L,U>b -}
0527e616fe505f0e7e5090bb12d14955
  conjunctionAtFront2 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction4
                   ParseSpecificationLanguage.conjunctionAtFront3) -}
6befb3cd238bc817cb5ed4ea04efd41e
  conjunctionAtFront3 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.toConjunction3
                   (GHC.Types.[] @ GHC.Base.String)) -}
4d7761683ba7c466d784334245bc7025
  findAfterLeadingParenthesis ::
    [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ s :: [GHC.Base.String] ->
                 case GHC.List.$wlenAcc
                        @ [GHC.Types.Char]
                        (ParseSpecificationLanguage.findInLeadingParenthesis s)
                        0 of ww2 { DEFAULT ->
                 let {
                   x :: GHC.Prim.Int# = GHC.Prim.+# 2 ww2
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# x 0) of wild1 {
                   GHC.Types.False
                   -> ParseSpecificationLanguage.$wunsafeDrop @ GHC.Base.String x s
                   GHC.Types.True -> s } }) -}
d0b74c6656242cb7c2ad3fe0ed1c40ae
  findInLeadingParenthesis :: [GHC.Base.String] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds1 :: [GHC.Base.String] ->
                 case ds1 of wild {
                   [] -> GHC.Types.[] @ GHC.Base.String
                   : ds2 xs
                   -> case ds2 of wild1 {
                        [] -> wild
                        : ds3 ds4
                        -> case ds3 of wild2 { GHC.Types.C# ds5 ->
                           case ds5 of ds6 {
                             DEFAULT -> wild
                             '('
                             -> case ds4 of wild3 {
                                  []
                                  -> ParseSpecificationLanguage.findInLeadingParenthesis'
                                       xs
                                       ParseSpecificationLanguage.findInLeadingParenthesis1
                                  : ipv ipv1 -> wild } } } } }) -}
ceb78809f0f26de26b2c1c90fdf4f3d4
  findInLeadingParenthesis' ::
    [GHC.Base.String] -> GHC.Types.Int -> [GHC.Base.String]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
b4bafc8d32969d530810c80050a7b061
  findInLeadingParenthesis1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
f36dcc62cf478c86855b3b8802eeb668
  isConjunction :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Base.String ->
                 GHC.List.elem
                   @ GHC.Base.String
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   s
                   ParseSpecificationLanguage.conjunctionAtFront2) -}
77c583e36e586e5038c1f8ebe9f4eeb6
  lexer :: GHC.Base.String -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,U> -}
4eea5a46c0d562726fe7ef75745cd0a3
  parse :: [GHC.Base.String] -> [Types.InputInstruction]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: [GHC.Base.String] ->
                 GHC.Base.build
                   @ (Types.SynthInstruction Types.InputRule)
                   (\ @ b1
                      c :: Types.SynthInstruction Types.InputRule -> b1 -> b1[OneShot]
                      n2 :: b1[OneShot] ->
                    GHC.Base.foldr
                      @ [GHC.Base.String]
                      @ b1
                      (GHC.Base.mapFB
                         @ (Types.SynthInstruction Types.InputRule)
                         @ b1
                         @ [GHC.Base.String]
                         c
                         ParseSpecificationLanguage.parse3)
                      n2
                      (Data.List.Split.Internals.splitOn
                         @ GHC.Base.String
                         GHC.Classes.$fEq[]_$s$fEq[]1
                         ParseSpecificationLanguage.parse1
                         s))) -}
58b324383b26a2c39973a350073b7c40
  parse1 :: [GHC.Base.String]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ GHC.Base.String
                   ParseSpecificationLanguage.parse2
                   (GHC.Types.[] @ GHC.Base.String)) -}
26c4898de41ab3d8d4b34ee3e497f85e
  parse2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
8862278d7241e0e07dc583cde2e29035
  parse3 ::
    [GHC.Base.String] -> Types.SynthInstruction Types.InputRule
  {- Arity: 1, Strictness: <S,1*U> -}
92cea3bc3bc7f99112777b1620c1ba64
  parseInstruction ::
    [GHC.Base.String]
    -> ([GHC.Base.String], Types.InputRule -> Types.InputInstruction)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case w of wild {
                   []
                   -> (GHC.Types.[] @ GHC.Base.String,
                       Types.NoInstruction @ Types.InputRule)
                   : ds1 ds2
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.parseInstruction1 of wild1 {
                        GHC.Types.False -> (wild, Types.NoInstruction @ Types.InputRule)
                        GHC.Types.True
                        -> case ds2 of wild2 {
                             [] -> (wild, Types.NoInstruction @ Types.InputRule)
                             : c ds3
                             -> case ds3 of wild3 {
                                  [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                  : ds4 xs
                                  -> case ds4 of wild4 {
                                       [] -> (wild, Types.NoInstruction @ Types.InputRule)
                                       : ds5 ds6
                                       -> case ds5 of wild5 { GHC.Types.C# ds7 ->
                                          case ds7 of ds8 {
                                            DEFAULT -> (wild, Types.NoInstruction @ Types.InputRule)
                                            ':'
                                            -> case ds6 of wild6 {
                                                 [] -> (xs, Types.ToChainNamed @ Types.InputRule c)
                                                 : ipv ipv1
                                                 -> (wild,
                                                     Types.NoInstruction
                                                       @ Types.InputRule) } } } } } } } }) -}
802964f1452876f449be5fd1ce6d8d33
  parseInstruction1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "chain"#) -}
3c376fd67631e341469fde9ebc057275
  parseRule :: [GHC.Base.String] -> Types.InputRule
  {- Arity: 1, Strictness: <L,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 let {
                   ds1 :: ([[GHC.Types.Char]], [[GHC.Types.Char]])
                   = case GHC.List.$wbreak
                            @ [GHC.Types.Char]
                            ParseSpecificationLanguage.parseRule2
                            w of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 Types.Rule
                   @ Types.InputCriteria
                   (case ds1 of wild { (,) c t ->
                    ParseSpecificationLanguage.parseSpecificationCriteria c })
                   (case ds1 of wild { (,) c t ->
                    case t of wild1 {
                      [] -> GHC.Types.[] @ Types.Target
                      : ds2 ds3
                      -> ParseSpecificationLanguage.parseSpecificationTarget ds3 } })
                   ParseSpecificationLanguage.parseRule1) -}
4e1aa3c7235175078574a6fe2ace1dff
  parseRule1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# (-1)) -}
f11aeed7f40136dbbadae8dd00d82bac
  parseRule2 :: GHC.Base.String -> GHC.Types.Bool
  {- Arity: 1,
     Unfolding: (GHC.Base.eqString
                   ParseSpecificationLanguage.parseRule3) -}
dbee4f01564b53798434edbcb7966178
  parseRule3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "=>"#) -}
241f2719dd338c9ca4f736f1c66bd694
  parseSpecificationCriteria ::
    [GHC.Base.String] -> [Types.InputCriteria]
  {- Arity: 1, Strictness: <S,1*U> -}
c0c56c4b3c9cd7545191de38b5efbd93
  parseSpecificationCriteria' ::
    [GHC.Base.String] -> (Types.InputCriteria, [GHC.Base.String])
  {- Arity: 1, Strictness: <S,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationCriteria'
                        w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
08afb57de781a557a8e476d556c3731f
  parseSpecificationTarget :: [GHC.Base.String] -> [Types.Target]
  {- Arity: 1, Strictness: <S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: [GHC.Base.String] ->
                 case ParseSpecificationLanguage.$wparseSpecificationTarget
                        w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.Target ww1 ww2 }) -}
62df66a2d2ef0c5b358cb09be796dd0d
  parseSpecificationTarget1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "DROP"#) -}
14dfb52ab0a9d18677968e9cc9ff000f
  parseSpecificationTarget2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ACCEPT"#) -}
e2734371484764d1f99b3a0a05d83d0e
  parseSpecificationTarget3 :: [Types.Target]
  {- Strictness: b -}
c290b0a88dc98b248dabf38fe58e0379
  toConjunction ::
    GHC.Base.String
    -> GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ ds1 :: [GHC.Types.Char] ->
                 case GHC.Base.eqString
                        ds1
                        ParseSpecificationLanguage.toConjunction4 of wild {
                   GHC.Types.False
                   -> case GHC.Base.eqString
                             ds1
                             ParseSpecificationLanguage.toConjunction3 of wild1 {
                        GHC.Types.False
                        -> GHC.Base.Nothing
                             @ ([Types.InputCriteria] -> Types.InputCriteria)
                        GHC.Types.True -> ParseSpecificationLanguage.toConjunction2 }
                   GHC.Types.True -> ParseSpecificationLanguage.toConjunction1 }) -}
0d3eeebc595372304a4464bf845b12ec
  toConjunction1 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.And) -}
a6c3fb9264e45fed788db6f2e1cab376
  toConjunction2 ::
    GHC.Base.Maybe ([Types.InputCriteria] -> Types.InputCriteria)
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Base.Just
                   @ ([Types.InputCriteria] -> Types.InputCriteria)
                   Types.Or) -}
32411603950933f2263a8a8ea34cdb04
  toConjunction3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OR"#) -}
25d50274f34a8034738a2d09fa7b7918
  toConjunction4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AND"#) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

